<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UOJ 221「NOI2016」循环之美]]></title>
    <url>%2F2018%2F07%2F21%2FNOI2016D1T3%2F</url>
    <content type="text"><![CDATA[Description求有多少数值不同的分数$\frac{x}{y}$（$1\leq x\leq n, 1\leq y\leq m$），满足其在$k$进制下化为小数之后事纯循环小数（即小数部分是无限循环的）。 $1\leq n, m\leq 10^9,2\leq k\leq 2000$。 Solution首先如果只统计最简分数就能保证数值相同辣（即钦点$x\perp y$，这里用垂直符号表示互质）。然后通过猜结论等手段可以发现纯循环小数其实限制了$y\perp k$。 然后考虑颓柿子： \begin{aligned} \quad&\sum_{x = 1}^n\sum_{y = 1}^m [x\perp y][y\perp k]\\ =&\sum_{x = 1}^n\sum_{y = 1,y\perp k}^m \sum_{d | x, d | y}\mu(d)\\ =&\sum_{d = 1,d\perp k}^{\min(n, m)}\mu(d)\lfloor\frac{n}{d}\rfloor\sum_{y = 1}^{\lfloor\frac{m}{d}\rfloor}[y\perp k] \end{aligned}然后这样是个反演的形式……很容易想到数论分块罢…… 接下来首先要考虑对于所有$\lfloor\frac{m}{d}\rfloor$处理出范围内和$k$互质的数的数量，这个很容易想到洲阁筛的思路。考虑筛出$k$的所有质因子$p_1,p_2,\ldots,p_c$，定义状态$f(i, j)$表示不大于$j$且和$p_1, p_2,\ldots,p_i$互质的数的数目（边界为$f(0, j) = j$）。然后转移很显然是： f(i, j) = f(i - 1, j) - f(i - 1, \lfloor\frac{j}{p_i}\rfloor)然后我们还有一块硬骨头……就是对于所有$\lfloor\frac{n}{d}\rfloor$要求出范围内和$k$互质的$d$的$\mu(d)$的和。还是采用洲阁筛的思路，定义$g(i, j)$表示对于所有$d$满足$d\leq j$且$d\perp p_1, p_2,\ldots, p_i$的$\mu(d)$的和，这样边界$g(0, j)$也就是直接对$\mu$求一个前缀和，这个杜教筛处理。其他情况的话，我们要排除在一个没有前$i$个质因子的数的基础上乘上$p_i$的情况（如果有$p_i$这个质因子的话再乘一遍就变成0了，所以对答案没有影响），故转移如下： g(i,j)=g(i - 1, j) + g(i, \lfloor\frac{j}{p_i}\rfloor)考虑到这题$k$不大，所以第一维非常的小，甚至不需要用洲阁筛的一般加速方法。总复杂度为$O(n^\frac{2}{3} + \omega(k)\sqrt{n})$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;unordered_map&gt;using ll = long long;const int N = 10000000;int mu[N + 5]; int mu_S[N + 5];int prm[N + 5]; bool vis[N + 5];void process() &#123; mu[1] = 1; vis[1] = true; int cnt = 0; for(int i = 2; i &lt;= N; i ++) &#123; if(!vis[i]) &#123; prm[cnt ++] = i; mu[i] = -1; &#125; for(int j = 0; j &lt; cnt &amp;&amp; i * prm[j] &lt;= N; j ++) &#123; int v = i * prm[j]; vis[v] = true; if(i % prm[j] == 0) &#123; mu[v] = 0; break; &#125; else &#123; mu[v] = -mu[i]; &#125; &#125; &#125; for(int i = 1; i &lt;= N; i ++) &#123; mu_S[i] = mu_S[i - 1] + mu[i]; &#125;&#125;int p[12]; int pcnt;void desc(int x) &#123; pcnt = 0; int l = sqrt(x + 0.5); for(int i = 2; i &lt;= l; i ++) &#123; if(x % i == 0) &#123; p[++ pcnt] = i; while(x % i == 0) x /= i; &#125; &#125; if(x &gt; 1) p[++ pcnt] = x;&#125;std::unordered_map&lt;int, ll&gt; h1[12];ll calc_1(int c, int n) &#123; if(c == 0) return n; if(n == 0) return 0; if(h1[c].count(n)) return h1[c][n]; ll ret = calc_1(c - 1, n) - calc_1(c - 1, n / p[c]); h1[c][n] = ret; return ret;&#125;std::unordered_map&lt;int, ll&gt; h2[12];ll calc_2(int c, int n) &#123; if(c == 0) &#123; if(n &lt;= N) return mu_S[n]; if(h2[0].count(n)) return h2[0][n]; ll ret = 1; for(int i = 2; i &lt;= n;) &#123; int next = n / (n / i); ret -= (ll(next - i + 1)) * calc_2(0, n / i); i = next + 1; &#125; h2[0][n] = ret; return ret; &#125; if(n == 0) return 0; if(h2[c].count(n)) return h2[c][n]; ll ret = calc_2(c - 1, n) + calc_2(c, n / p[c]); h2[c][n] = ret; return ret;&#125;ll calc(int n, int m, int k) &#123; desc(k); ll ans = 0; ll las = 0; for(int i = 1; i &lt;= std::min(n, m);) &#123; int next = std::min(n / (n / i), m / (m / i)); ll th = n / i; th *= (ll)calc_1(pcnt, m / i); ll ts = calc_2(pcnt, next); th *= (ts - las); ans += th; i = next + 1; las = ts; &#125; return ans;&#125;int main() &#123; process(); int n, m, k; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); printf("%lld\n", calc(n, m, k)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>UOJ</tag>
        <tag>NOI</tag>
        <tag>狄利克雷卷积</tag>
        <tag>莫比乌斯反演</tag>
        <tag>洲阁筛</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3551「ONTAK2010」Peaks加强版]]></title>
    <url>%2F2018%2F07%2F18%2FBZOJ3551%2F</url>
    <content type="text"><![CDATA[真他X的是个弟弟。 初中会嘴巴的东西，高中不会了。 写了骗分，被多组数据雷普了，从75到5。 我谔谔，还事书这题罢，，， 这题大概可以用可持久化并查集套可持久化平衡树或权值线段树啥的做一下（逃 然后我们考虑用一种简单的做法…… 如果我们最后的并查集树中只有原图中的点的话，那么很多信息会非常难处理，那么是否可以考虑引入边？ 在Kruskal的过程中，边被从小到大加入。那么我们给每个边建一个点，用来维护经过这条边才能联通的点的信息。最后我们会得到一棵满二叉树。 这样的好处事有很多的……首先我们可以把信息维护在边上了。这个题要求$k$大，所以我们就用可持久化权值线段树吧，然后每个非叶子结点合并信息的时候直接可持久化的线段树合并就行了。 然后还有一个小好处，就是这棵树显然从叶子向上的边点的权值事单调不降的，这样我们可以直接倍增找到一个最往上的符合限制的祖先，用这个祖先的信息就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;const int maxn = 200005;const int maxm = 500005;int n, m;struct Edge &#123; int u, v, d; bool operator &lt;(const Edge &amp;res) const &#123; return d &lt; res.d; &#125;&#125;;Edge E[maxm];const int bufsiz = 1024 * 1024 * 40;char buf[bufsiz]; char *cur = buf;void *alloc(size_t size) &#123; if(cur - buf + size &gt; bufsiz) &#123; return malloc(size); &#125; else &#123; char *ret = cur; cur += size; return ret; &#125;&#125;struct Node &#123; int sumv; Node *lc, *rc;&#125;;Node *nil;void init_tree() &#123; nil = (Node*)alloc(sizeof(Node)); nil -&gt; sumv = 0; nil -&gt; lc = nil -&gt; rc = nil;&#125;Node *alloc_node(int v = 0, Node *lc = nil, Node *rc = nil) &#123; Node *ret = (Node*)alloc(sizeof(Node)); ret -&gt; sumv = v; ret -&gt; lc = lc; ret -&gt; rc = rc; return ret;&#125;Node *gen_chain(int L, int R, int p, int v) &#123; if(L == R) &#123; return alloc_node(v); &#125; else &#123; int M = (L + R) / 2; Node *lc = nil, *rc = nil; if(p &lt;= M) &#123; lc = gen_chain(L, M, p, v); &#125; else &#123; rc = gen_chain(M + 1, R, p, v); &#125; return alloc_node(v, lc, rc); &#125;&#125;Node *merge(Node *A, Node *B) &#123; if(A == nil) return B; if(B == nil) return A; Node *lc = merge(A -&gt; lc, B -&gt; lc); Node *rc = merge(A -&gt; rc, B -&gt; rc); Node *ret = alloc_node(A -&gt; sumv + B -&gt; sumv, lc, rc); return ret;&#125;int kth(Node *o, int L, int R, int k) &#123; if(o -&gt; sumv &lt; k) &#123; return 0; &#125; if(L == R) &#123; return L; &#125; else &#123; int M = (L + R) / 2; if(k &lt;= o -&gt; rc -&gt; sumv) &#123; return kth(o -&gt; rc, M + 1, R, k); &#125; else &#123; return kth(o -&gt; lc, L, M, k - o -&gt; rc -&gt; sumv); &#125; &#125;&#125;int p[maxn];void init_set() &#123; for(int i = 1; i &lt;= 2 * n; i ++) &#123; p[i] = i; &#125;&#125;int get_fa(int x) &#123; if(p[x] == x) &#123; return x; &#125; else &#123; return (p[x] = get_fa(p[x])); &#125;&#125;void merge_set(int x, int y) &#123; x = get_fa(x), y = get_fa(y); p[x] = y;&#125;bool is_same(int x, int y) &#123; return (get_fa(x) == get_fa(y));&#125;int h[maxn], h2[maxn]; int lsiz;void desc() &#123; std::copy(h + 1, h + 1 + n, h2 + 1); std::sort(h2 + 1, h2 + 1 + n); lsiz = std::unique(h2 + 1, h2 + 1 + n) - h2 - 1; for(int i = 1; i &lt;= n; i ++) &#123; h[i] = std::lower_bound(h2 + 1, h2 + 1 + lsiz, h[i]) - h2; &#125;&#125;int lim[maxn];int anc[maxn][19]; int cnt;Node *T[maxn];void build_tree() &#123; memset(anc, -1, sizeof(anc)); init_set(); init_tree(); desc(); for(int i = 1; i &lt;= n; i ++) &#123; T[i] = gen_chain(1, lsiz, h[i], 1); &#125; std::sort(E + 1, E + 1 + m); cnt = n; for(int i = 1; i &lt;= m; i ++) &#123; int u = E[i].u, v = E[i].v, l = E[i].d; if(is_same(u, v)) continue; u = get_fa(u); v = get_fa(v); cnt ++; lim[cnt] = l; T[cnt] = merge(T[u], T[v]); anc[u][0] = anc[v][0] = cnt; merge_set(u, cnt); merge_set(v, cnt); &#125; for(int j = 1; (1 &lt;&lt; j) &lt; cnt; j ++) &#123; for(int i = 1; i &lt;= cnt; i ++) &#123; int a = anc[i][j - 1]; if(a != -1) anc[i][j] = anc[a][j - 1]; &#125; &#125;&#125;int get_up(int x, int l) &#123; for(int j = 18; j &gt;= 0; j --) &#123; int a = anc[x][j]; if(a != -1 &amp;&amp; lim[a] &lt;= l) &#123; x = a; &#125; &#125; return x;&#125;int main() &#123; int q; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf("%d", &amp;h[i]); for(int i = 1; i &lt;= m; i ++) &#123; scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].d); &#125; build_tree(); int lastans = 0; h2[0] = -1; while(q --) &#123; int v, x, k; scanf("%d%d%d", &amp;v, &amp;x, &amp;k); if(lastans != -1) &#123; v ^= lastans; x ^= lastans; k ^= lastans; &#125; v = get_up(v, x); printf("%d\n", lastans = h2[kth(T[v], 1, lsiz, k)]);#ifdef LOCAL lastans = 0;#endif &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>ONTAK</tag>
        <tag>Kruskal重构树</tag>
        <tag>权值线段树</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2015」概率论]]></title>
    <url>%2F2018%2F07%2F17%2Floj2105%2F</url>
    <content type="text"><![CDATA[通过OEIS等传统艺能易知答案为$\frac{n(n + 1)}{2(2n - 1)}$。然后下面说一下怎么证明…… 令虑$n$个点的二叉树的方案数为$H_n$（其实很显然就是卡塔兰数列），令$n$个点的所有二叉树的叶子数的和为$F_n$。 考虑推导$H_n$的生成函数。我们知道（下面只考虑$n &gt; 0$，我们钦定$H_0 = 1$）： H_n = \sum_{i = 0}^{n - 1} H_i H_{n - i - 1}所以说对于$H$的生成函数，我们可以列方程： H(x) = xH^2(x) + 1解得： H(x) = \frac{1 \pm \sqrt{1 - 4x}}{2x}通过收敛性可以得知（具体地说……如果取得是加号，那么$H(x)$在0处不收敛，与$H(x)$的零次项系数的取值有限的事实明显背道相驰），应取$H(x) = \frac{1 - \sqrt{1 - 4x}}{2x}$。 由于$H$就是卡塔兰数列，所以有$H_n = \frac{1}{n + 1}\binom{2n}{n}$。 然后对于$F$，我们考虑左右儿子分别的贡献，就可以列式得（这里考虑$n &gt; 1$的情况，$F_1=1$）： F_n = 2\sum_{i = 1}^{n - 1} F_i H_{n - i - 1}所以可以列出方程： F(x) = 2xF(x)H(x) + x然后解得： F(x) = \frac{x}{\sqrt{1 - 4x}}下面那个开根，看起来很不好弄。我们尝试用广义二项式定理展开它，就可以得到： F(x) = \sum_{i = 1}^{+\infty} \binom{-0.5}{i - 1}(-4)^{i - 1} x^i这里牵扯到了任意实数的组合数……定义可以参考维基（具体是二项式定理那篇）。然后我们去考虑$F_n$： \begin{aligned} F_n &= \frac{(-0.5)^{\underline{n - 1}}(-4)^{n - 1}}{(n - 1)!}\\ &=\frac{1}{(n - 1)!}\prod_{i = 0}^{n - 2} (-0.5 - i)\cdot (-4)\\ &=\frac{2^{n - 1}}{(n - 1)!}\prod_{i = 0}^{n - 2} (1 + 2i)\\ &=\frac{2^{n - 1}}{(n - 1)!}\cdot\frac{(2n - 2)!}{2^{n - 1}(n - 1)!}\\ &=\frac{(2n - 2)!}{(n - 1)!(n - 1)!}\\ &=\binom{2n - 2}{n - 1} \end{aligned}最后的答案是一个$\frac{F_n}{H_n}$，不妨推一下： \begin{aligned} \frac{F_n}{H_n} &= \frac{(n + 1)\binom{2n - 2}{n - 1}}{\binom{2n}{n}}\\ &=\frac{(n + 1)(2n - 2)!n!n!}{(n-1)!(n-1)!(2n)!}\\ &=\frac{(n + 1)n^2}{2n(2n - 1)}\\ &=\frac{(n + 1)n}{2(2n - 1)} \end{aligned}终于搞出来了…… 代码不用贴了吧……（逃]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>TJOI</tag>
        <tag>生成函数</tag>
        <tag>广义二项式定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min_25筛学习笔记]]></title>
    <url>%2F2018%2F07%2F14%2FMIN-25-sieve%2F</url>
    <content type="text"><![CDATA[一直想学洲阁筛吧……（这就是我学Min_25筛的理由？） 然后今天终于能yy出来洲阁筛的复杂度证明了……（然后不想写（逃 然后发现了一种更优越的求积性函数前缀和的方法，叫做Min_25筛的……（虽然算是烂大街了？） Min_25筛假设现在有一个积性函数$f$，我们知道他在质数的幂$p^c$上的表现$f(p^c)$，然后要去求它的前缀和。 Min_25筛有个重要的要求就是……$f(p)$（$p$为质数）事一个低次多项式或者一个方便求前缀和的东西。下面就谈谈为什么…… 我们先考虑对于所有状态$\lfloor\frac{n}{x}\rfloor$，求出范围内所有质数的答案。 看起来蛮棘手的……但我们考虑模仿洲阁筛，定义一个状态$g(i, x)$，表示$x$范围内事质数或者和前$i$个质数都互质的数的答案之和。如果说$p_i$达到了$\lfloor\sqrt{n}\rfloor$，那么显然$g(i, x)$就是$x$范围内所有质数的答案了（$p_i$表示第$i$个质数，下同）。 那么考虑转移（接下来出现的$f(p_i)$是指质数的答案多项式中的某一项，因为答案多项式要分开考虑）……对所有$x\geq p_i^2$，使用$g(i, x) = g(i - 1, x) - f(p_i)(g(i - 1,\lfloor\frac{x}{p_i}\rfloor) - g(i - 1, p_i - 1))$转移（之所以后面又补了一个东西是因为要把多减去的小于$p_i$的质数补回来）；至于$x &lt; p_i^2$，我们会发现答案以后就不会变了，因为答案全部都是一堆质数的答案的和（其中不大于$p_i$的一定不是合数，否则必定有小于等于$p_i$的质因子；倘使大于$p_i$的话，没有小于等于$p_i$的质因子也只能有且仅有一个大于$p_i$的质因子，当然就是质数了）。 这一步操作和洲阁筛几乎如出一辙，复杂度证明也完全一致（复杂度为$O(\frac{n^{\frac{3}{4}}}{\ln n})$）。 但是光考虑质数的答案没完惹……再定义状态$f(i, x)$表示$x$范围内和小于$p_i$的质数都互质的数的答案，最终答案显然就是$f(1) + f(1, n)$。那么考虑一个很暴力的策略： 先把质数的答案都算进来（之前预处理了），然后考虑合数的答案。考虑枚举所有不小于$p_i$的质数$p$（假设是第$j$个质数），如果说$p^2 &gt; x$了那么就没法往下转移了（因为这样用上$p$就没法构造合数了），break出来就行了；反之则枚举$p$在数中所占的正指数$e$，对于所有$p^{e + 1}\leq x$，对答案做$f(j + 1, \lfloor\frac{x}{p^e}\rfloor)f(p^e) + f(p^{e + 1})$的贡献（其实就是枚举是否选够了$e$个$p$，然后考虑只用$p$的若干次方的情况）。 这个方法看起来极其暴力（甚至也没记忆化），但是复杂度很玄学（也很优秀）……可以参考朱老大的集训队论文。 例题：SPOJ DIVCNT3这个题显然有$f(p^c) = 3c + 1$，然后根据上面说的搞就行了…… 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;const int maxn = 400005;using ll = long long;int prm[maxn]; ll A[maxn], B[maxn];ll sqr(ll x) &#123; ll ret = 1; while((ret + 1LL) * (ret + 1LL) &lt;= x) ret ++; return ret;&#125;ll n, S;int cnt;void process() &#123; S = sqr(n); cnt = 0;#ifdef LOCAL printf("S : %lld\n", S);#endif for(int i = 1; i &lt;= S; i ++) &#123; A[i] = i; &#125; for(int i = 1; i &lt;= S; i ++) &#123; B[i] = n / (ll(i)); &#125; for(int i = 2; i &lt;= S; i ++) &#123; if(A[i] == A[i - 1]) continue; ll v = A[i - 1], lim = (ll(i)) * (ll(i)); for(int j = 1; j &lt;= (S / i); j ++) &#123; B[j] -= B[j * i] - v; &#125; for(int j = S / i + 1; j &lt;= S; j ++) &#123; ll th = n / (ll(j)); if(th &lt; lim) break; B[j] -= A[th / (ll(i))] - v; &#125; for(int j = S; (ll)j &gt;= lim; j --) &#123; A[j] -= A[j / (ll(i))] - v; &#125; prm[++ cnt] = i; &#125; prm[++ cnt] = S + 1LL;&#125;inline ll query(ll x) &#123; if(x &lt;= S) &#123; return A[x]; &#125; else &#123; return B[n / x]; &#125;&#125;ll calc(ll m, int x) &#123; if(m &lt; (ll)prm[x]) return 0; ll ret = 4LL * (query(m) - query(prm[x] - 1)); for(int i = x; i &lt;= cnt; i ++) &#123; ll mul = prm[i]; if(mul * (ll(prm[i])) &gt; m) break; for(int j = 1; ; j ++) &#123; if(mul * (ll(prm[i])) &gt; m) break; ret += calc(m / mul, i + 1) * (ll(3 * j + 1)) + (ll(3 * j + 4)); mul *= (ll(prm[i])); &#125; &#125; return ret;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T --) &#123; scanf("%lld", &amp;n); process(); printf("%lld\n", calc(n, 1) + 1LL); &#125; return 0;&#125;]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>洲阁筛</tag>
        <tag>Min_25筛</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4261」建设游乐场]]></title>
    <url>%2F2018%2F07%2F11%2FBZOJ4261%2F</url>
    <content type="text"><![CDATA[Description给定一个$n\times m$网格图，其中有一些点是障碍，有一些点是平原。 现在要求你用若干无重边无自环的不相交简单环覆盖所有平原。有一些点$(i, j)$如果满足经过的两条边一条是横着的一套是竖着的那么就会获得$V_{i, j}$的收益。 求是否有解，如果有解的话输出最大收益。 $n\le 150$，$m\le 30$，$0\le V_{i, j}\le 100$。 Solution算是坑了很久的传统艺能题，，， 首先先来一步传统艺能：假设所有收益都能获得，然后问题转化成使笋丝尽可能小，也就变成了如果有一个地方是直的话就会有笋丝。 考虑黑白染色，我们钦点只从黑点往白点连边，这样的话每个黑点要向两个不同的白点（不能走到障碍上）连边。我们要希望所有点都弯着走，我们大可以把所有点全部拆成两个点，一个表示横着走一个表示竖着走，分别向源/汇连容量为1的边，同时他们再往相邻的横着/竖着相邻的点连容量为1的边。 但问题是有些时候有些点肯定只能直着走。那可以用“弯直转换”来表示，具体方法就是把一个点拆出来的横竖点互连容量为1费用为$V_{i, j}$的边。 最后关于是否有解的判定……最后的流量就是原网格图中用了的边的数量，对于每个环的边数都等于点数，因此总边数要等于总点数，因此最后的流量要等于平地的总数量才算有解。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int maxn = (150 * 30) * 2 + 5;struct Edge &#123; int u, v, cap, flow, cost;&#125;;std::vector&lt;int&gt; G[maxn];std::vector&lt;Edge&gt; E;inline void add_edge(int u, int v, int cap, int cost) &#123; E.push_back((Edge)&#123;u, v, cap, 0, cost&#125;); E.push_back((Edge)&#123;v, u, 0, 0, -cost&#125;); int m = E.size(); G[u].push_back(m - 2); G[v].push_back(m - 1);&#125;int a[maxn], d[maxn], p[maxn];bool inq[maxn];int num;const int INF = 0x3f3f3f3f;inline bool spfa(int s, int t, int &amp;flow, int &amp;cost) &#123; std::fill(a, a + num + 1, 0); std::fill(d, d + num + 1, INF); std::fill(p, p + num + 1, 0); std::fill(inq, inq + num + 1, false); std::queue&lt;int&gt; Q; Q.push(s); d[s] = 0; a[s] = INF; inq[s] = true; while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); inq[u] = false; for(int i = 0; i &lt; G[u].size(); i ++) &#123; Edge &amp;e = E[G[u][i]]; int v = e.v; if(e.cap &gt; e.flow &amp;&amp; d[u] + e.cost &lt; d[v]) &#123; d[v] = d[u] + e.cost; p[v] = G[u][i]; a[v] = std::min(a[u], e.cap - e.flow); if(!inq[v]) Q.push(v), inq[v] = true; &#125; &#125; &#125; if(d[t] &gt;= INF) return false; flow += a[t]; cost += d[t] * a[t];#ifdef LOCAL printf("flow delta : %d\n", a[t]); printf("cost delta : %d\n", d[t] * a[t]);#endif int u = t; while(u != s) &#123; Edge &amp;e = E[p[u]]; e.flow += a[t]; E[p[u] ^ 1].flow -= a[t]; u = e.u; &#125; return true;&#125;inline void MCMF(int s, int t, int &amp;flow, int &amp;cost) &#123; while(spfa(s, t, flow, cost));&#125;int n, m;inline int get_p(int i, int j, int t) &#123; int ret = (i - 1) * m + j; ret = ret * 2 - 1 + t; return ret;&#125;int A[155][35], V[155][35];int main() &#123; scanf("%d%d", &amp;n, &amp;m); int s = 0, t = n * m * 2 + 1; num = t; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; scanf("%d", &amp;A[i][j]); &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; scanf("%d", &amp;V[i][j]); if(!A[i][j]) ans += V[i][j]; &#125; &#125; int cnt = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; if(A[i][j]) continue; cnt ++; int p0 = get_p(i, j, 0), p1 = get_p(i, j, 1); add_edge(p0, p1, 1, V[i][j]); add_edge(p1, p0, 1, V[i][j]); if((i + j) &amp; 1) &#123; add_edge(p0, t, 1, 0); add_edge(p1, t, 1, 0); &#125; else &#123; add_edge(s, p0, 1, 0); add_edge(s, p1, 1, 0); if(i &gt; 1 &amp;&amp; !A[i - 1][j]) &#123; add_edge(p0, get_p(i - 1, j, 0), 1, 0); &#125; if(i &lt; n &amp;&amp; !A[i + 1][j]) &#123; add_edge(p0, get_p(i + 1, j, 0), 1, 0); &#125; if(j &gt; 1 &amp;&amp; !A[i][j - 1]) &#123; add_edge(p1, get_p(i, j - 1, 1), 1, 0); &#125; if(j &lt; m &amp;&amp; !A[i][j + 1]) &#123; add_edge(p1, get_p(i, j + 1, 1), 1, 0); &#125; &#125; &#125; &#125;#ifdef LOCAL printf("tot : %d\n", ans);#endif int flow = 0, cost = 0; MCMF(s, t, flow, cost); if(flow &lt; cnt) &#123; puts("-1"); &#125; else &#123; printf("%d\n", ans - cost); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝尔级数在积性函数毒瘤题中的应用]]></title>
    <url>%2F2018%2F07%2F11%2Fbell-series%2F</url>
    <content type="text"><![CDATA[嗯，OC！ 一直以来，数论生成函数在积性函数毒瘤题中的应用都不是很多…… 数论函数的生成函数大概有三种：狄利克雷级数（也叫数论生成函数）、贝尔级数、Lambert级数。Lambert级数不了解，狄利克雷级数太复杂（需要一些复分析的水平，恰好我没有……），能派上用场的也就只有贝尔级数力，，， 下文主要介绍贝尔级数的基本概念，在狄利克雷卷积中的应用，以及在积性函数求和（对我书得就事杜教筛）中的一些微小的应用…… 贝尔级数的概念贝尔级数的定义贝尔级数是一种形式幂级数。对于给定的数论函数$f$和质数$p$，我们定义$f$模$p$的贝尔级数为： f_p(x)=\sum_{i = 0}^{+\infty} f(p^i)x^i贝尔级数的基本性质唯一定理对于两个积性函数$f$和$g$，如果对于任意质数$p$都有$f$和$g$模$p$的贝尔级数相同，那两者相同。 这个定理我局的还事挺好理解的……两个积性函数在任何质数的幂的表现都相同，那么两者也相同。 因为一般的数论函数没有这么优秀的性质……所以下面提到的贝尔级数的应用基本上都针对积性函数…… 狄利克雷卷积对任意两个数论函数$f$和$g$，有$(f\ast g)_p(x) = f_p(x)\cdot g_p(x)$。 这是贝尔级数最有用的性质了……（没这个性质用它干啥？） 完全积性函数的贝尔级数对于一个完全积性函数$f$，有$f_p(x)=\frac{1}{1 - f(p)x}$。 这个也不难理解，用的就是等比数列求和公式。不过好在事形式幂级数，并不需要考虑收敛的问题…… 常用积性函数函数的贝尔级数关于狄利克雷卷积的单位元$\epsilon$（$\epsilon(x) = [x=1]$），不必自说当然是$1$。 首先对于$f(x) = x^k(k\in N^0)$这种东西，根据完全积性函数的贝尔级数公式可知有$f_p(x)=\frac{1}{1 - p^kx}$。 莫比乌斯函数比较有意思。显然$\mu(1) = 1$，$\mu(p) = -1$，但是$\mu(p^k)=0(k\ge 2)$。所以说其贝尔级数就是$1-x$。类似我们可以推导得$\mu^2$的贝尔级数为$1+x$。 欧拉函数直接推有些棘手……但注意到我们知道$\varphi\ast 1 = \mathrm{id}$，反演一下可以得知$\mathrm{id}\ast\mu =\varphi$，由此可得$\varphi_p(x)=\frac{1 - x}{1 - px}$。 接下来介绍一个非常好玩的函数：刘维尔函数。在此之前先定义$\Omega(n)$表示$n$的可重复质因子数（因此$\Omega(4) = 2$），那么刘维尔函数$\lambda(x) = (-1)^{\Omega(x)}$，这个函数很显然是完全积性函数，故$\lambda_p(x)=\frac{1}{1 + x}$。这个函数有些时候是肥肠有用的。 然后考虑约数好兄弟$\sigma_k$。很显然$\sigma_k = \mathrm{id}^k\ast 1$，因此可以推出$(\sigma_k)_p(x)=\frac{1}{1 - p^kx}\cdot\frac{1}{1 - x} = \frac{1}{1 - (1 + p^k)x + p^kx^2}$。 至此常见积性函数已经推完力，，， 贝尔级数在狄利克雷卷积中的应用这个还算是很显然吧…… 举个例子，让你证$(\mathrm{id}\cdot\mu)\ast\mathrm{id} = \epsilon$。 这个东西用传统的计数解方法当然可行，但是多麻烦事有目共睹的（甚至于有些东西被我们的当结论记了）。用贝尔级数的话这个等式不就是$(1 - px)\cdot\frac{1}{1 - px} = 1$嘛，非常简单。 还有一些比较复杂的例子，大家可以自行寻找。 贝尔级数在杜教筛中的应用这个东西算是最大应用了吧…… 应用主要分为两部分：你知道$f$本身是啥，但是不知道找啥去卷比较好；你不知道$f$本身是啥（你只知道它在质数的幂上表现），但你还是要杜教筛。 利用贝尔级数构造合适的狄利克雷卷积给一道题吧：求$\mu^2\ast (\mathrm{id}\cdot\mu)$这个东西的前缀和，$n\le 10^{11}$。 如果你不知道贝尔级数，你可能需要靠背上面提到的那个用传统方法很难证的结论来做这个题…… 但如果说你知道贝尔级数的话，你发现原函数贝尔级数为$(1 + x)(1 - px)$，然后我们想肯定要消掉一部分或者全部式子。我们考虑卷上一个$\mathrm{id}$，弄完了之后的贝尔级数为$1 + x$，也就是$\mu^2$。 $\mathrm{id}$的前缀和自然好说，但是$\mu^2$的前缀和咋整？ 其实$\mu^2$就是判断它是否没有完全平方因子。因此我们直接枚举那个因子的平方根就好了，但是这样会重复，因此考虑用$\mu$容斥一下，得到： \sum_{i = 1}^n\mu^2(i)=\sum_{i = 1}^{\lfloor\sqrt{n}\rfloor}\mu(i)\lfloor\frac{n}{i^2}\rfloor因此$\mu^2$的前缀和是可以根号复杂度来求的，不会影响杜教筛总的转移复杂度。因此总复杂度为$O(n^{\frac{2}{3}})$。 在不知道函数本身是啥的时候杜教筛还是给一道题： 有一个积性函数$f(x)$，你不知道它本身是啥，但是你知道他满足以下性质： $f(1) = 1$。 对于质数$p$和正整数$a$，有$f(p^a) = p^a + (-1)^a$。 求这玩意的前缀和，$n\le 10^{11}$。 其实你通过OEIS可以知道这个函数本身是啥（逃），但考虑到那样你也很难用常规手段杜教筛所以还事没啥用…… 首先考虑去构造这个玩意的贝尔级数。它看起来很像事$\mathrm{id}$和$\lambda$的贝尔级数加一下，但是考虑到$f(1) = 1$因此还要再减个1。最后得到： f_p(x)=\frac{1}{1 - px} + \frac{1}{1 + x} - 1我们想要卷上一个$g$，那些分母看起来很不顺眼，干脆把他们都消掉了吧！因此我们规定$g_p(x) = (1 - px)(1 + x)$（因此我们得知$g = (\mathrm{id}\cdot\mu)\ast\mu^2$）。卷出来之后发现： (f\ast g)_p(x) = 1 + x + 1 - px - 1 - x + px + px^2 = 1 + px^2然后我们弄了一大半顿我们还是不知道$f\ast g$具体是啥……但是我们观察到一点非常重要的性质：若$(f\ast g)(x)\ne 0$，那么$x$起码也得是完全平方数，并且$\mu^2(\sqrt{x}) = 1$，并且对答案的贡献为$\sqrt{x}$！ 这下$f\ast g$虽然还不知道是啥，但是起码它前缀和好求了！我们对于对答案可能有贡献的$x$枚举其算术平方根即可，写出来就是： \sum_{i = 1}^n(f\ast g)(i) = \sum_{i = 1}^{\lfloor\sqrt{n}\rfloor}\mu^2(i)i这样的话求$f\ast g$的前缀和的复杂度就已经降到$O(\sqrt{n})$了，更进一步我们发现这个式子的答案只和$\lfloor\sqrt{n}\rfloor$有关，所以我们用$O(\sqrt{n})$的时间预处理所有这种和之后$O(1)$查询就好了。 剩下唯一的硬骨头就是$g$的前缀和，这个上一小节已经讲了。 虽说这玩意蛮有用的……但是无法阻止杜教筛过气，常熟优秀还好想的MIN_25筛已经要dssq力（悲）]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>狄利克雷卷积</tag>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
        <tag>生成函数</tag>
        <tag>贝尔级数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些测试]]></title>
    <url>%2F2018%2F07%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[一级标题二级标题三级标题四级标题五级标题行内公式：$\int_{-\infty}^{+\infty}e^{x^2}\mathrm{d}x$。 行间公式： \int u\mathrm{d}v = uv - \int v\mathrm{d}u123456// C++ code#include &lt;cstdio&gt;int main() &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); printf("%d\n", a + b); return 0;&#125; 嗯，OC！]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
