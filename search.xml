<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ 1566 「NOI2009」管道取珠]]></title>
    <url>%2F2018%2F08%2F07%2FBZOJ1566%2F</url>
    <content type="text"><![CDATA[Description 有两个长度分别为\(n,m\)的珠子序列\(S,T\)，每种珠子可能是黑色或者白色，同色的珠子视为本质相同。 我们进行\(n + m\)次操作，每次从\(S,T\)中的一个的头部取出一个珠子，放到我们结果序列的尾部，这样能形成一个新的序列。定义两种方案不同，当且仅当存在一步使得这一步两种方案一个从\(S\)取一个从\(T\)取。那么我们假设最后可能的结果序列有\(k\)种，我们把他们用\(1\ldots k\)编号，假设\(a_k\)为编号为\(k\)的序列的操作方案数量，求： \[ \sum_{i = 1}^k a_i^2 \] \(n,m\leq 500\)。 Solution 那个平方是不是很不好处理啊…… 那么\(a_i\)一定可以表示为若干个\(1\)相加，每个\(1\)都代表了一种可以形成序列\(i\)的操作方案，平方之后这些\(1\)就会两两配对（参考二项式定理？）。 那么问题就转化成了求有多少对（可以相同也可以不相同的）操作序列可以生成同样的结果序列。这个DP一下就好力，，， Code 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;const int ha = 1024523;int d[2][505][505];char S[505], T[505];int main() &#123; int n, m; scanf("%d%d%s%s", &amp;n, &amp;m, S + 1, T + 1); d[0][0][0] = 1; for(int i = 1; i &lt;= n + m; i ++) &#123; int now = i &amp; 1; int pre = now ^ 1; memset(d[now], 0, sizeof(d[now])); for(int j = 0; j &lt;= i &amp;&amp; j &lt;= n; j ++) &#123; if(i - j &gt; m) continue; for(int k = 0; k &lt;= i &amp;&amp; k &lt;= n; k ++) &#123; if(i - k &gt; m) continue; int &amp;ans = d[now][j][k]; bool A0 = j &gt; 0, B0 = k &gt; 0; bool A1 = j &lt; i, B1 = k &lt; i; if(A0 &amp;&amp; B0 &amp;&amp; S[j] == S[k]) ans = (ans + d[pre][j - 1][k - 1]) % ha; if(A1 &amp;&amp; B1 &amp;&amp; T[i - j] == T[i - k]) ans = (ans + d[pre][j][k]) % ha; if(A0 &amp;&amp; B1 &amp;&amp; S[j] == T[i - k]) ans = (ans + d[pre][j - 1][k]) % ha; if(A1 &amp;&amp; B0 &amp;&amp; T[i - j] == S[k]) ans = (ans + d[pre][j][k - 1]) % ha;#ifdef LOCAL printf("d[%d][%d][%d] : %d\n", i, j, k, ans);#endif &#125; &#125; &#125; printf("%d\n", d[(n + m) &amp; 1][n][n]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>NOI</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC001E BBQ Hard]]></title>
    <url>%2F2018%2F08%2F06%2Fagc001E%2F</url>
    <content type="text"><![CDATA[Description 你有\(n\)个串，第\(i\)个串上有\(A_i\)块肉和\(B_i\)块菜。现在选出两个串，将他们中的肉和菜放在一起重新排列，求总方案数。 \(2\leq n\leq 200000, 1\leq A_i,B_i\leq 2000\)。 Solution 很显然对于两个串\(i, j\)，对答案的贡献是： \[ \binom{A_i + B_i + A_j + B_j}{A_i + A_j} \] 这个东西有什么组合意义吗？答案是有的。就是在一个平面上从原点走到\((A_i + A_j, B_i + B_j)\)，每次只向上或者向右走一格的方案数，然后我们把整个坐标系平移一下就可以把这个东西变成从\((-A_i, -B_i)\)走到\((A_j, B_j)\)。 然后我们建出所有的点，就是要我们求所有正点走到所有负点的方案数之和。这个东西很好DP，我们先把横纵坐标都加2000，然后根据到\((0, 0)\)的曼哈顿距离从小到大递推即可。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;utility&gt;using pii = std::pair&lt;int, int&gt;;const int ha = 1000000007;using ll = long long;ll pow_mod(ll a, ll b) &#123; ll ans = 1, res = a; while(b) &#123; if(1LL &amp; b) ans = ans * res % (ll)ha; res = res * res % (ll)ha; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow_mod(x, ha - 2);&#125;ll fac[10005], ifac[10005];void process() &#123; int n = 10000; fac[0] = 1; for(int i = 1; i &lt;= n; i ++) &#123; fac[i] = (fac[i - 1] * (ll(i))) % (ll)ha; &#125; ifac[n] = inv(fac[n]); for(int i = n - 1; i &gt;= 0; i --) &#123; ifac[i] = ifac[i + 1] * (ll(i + 1)) % (ll)ha; &#125;&#125;ll C(int x, int y) &#123; ll ret = fac[x]; ret = ret * ifac[x - y] % (ll)ha; ret = ret * ifac[y] % (ll)ha; return ret;&#125;pii P[200005]; int d[4005][4005];int n;int dp() &#123;#ifdef LOCAL puts("11111"); fflush(stdout);#endif for(int i = 1; i &lt;= n; i ++) &#123; int x = P[i].first, y = P[i].second; d[2000 - x][2000 - y] ++; &#125; for(int dis = 1; dis &lt;= 8000; dis ++) &#123; for(int i = std::max(0, dis - 4000); i &lt;= std::min(4000, dis); i ++) &#123; int j = dis - i; if(i &gt; 0) d[i][j] = (d[i][j] + d[i - 1][j]) % ha; if(j &gt; 0) d[i][j] = (d[i][j] + d[i][j - 1]) % ha; &#125; &#125;#ifdef LOCAL puts("Gou!"); fflush(stdout);#endif int ans = 0; for(int i = 1; i &lt;= n; i ++) &#123; int x = P[i].first, y = P[i].second; ans = (ans + d[x + 2000][y + 2000]) % ha; ans = (ans - C(2 * x + 2 * y, 2 * x) + ha) % ha; &#125; static const ll inv_2 = 500000004; ans = (((ll(ans)) * inv_2) % (ll)ha); return ans;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i ++) &#123; scanf("%d%d", &amp;P[i].first, &amp;P[i].second); &#125; process(); printf("%d\n", dp()); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4671 异或图]]></title>
    <url>%2F2018%2F08%2F06%2FBZOJ4671%2F</url>
    <content type="text"><![CDATA[Description 定义两个点数相同的图\(G_1,G_2\)的异或为一个新图\(G\)。\(G\)的点数和原来两个图一样，并且对于一条边\((i, j)\)，如果在\(G_1,G_2\)中的出现次数异或起来为\(1\)的话，那么\((i, j)\)会出现在\(G\)中，反之则不会出现。 给出\(s\)个有\(n\)个点的图\(G_1, G_2,\ldots,G_s\)，求这些图有多少个子集异或起来得到的图是一个联通图。 \(2\leq n\leq 10, 1\leq s\leq 60\)。 Solution 数数题，启动！ 恰好有一个连通块的情况是不好统计的，但是至少有一个连通块的情况很好统计。我们只需要枚举\(n\)个点的集合划分（\(B_{10} = 21147\)，所以不虚），保证不同集合之间没有边就行了。这样假设划出来了\(c\)个集合，那么最后的连通块数一定不小于\(c\)。 考虑不同集合之间没有边的条件如何处理。注意到这样就要求了包含这条边的图只用了偶数个，那么把所有这种条件列成一个方程组就是一个\(s\)元异或方程组。而我们知道一个\(s\)元异或方程组（假设其矩阵为\(A\)）的解数为\(2^{s - r(A)}\)，而\(r(A)\)就等于该矩阵的线性基数量，用线性基那一套传统艺能就可以求了。 然后我们现在只求出了至少\(c\)个连通块的方案，要想知道只有一个连通块的方案，势必要容斥一下。根据容斥系数那一套理论，我们要求右边的条件是\([n = 1]\)，因此容斥系数\(\mathrm{coef}_i\)应当满足： \[ \sum_{i = 1}^n \begin{Bmatrix}n\\i\end{Bmatrix}\mathrm{coef}_i = [n = 1] \] 使用打表等传统艺能可知\(\mathrm{coef}_i = (-1)^{i - 1}(i - 1)!\)，然后这题就做完力…… Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;bitset&gt;typedef long long ll;const int maxn = 12;const int maxs = 62;const int maxm = 60;ll lowbit(ll x) &#123; return x &amp; (-x);&#125;int n, m, s;ll L[maxn][maxn];ll M[maxm];ll gj() &#123; static ll bas[maxs]; std::fill(bas, bas + s, 0LL); int cnt = 0; for(int i = 1; i &lt;= m; i ++) &#123; ll x = M[i]; for(int j = s - 1; j &gt;= 0; j --) &#123; if(!((1LL &lt;&lt; (ll(j))) &amp; x)) continue; if(bas[j]) &#123; x ^= bas[j]; &#125; else &#123; cnt ++; bas[j] = x; break; &#125; &#125; &#125; return (1LL &lt;&lt; (ll(s - cnt)));&#125;int bel[maxn]; ll f[maxn];void dfs(int x, int cnt) &#123; if(x &gt; n) &#123; m = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = i + 1; j &lt;= n; j ++) &#123; if(bel[i] == bel[j]) continue; M[++ m] = L[i][j]; &#125; &#125; f[cnt] += gj(); return; &#125; for(int i = 1; i &lt;= cnt + 1; i ++) &#123; bel[x] = i; dfs(x + 1, std::max(i, cnt)); &#125;&#125;int main() &#123; scanf("%d", &amp;s); for(int i = 0; i &lt; s; i ++) &#123; char S[maxs]; scanf("%s", S); if(!n) &#123; int l = strlen(S); n = (1 + (int((sqrt(1 + 8 * l))))) / 2; &#125; int cnt = 0; for(int j = 1; j &lt;= n; j ++) &#123; for(int k = j + 1; k &lt;= n; k ++) &#123; if(S[cnt] == '1') &#123; L[j][k] ^= (1LL &lt;&lt; (ll(i))); &#125; cnt ++; &#125; &#125; &#125;#ifdef LOCAL printf("n : %d\n", n);#endif dfs(1, 0); ll ans = 0, fac = 1; for(int i = 1; i &lt;= n; i ++) &#123; ll delta = fac * f[i]; if(!(i &amp; 1)) delta *= -1LL;#ifdef LOCAL printf("delta(%d) : %lld\n", i, delta);#endif ans += delta; fac *= (ll)i; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>容斥原理</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 6076 「2017 山东一轮集训 Day6」三元组]]></title>
    <url>%2F2018%2F08%2F04%2Floj6076%2F</url>
    <content type="text"><![CDATA[Description 给定正整数\(a,b,c\)，求： \[ \sum_{i = 1}^a\sum_{j = 1}^b\sum_{k = 1}^c [i\perp j][i\perp k][j\perp k] \] \(a,b,c\leq 5\times 10^5\)。 Solution 下面钦点\(a\leq b\leq c\)。 \[ \begin{aligned} \quad&amp;\sum_{i = 1}^a\sum_{j = 1}^b\sum_{k = 1}^c [i\perp j][j\perp k][i\perp k]\\ =&amp;\sum_{i = 1}^a\sum_{j = 1,j\perp i}^b\sum_{k = 1,k\perp i}^c [j\perp k]\\ =&amp;\sum_{i = 1}^a\sum_{j = 1,j\perp i}^b\sum_{k = 1,k\perp i}^c \sum_{d | j, d | k}\mu(d)\\ =&amp;\sum_{i = 1}^a\sum_{d = 1, d\perp i}^b \mu(d)S_i(\lfloor\frac{b}{d}\rfloor)S_i(\lfloor\frac{c}{d}\rfloor) \end{aligned} \] 其中\(S_a(n)\)表示\([1, n]\)中和\(a\)互质的正整数数量。 后面那一块很显然可以整除分块罢……然后接下来我们需要考虑处理\([1, n]\)中和\(a\)互质的数的\(\mu\)和\(1\)的和，这个东西很显然可以用洲阁筛/Min_25筛的思想。考虑将\(i\)质因数分解为，其质因子有\(p_1, p_2,\ldots, p_k\)。定义状态\(f_i(n)\)表示\([1, n]\)中和前\(i\)个质因子互质的\(\mu\)的和，类似的用\(g_i(n)\)表示\(1\)的和。那么转移很显然是： \[ f_i(n) = f_{i - 1}(n) + f_i(\lfloor\frac{n}{p_i}\rfloor)\\ g_i(n) = g_{i - 1}(n) - g_{i - 1}(\lfloor\frac{n}{p_i}\rfloor) \] 考虑到状态全部是\(\lfloor\frac{n}{x}\rfloor\)的形式，所以我们要是对每个\(i\)都这么做一遍的话，每个\(i\)的总状态数（也是时间复杂度）就是\(O(\omega(i)\sqrt{i})\)。因此总的复杂度大约就是\(O(n\sqrt{n}\log n)\)，并且还很不满，看起来很稳是不是啊…… 然后我直接写了一个东西交上去，然后T到60……卡了卡常之后T到了80…… 然后注意到如果两个\(i\)的质因子构成是完全一致的话，那么他们对答案的贡献也就一样……所以我们再额外对这个东西记忆化一下，然后就能卡过去了。这之后有没有一个可以推出来的更紧的上界，我就不知道了……有没有先辈会算这个啊……有的话麻烦在评论区书一下qwq Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;unordered_map&gt;#include &lt;map&gt;#include &lt;stack&gt;const int N = 50005;int mu[N + 1], minp[N + 1];int prm[N + 1]; bool vis[N + 1];void sieve() &#123; int cnt = 0; mu[1] = 1; minp[1] = 1; vis[1] = true; for(int i = 2; i &lt;= N; i ++) &#123; if(!vis[i]) &#123; mu[i] = -1; minp[i] = i; prm[cnt ++] = i; &#125; for(int j = 0; j &lt; cnt; j ++) &#123; int v = i * prm[j]; if(v &gt; N) break; vis[v] = true; minp[v] = prm[j]; if(i % prm[j] == 0) &#123; mu[v] = 0; break; &#125; else &#123; mu[v] = -mu[i]; &#125; &#125; &#125; for(int i = 1; i &lt;= N; i ++) &#123; mu[i] += mu[i - 1]; &#125;&#125;using ll = long long;using ull = unsigned long long;const ll ha = 1000000007LL;const int maxn = 50005;int p[16], pcnt;const int INF = 0x7f7f7f7f;int ma[16][maxn]; int st1[16][maxn], top1[16];int calc_S(int c, int n) &#123; if(c == 0) return n; if(n == 0) return 0; if(ma[c][n] != INF) return ma[c][n]; st1[c][top1[c] ++] = n; int ret = (calc_S(c - 1, n) - calc_S(c - 1, n / p[c])); ma[c][n] = ret; return ret;&#125;int ma_mu[16][maxn]; int st2[16][maxn], top2[16];int calc_mu(int c, int n) &#123; if(c == 0) return (mu[n]); if(n == 0) return 0; if(ma_mu[c][n] != INF) return ma_mu[c][n]; st2[c][top2[c] ++] = n; int ret = (calc_mu(c - 1, n) + calc_mu(c, n / p[c])); ma_mu[c][n] = ret; return ret;&#125;ll sqr(ll x) &#123; ll ret = 1; while((ret + 1LL) * (ret + 1LL) &lt;= x) ret ++; return ret;&#125;const ull seed = 200261ULL;int main() &#123; sieve(); int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); if(a &gt; b) std::swap(a, b); if(a &gt; c) std::swap(a, c); if(b &gt; c) std::swap(b, c); static int rec[50005]; memset(rec, -1, sizeof(rec)); memset(ma, 0x7f, sizeof(ma)); memset(ma_mu, 0x7f, sizeof(ma_mu)); ll ans = 0; for(int i = 1; i &lt;= a; i ++) &#123; pcnt = 0; int u = i; while(u &gt; 1) &#123; int tp = minp[u]; p[++ pcnt] = tp; while(u % tp == 0) u /= tp; &#125; int hs = 1; for(int i = 1; i &lt;= pcnt; i ++) &#123; hs *= p[i]; &#125; if(rec[hs] != -1) &#123; ans = (ans + (ll)rec[hs]) % ha; continue; &#125; ll las = 0, ret = 0LL; for(int j = 1; j &lt;= b;) &#123; int next = std::min(b / (b / j), c / (c / j)); ll th = calc_mu(pcnt, next); // th = (th + ha) % ha; ll delta = (th - las + ha) % ha; delta = (delta * (ll)calc_S(pcnt, b / j)); delta = (delta * (ll)calc_S(pcnt, c / j)) % ha; ret = (ret + delta); if(ret &gt; ha) ret -= ha; las = th; j = next + 1; &#125; for(int j = 1; j &lt;= pcnt; j ++) &#123; while(top1[j] &gt; 0) &#123; int p = st1[j][-- top1[j]]; ma[j][p] = INF; &#125; while(top2[j] &gt; 0) &#123; int p = st2[j][-- top2[j]]; ma_mu[j][p] = INF; &#125; &#125; rec[hs] = ret; ans = (ans + ret) % ha; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Min_25筛</tag>
        <tag>洲阁筛</tag>
        <tag>LibreOJ</tag>
        <tag>山东省队集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 2219 数论之神]]></title>
    <url>%2F2018%2F08%2F04%2FBZOJ2219%2F</url>
    <content type="text"><![CDATA[Description 给定正整数\(A, B, K\)，求方程\(x^A\equiv B\pmod{2K+1}\)在\(Z_{2K+1}\)中的解的数量。 多组询问，组数不超过1000。 \(1\leq A,B\leq 10^9, 1\leq K\leq 5\times 10^8\)。 Solution 算是一道综合性很强的题目了…… 先将模数分解质因数，对每一种质因子幂单独求解，然后由中国剩余定理之类的知道最后的解数是每一部分的解数的积。 那么考虑每种质因子的幂\(m=p^c\)的解数。先把\(B\)取下模，要是\(B = 0\)的话那么\(x\)是\(p^{\lceil\frac{c}{A}\rceil}\)的倍数就行了，因此答案是\(p^{c-\lceil\frac{c}{A}\rceil}\)。 那么考虑\(B\neq 0\)的情况。你可以对两边取指标（因为\(m\)事奇质数的幂，所以一定有原根，原根当然很好找了），就得到了\(A\mathrm{ind}x\equiv\mathrm{ind}B\pmod{\varphi(m)}\)，然后根据线性同余方程那套理论，假设\(d=\gcd(A,\varphi(m))\)，如果\(d|\mathrm{ind}B\)才有解，且解的数量为\(d\)。 但是有一个问题就是可能有\(\gcd(B, m)&gt;1\)，这样的话\(\mathrm{ind}B\)就不一定存在。那么我们在原始的式子里，把两边疯狂除\(p\)直到右边没有\(p\)了，那么假设\(B=p^su\)，那么可知新的方程为\(\frac{x^A}{p^s}\equiv u\pmod{p^{c - s}}\)。可以发现如果\(A\)不是\(s\)的因子的话那么凉了，要是是的话假设\(s = At\)，那么新的方程也可以写作\((\frac{x}{p^t})^A\equiv u\pmod{p^{c - s}}\)，这样的话就得到了一个新的方程，且\(u\)和现在的模数是互质的，因此可以直接用上面的方法做。需要注意的是我们现在只是求出了模\(p^{c-s}\)的解数，对应到\(p^c\)要乘上\(p^s\)。但是解肯定要乘上一个\(p^t\)，因此解数还要在除一下\(p^t\)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cassert&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;tr1/unordered_map&gt;typedef long long ll;ll gcd(ll a, ll b) &#123; if(!b) &#123; return a; &#125; else &#123; return gcd(b, a % b); &#125;&#125;void exgcd(ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y) &#123; if(!b) &#123; d = a; x = 1; y = 0; &#125; else &#123; ll nx, ny; exgcd(b, a % b, d, nx, ny); x = ny; y = nx - ny * (a / b); &#125;&#125;ll inv(ll v, ll p) &#123; ll d, x, y; exgcd(v, p, d, x, y); return (x + p) % p;&#125;ll pow_mod(ll a, ll b, ll p) &#123; ll ans = 1, res = a; while(b) &#123; if(1LL &amp; b) ans = ans * res % p; res = res * res % p; b &gt;&gt;= 1; &#125; return ans;&#125;void desc(ll x, std::vector&lt;int&gt; &amp;V) &#123; ll bd = floor(sqrt((double)x) + 0.5); for(ll i = 2; i &lt;= bd; i ++) &#123; if(x % i == 0LL) &#123; V.push_back(i); while(x % i == 0LL) x /= i; &#125; &#125; if(x &gt; 1LL) V.push_back(int(x));&#125;ll find_g(ll p, ll phi, std::vector&lt;int&gt; &amp;V) &#123; if(p == 2LL) return 1; for(ll i = 2; i &lt; p; i ++) &#123; bool ok = true; for(int j = 0; j &lt; V.size(); j ++) &#123; ll c = phi / (ll)V[j]; if(pow_mod(i, c, p) == 1LL) &#123; ok = false; break; &#125; &#125; if(ok) return i; &#125; return -1LL;&#125;ll bsgs(ll a, ll b, ll p) &#123; if(a == 0LL) &#123; return (b == 0LL) ? 1LL : -1LL; &#125; int bd = ceil(sqrt((double)p)); std::tr1::unordered_map&lt;ll, ll&gt; ma; ll blk = 1LL; for(int i = 0; i &lt; bd; i ++) &#123; if(!ma.count(blk)) ma[blk] = i; blk = blk * a % p; &#125; ll bs = 1LL; blk = inv(blk, p); for(int i = 0; (ll)i * (ll)bd &lt; p; i ++) &#123; ll th = b * bs % p; if(ma.count(th)) return ma[th] + i * bd; bs = bs * blk % p; &#125; assert(false); return -1;&#125;ll equation(ll a, ll b, ll p) &#123; ll ret = gcd(a, p); if(b % ret != 0LL) return 0; else return ret;&#125;ll solve(ll a, ll b, ll mod, ll p, ll c) &#123; if(b == 0LL) &#123; ll ret = ceil((double(c)) / (double(a))); return pow_mod(p, c - ret, 2000000007LL); &#125; else &#123; if(b % p == 0LL) &#123; ll nc = 0; while(b % p == 0LL) nc ++, b /= p, mod /= p; if(nc % a != 0LL) return 0LL; ll t = nc / a; return solve(a, b, mod, p, c - nc) * pow_mod(p, (a - 1LL) * t, 2000000007LL); &#125; else &#123; ll phi = mod / p * (p - 1LL); std::vector&lt;int&gt; d_phi; desc(phi, d_phi); ll g = find_g(mod, phi, d_phi); return equation(a, bsgs(g, b, mod), phi); &#125; &#125;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T --) &#123; int a, b, k; scanf("%d%d%d", &amp;a, &amp;b, &amp;k); k = 2 * k + 1; int bd = floor(sqrt((double)k) + 0.5); int ans = 1; for(int i = 2; i &lt;= bd; i ++) &#123; if(k % i == 0) &#123; int c = 0, mod = 1; while(k % i == 0) k /= i, c ++, mod *= i; ans *= solve(a, b % mod, mod, i, c); &#125; &#125; if(k &gt; 1) ans *= solve(a, b % k, k, k, 1); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>BSGS</tag>
        <tag>原根</tag>
        <tag>指标</tag>
        <tag>同余方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 2014 「SCOI2016」萌萌哒]]></title>
    <url>%2F2018%2F08%2F02%2Floj2014%2F</url>
    <content type="text"><![CDATA[Description 有一个长度为\(n\)的无前导零数字串。 现在给你\(m\)组信息，形如\((a,b,c,d)\)（保证\(a\leq b, c\leq d,b - a = d - c\)），表示数字串\(a\ldots b\)这一段子串和\(c\ldots d\)这一段子串是一样的。 求最后的数字串有多少种可能。 \(1\leq n, m\leq 10^5, 1\leq a,b,c,d\leq n\)。 Solution ao劲啊这种题，，， 肯定要上并查集辣……但是暴力建图一定会炸，线段树优化建图在这也不好用（两边子树的形态可能差异巨大）。那么考虑用倍增优化建图。 建出形如\(v(i, j)\)的点表示从\(i\)开始长度为\(2^j\)的子串。然后这样用类似于ST表的方式就可以处理所有信息了，具体方式就是把对应的两组点在并查集上连一下。 然后考虑最后如何统计答案。这个也不难，你把并查集的关系逐层往下推就行。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int maxn = 100005;const int maxs = maxn * 17;using ll = long long;const ll ha = 1000000007LL;ll pow_mod(ll a, ll b) &#123; ll ans = 1LL, res = a; while(b) &#123; if(1LL &amp; b) ans = ans * res % ha; res = res * res % ha; b &gt;&gt;= 1; &#125; return ans;&#125;int p[maxs], rk[maxs];void init_set(int s) &#123; for(int i = 1; i &lt;= s; i ++) &#123; p[i] = i; rk[i] = 0; &#125;&#125;int get_fa(int x) &#123; if(p[x] == x) &#123; return x; &#125; else &#123; return (p[x] = get_fa(p[x])); &#125;&#125;void link_set(int x, int y) &#123; if(rk[x] &gt; rk[y]) std::swap(x, y); p[x] = y; if(rk[x] == rk[y]) rk[y] ++;&#125;void merge_set(int x, int y) &#123; x = get_fa(x); y = get_fa(y); if(x != y) link_set(x, y);&#125;int n, cnt;int lst[maxn];int num[maxn][17], lc[maxs], rc[maxs];void process() &#123; lst[1] = 0; for(int i = 2; i &lt;= n; i ++) &#123; lst[i] = lst[i - 1]; while((1 &lt;&lt; (lst[i] + 1)) &lt;= i) lst[i] ++; &#125; cnt = 0; for(int j = 0; (1 &lt;&lt; j) &lt;= n; j ++) &#123; for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++) &#123; num[i][j] = ++ cnt; if(j &gt; 0) &#123; lc[cnt] = num[i][j - 1]; rc[cnt] = num[i + (1 &lt;&lt; (j - 1))][j - 1]; &#125; &#125; &#125; init_set(cnt);&#125;void update(int a, int b, int c, int d) &#123; int g = lst[b - a + 1];#ifdef LOCAL printf("Operation (%d, %d, %d, %d) %d\n", a, b, c, d, g);#endif merge_set(num[a][g], num[c][g]); merge_set(num[b - (1 &lt;&lt; g) + 1][g], num[d - (1 &lt;&lt; g) + 1][g]);&#125;int main() &#123; int m; scanf("%d%d", &amp;n, &amp;m); process(); while(m --) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); update(a, b, c, d); &#125; for(int i = cnt; i &gt; n; i --) &#123; int fa = get_fa(i); merge_set(lc[i], lc[fa]); merge_set(rc[i], rc[fa]); &#125; int blk = 0; for(int i = 1; i &lt;= n; i ++) &#123; if(get_fa(i) == i) blk ++; &#125; ll ans = 9LL * pow_mod(10LL, blk - 1) % ha; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LibreOJ</tag>
        <tag>SCOI</tag>
        <tag>倍增</tag>
        <tag>倍增优化建图</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛23]]></title>
    <url>%2F2018%2F07%2F28%2FNCTraining25%2F</url>
    <content type="text"><![CDATA[昨晚打了一场比赛……感觉不太难的？（E题除外） 还事撸一篇题解罢？ A Description 懒得写了……（逃 Solution 贪心且尽量选最大的，然后没了…… Code 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;int v1[7] = &#123;100, 50, 20, 10, 5, 2, 1&#125;;int v2[6] = &#123;50, 20, 10, 5, 2, 1&#125;;int main() &#123; int T; scanf("%d", &amp;T); while(T --) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); for(int i = 0; i &lt; 7; i ++) &#123; int g = a / v1[i]; if(i &gt; 0) putchar(' '); printf("%d", g); a -= v1[i] * g; &#125; for(int i = 0; i &lt; 6; i ++) &#123; int g = b / v2[i]; printf(" %d", g); b -= v2[i] * g; &#125; puts(""); &#125; return 0;&#125; B Description 还事懒得写……（逃 Solution 如果你自己试过的话会发现尽量均分事很合理的……证明啥的画画函数图像就行了（逃 Code 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;using ll = long long;std::unordered_map&lt;int, ll&gt; ma;ll dp(int n) &#123; if(n == 1) return 0; if(ma.count(n)) return ma[n]; ll x = n / 2; ll y = n - x; ll ret = x * y + dp(x) + dp(y); ma[n] = ret; return ret;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T --) &#123; int n; scanf("%d", &amp;n); printf("%lld\n", dp(n)); &#125; return 0;&#125; C Description 给定一自然数序列\(a\)，选出一个子序列\(b\)使得\(b\)中所有元素按位与的lowbit尽可能大。要求你输出这个\(b\)。 此外，如果有多解那么取一个\(b\)尽可能长的。 \(n\leq 10^5,a_i&lt;2^{31}\)。 Solution 我们可以枚举那个lowbit是哪一位，然后我们至少要保证\(b\)中每个元素都含有这一位。 然后我们要求按位与起来更低的位都要是0。然后我们知道参与按位与运算的元素越多，每一位就不可能会变大。那么只要取出所有含有我们要求的那一位元素构成\(b\)，还是有更低位元素为1的话，那么我们枚举的这一位就一定不是答案了。 更好的性质是，这种方法是一定能保证\(b\)尽可能长的。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;climits&gt;int lowbit(int x) &#123; return x &amp; (-x);&#125;const int maxn = 100005;int a[maxn];int main() &#123; int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i ++) &#123; scanf("%d", &amp;a[i]); &#125; int ans = 0; for(int j = 0; j &lt;= 30; j ++) &#123; int sv = INT_MAX; for(int i = 1; i &lt;= n; i ++) &#123; if((1 &lt;&lt; j) &amp; a[i]) sv &amp;= a[i]; &#125; if(sv != 0 &amp;&amp; lowbit(sv) &gt;= (1 &lt;&lt; j)) &#123; ans = std::max(ans, (1 &lt;&lt; j)); &#125; &#125; if(ans == 0) &#123; puts("0"); return 0; &#125; std::vector&lt;int&gt; vec; for(int i = 1; i &lt;= n; i ++) &#123; if(a[i] &amp; ans) &#123; vec.push_back(a[i]); &#125; &#125; printf("%d\n", vec.size()); for(int i = 0; i &lt; vec.size(); i ++) &#123; if(i &gt; 0) putchar(' '); printf("%d", vec[i]); &#125; puts(""); return 0;&#125; D Description 给你一个由\(a\ldots i\)为组成字符的字符串\(S\)（\(|S|\leq 3000\)），求有多少abcdefghi的排列使得该排列为\(S\)的子序列。 Solution 我们考虑枚举排列再判定吧。 我们直接搞出来\(S\)的子序列自动机，然后再扔进去一遍就行了。子序列自动机也不难，你每个点的每种字符的边往他后面第一次这个字符出现的地方连就行。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;const int maxn = 3005;int go[maxn][9]; int n;char S[maxn]; int las[9];void process() &#123; for(int i = n; i &gt;= 0; i --) &#123; memcpy(go[i], las, sizeof(las)); if(i &gt; 0) las[S[i] - 'a'] = i; &#125;&#125;bool check(char *s) &#123; int l = strlen(s); int u = 0; for(int i = 0; i &lt; l; i ++) &#123; int c = s[i] - 'a'; if(!go[u][c]) return false; u = go[u][c]; &#125; return true;&#125;char s[10] = "abcdefghi";int main() &#123; scanf("%s", S + 1); n = strlen(S + 1); process(); int ans = 0; do &#123; if(check(s)) ans ++; &#125; while(std::next_permutation(s, s + 9)); printf("%d\n", ans); return 0;&#125; E Description 给定正整数\(n, x\)，要你求一个最大的\(b\)满足\(1&lt;b&lt;x\)，且在\(b\)进制下存在一个长为\(n\)的正整数\(a\)（允许有前导0），满足把\(a\)的\(b\)进制表示看成一个序列之后，做出来的\(n\)种循环位移互不相同，且分别可以由\(a\cdot l(1\leq l\leq n)\)得到。 \(n\leq 5\cdot 10^6,x\leq 10^9\)。 Solution 可以书事最难的题力，，， 我们考虑那个\(a\)吧，就当\(b = 10, a = 142857\)来说，构造一个小数\(c\)满足： \[ c = 0.\overline{142857} \] 这个东西既然是个小数，那么一定可以表示为一个分数\(\frac{p}{q}(p\perp q)\)。然后我们发现如果\(a\)合法，那么\(a\cdot b^l(0\leq l &lt; n)\)的小数部分组成的集合和\(a\cdot l(1\leq l\leq n)\)组成的集合事完全一致的。 小数部分显然只会由分子模\(q\)的结果决定，那么上面的结论就等价于\(p\cdot b^l(0\leq l &lt; n)\)组成的集合和\(p\cdot l(1\leq l\leq n)\)组成的集合事一致的。而\(p^{-1}\bmod{q}\)存在，那么给两个集合都乘上这玩意，那么就得到了\(b^l(0\leq l &lt; n)\)和\(l(1\leq l\leq n)\)，然后就会发现\(b\)的这若干次幂和\(Z_{n + 1}\)中的正数一一对应……换言之\(b\)为\(n + 1\)的原根且\(n + 1\)必须为质数。 找原根的话直接枚举判定就行了……要知道原根很密集的（逃 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;queue&gt;#include &lt;set&gt;const int N = 10000000;int phi[N + 5], minp[N + 5];int prm[N + 5]; bool vis[N + 5];void sieve() &#123; phi[1] = 1; vis[1] = true; int cnt = 0; for(int i = 2; i &lt;= N; i ++) &#123; if(!vis[i]) &#123; phi[i] = i - 1; minp[i] = i; prm[cnt ++] = i; &#125; for(int j = 0; j &lt; cnt &amp;&amp; prm[j] &lt;= N / i; j ++) &#123; int v = i * prm[j]; if(v &gt; N) break; vis[v] = true; minp[v] = prm[j]; if(i % prm[j] == 0) &#123; phi[v] = phi[i] * prm[j]; break; &#125; else &#123; phi[v] = phi[i] * phi[prm[j]]; &#125; &#125; &#125;&#125;using ll = long long;ll pow_mod(ll a, ll b, ll p) &#123; ll ans = 1, res = a % p; while(b) &#123; if(1LL &amp; b) ans = (ans * res) % p; res = (res * res) % p; b &gt;&gt;= 1; &#125; return ans;&#125;bool has_phi(int x) &#123; return !vis[x];&#125;std::vector&lt;int&gt; V;void desc(int x) &#123; while(x &gt; 1) &#123; int p = minp[x]; V.push_back(p); while(x % p == 0) x /= p; &#125;&#125;bool check(int x, int t, int p) &#123; for(int v : V) &#123; ll ans = pow_mod(x, t / v, p); if(ans == 1LL) return false; &#125; return true;&#125;int gcd(int a, int b) &#123; if(!b) return a; else return gcd(b, a % b);&#125;int main() &#123; sieve(); int n, x; scanf("%d%d", &amp;n, &amp;x); if(x &lt;= 2 || vis[n + 1]) &#123; puts("-1"); return 0; &#125;/* if(n == 1) &#123; printf("%d\n", x - 1); return 0; &#125;*/ int p = n + 1; int t = n; desc(t); bool ok = false; for(int i = x - 1; i &gt; 1; i --) &#123; if((gcd(i, p) == 1) &amp;&amp; check(i, t, p)) &#123; printf("%d\n", i); ok = true; break; &#125; &#125; if(!ok) puts("-1"); return 0;&#125; F Description 给一颗\(n\)个点的以1为根的树，每次随机选择剩下点中的一个将其子树删掉，等没点了游戏终止。 求期望删除次数。 Solution 怎么感觉是一道经典题…… 根据期望线性性，我们考虑每个点对答案的贡献。 每个点首先他和他祖先中势必会有一个点被删除，要是祖先被删了那也没它什么戏了。 所以在它做出贡献时必定他和他祖先都在，然后删了它。无论是在什么情况下，他被删了他祖先却没被动的概率都是\(\frac{1}{d}\)（其中\(d\)为他和他祖先的数量）。 然后加起来就好了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;using ll = long long;const ll ha = 998244353LL;ll pow_mod(ll a, ll b) &#123; ll ans = 1, res = a; while(b) &#123; if(1LL &amp; b) ans = (ans * res) % ha; res = (res * res) % ha; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow_mod(x, ha - 2LL);&#125;std::vector&lt;int&gt; G[100005];void ins_edge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u);&#125;ll dfs(int x, int fa, int depth) &#123; ll ret = inv(depth); for(auto v : G[x]) &#123; if(v != fa) &#123; ret = (ret + dfs(v, x, depth + 1)) % ha; &#125; &#125; return ret;&#125;int main() &#123; int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n - 1; i ++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); ins_edge(u, v); &#125; printf("%lld\n", dfs(1, -1, 1)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>原根</tag>
        <tag>NowCoder</tag>
        <tag>贪心</tag>
        <tag>子序列自动机</tag>
        <tag>位运算</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀XXX可持久化大坑]]></title>
    <url>%2F2018%2F07%2F25%2Fsuffix%2F</url>
    <content type="text"><![CDATA[我谔谔，我今天才学的后缀数组（之前只会后缀自动机）。 然后就想开个后缀家族大坑？ 后缀数组 介绍 虽然说可能在各位巨佬眼里这已经是烂大街的东西了……但我现在才会（逃 思想很简单吧，对于原串的所有后缀排个序（按字典序升序），形成了一个数组\(\mathrm{sa}\)，就叫做后缀数组，方便起见定义\(\mathrm{rk}[i]\)表示\(i\ldots n\)这一段后缀在\(\mathrm{sa}\)中的排名。 然后考虑怎么求这玩意吧…… 倍增排序求SA 如果直接按照定义，快排加暴力比较弄的话，\(O(n^2\log n)\)的复杂度没什么用（其实有个比较贱的方法事你可以预处理哈希然后二分比较两个后缀就匪快了）。 我们考虑采取倍增的思想，依次比较各个后缀的长度为\(1,2,4,8,16,\ldots\)的前缀，这样的话总是可以比较出最后的结果。 更大的好处是，假如我们已经有了\(2^t\)下的答案，我们要对\(2^{t + 1}\)的情况排序。那么每个后缀我们可以直接视为一个二元组\((a, b)\)，其中\(a,b\)分别是\(2^t\)下的排名。 这样的话我们可以直接用这种思想套上快排，复杂度\(O(n\log^2 n)\)。但观察到二元组的两元的值域都不超过\(n\)，所以把快排改成桶排，这样复杂度就是\(O(n\log n)\)的了。 然后更多细节参考代码吧。 SA的应用：height数组 这样看的话SA好像没啥用处？ 我们定义一个\(\mathrm{height}[i]\)表示排名为\(i\)的后缀和他的上一名的LCP。如果你学过后缀树的话，你会发现把后缀树的叶子按照对应后缀字典序排序一下，然后这个\(\mathrm{height}\)就是每个叶子和他左侧的叶子的LCA的深度。 直接按照定义求这玩意显然复杂度\(O(n^2)\)，难以接受。然后我们定义\(h(i) = \mathrm{height}[\mathrm{rk}[i]]\)，然后我们发现有： \[ h(i)\geq h(i - 1) - 1 \] 证明的话考虑\(h(i - 1)\geq 1\)的情况就行了。我们假设\(a = i - 1, b = \mathrm{sa}[\mathrm{rk}[a] - 1]\)，那么若\(h(i - 1)\geq 1\)，那么我们把两者截去开头一个字符还会得到两个新的后缀\(a&#39;,b&#39;\)，注意到有\(a&#39; = i, b&#39; = b + 1\)，且\(\mathbf{LCP}(a&#39;,b&#39;) = h(i - 1) - 1\)，考虑到字典序意义上\(a &gt; b\)，那么显然字典序意义下也有\(i &gt; b + 1\)，那么说明\(\mathrm{rk}[i] - 1\leq b + 1\)，因此\(\mathrm{sa}[\mathrm{rk}[i] - 1]\)在排序后的后缀树中一定不会比\(b + 1\)离\(i\)更远，换言之\(\mathrm{sa}[\mathrm{rk}[i] - 1]\)和\(i\)在树中的LCA深度（也就是串中的LCP大小）不会小于\(h(i - 1) - 1\)。 根据这个东西，就可以很轻松的\(O(n)\)求出\(\mathrm{height}\)数组了。 题目 POJ 2774 Long Long Message Description 给两个串，求两者的最长公共子串。 两个串的长度都不超过100000。 Solution 考虑把两个串强行接在一起（顺便中间加上一个特殊字符作为分隔符以防越界），那么两者的公共子串一定是某两个在分隔符两端的后缀的公共前缀，而我们要取出最长的情况。 那么我们按照\(\mathrm{sa}\)的顺序扫描所有后缀，如果出现相邻两个后缀在分隔符两侧，那就取他们的\(\mathrm{height}\)值更新答案即可。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;int idx(char c) &#123; if(c == '$') &#123; return 27; &#125; else &#123; return c - 'a' + 1; &#125;&#125;const int maxn = 200005;char S[maxn]; int sz;int sa[maxn], rk[maxn], height[maxn];void process() &#123; static int fir[maxn], sec[maxn]; static int buf[maxn], tmp[maxn]; for(int i = 1; i &lt;= sz; i ++) buf[idx(S[i])] ++; for(int i = 1; i &lt;= 27; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) rk[i] = buf[idx(S[i]) - 1] + 1; for(int t = 1; t &lt;= sz; t &lt;&lt;= 1) &#123; for(int i = 1; i &lt;= sz; i ++) &#123; fir[i] = rk[i]; sec[i] = (i + t &gt; sz) ? 0 : rk[i + t]; &#125; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[sec[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) tmp[buf[sec[i]] --] = i; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[fir[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = sz; i &gt;= 1; i --) &#123; int j = tmp[i]; sa[buf[fir[j]] --] = j; &#125; bool unique = true; for(int i = 1, las = 0; i &lt;= sz; i ++) &#123; int j = sa[i]; if(!las) &#123; rk[j] = 1; &#125; else &#123; if(fir[j] == fir[las] &amp;&amp; sec[j] == sec[las]) &#123; unique = false; rk[j] = rk[las]; &#125; else &#123; rk[j] = rk[las] + 1; &#125; &#125; las = j; &#125; if(unique) break; &#125; for(int i = 1, k = 0; i &lt;= sz; i ++) &#123; if(rk[i] == 1) &#123; k = 0; &#125; else &#123; if(k &gt; 0) k --; int j = sa[rk[i] - 1]; while(i + k &lt;= sz &amp;&amp; j + k &lt;= sz &amp;&amp; S[i + k] == S[j + k]) k ++; &#125; height[rk[i]] = k; &#125;&#125;int s1, s2;int solve() &#123; process(); int ans = 0; for(int i = 2; i &lt;= sz; i ++) &#123; int a = sa[i], b = sa[i - 1]; bool v1 = a &lt;= s1, v2 = b &lt;= s1; if(v1 ^ v2) &#123; ans = std::max(ans, height[i]); &#125; &#125; return ans;&#125;int main() &#123; scanf("%s", S + 1); s1 = strlen(S + 1); S[s1 + 1] = '$'; scanf("%s", S + s1 + 2); sz = strlen(S + 1); printf("%d\n", solve()); return 0;&#125; POJ 1743 Musical Theme Description 给一个由\([1, 88]\)中整数组成的数字串，要求取出两个长度相等的不重叠子串。要求： 两个串的长度都大于5。 一个子串可以通过整体加上一个整数得到另一个子串。 最大化取出子串的长度。 多组数据，串长不超过20000。 Solution 算事经典套路题了……一直知道但一直没做 首先第二个条件很鬼畜，我们考虑做一些转化搞掉它。我们直接把序列差分，这样的话除了第一项其他都能匹配（要考虑一下整个序列的第一项怎么处理啊，这个参考代码吧）。 先讲个比较逊的做法……很显然这个东西的答案具有单调性，那么考虑二分答案。 然后考虑该怎么判定答案。考虑当前二分答案为\(k\)，然后我们对于所有\(\mathrm{height}[i]\geq k\)，我们都可以合并\(\mathrm{sa}[i - 1]\)和\(\mathrm{sa}[i]\)（也就是说可能可以由这两个后缀产生答案，并且这种关系很显然具有传递性），那么就相当于除了\(\mathrm{height}[i] &lt; k\)的情况被“断开”了，其他地方都已经分别连在一块了。那么每一块都是可能在块内产生答案（但不可能和块外产生答案），如果说某个块中最长后缀和最短后缀的差不小于\(k\)，那么说明该块可以取出两个不重叠的长度不小于\(k\)的后缀的前缀，因此\(k\)合法。反之\(k\)不合法。 这样复杂度很显然事\(O(n\log n)\)的，可以通过此题。 然后我们考虑那个二分答案其实不需要的……我们可以用并查集来维护块。我们每个块都维护块中最长后缀和最短后缀，刚开始每个点都是自己一块。从大到小枚举所有\(\mathrm{height}[i]\)的值，然后去合并块。每次合并出新的块的时候我们判一下是否有合法答案就行了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;const int maxn = 200005;int S[maxn]; int sz;int sa[maxn], rk[maxn], height[maxn];void process() &#123; static int fir[maxn], sec[maxn]; static int buf[maxn], tmp[maxn]; std::fill(buf, buf + 1 + sz, 0); for(int i = 1; i &lt;= sz; i ++) buf[S[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) rk[i] = buf[S[i] - 1] + 1; for(int t = 1; t &lt;= sz; t &lt;&lt;= 1) &#123; for(int i = 1; i &lt;= sz; i ++) &#123; fir[i] = rk[i]; sec[i] = (i + t &gt; sz) ? 0 : rk[i + t]; &#125; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[sec[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) tmp[buf[sec[i]] --] = i; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[fir[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = sz; i &gt;= 1; i --) &#123; int j = tmp[i]; sa[buf[fir[j]] --] = j; &#125; bool unique = true; for(int i = 1, las = 0; i &lt;= sz; i ++) &#123; int j = sa[i]; if(!las) &#123; rk[j] = 1; &#125; else &#123; if(fir[j] == fir[las] &amp;&amp; sec[j] == sec[las]) &#123; unique = false; rk[j] = rk[las]; &#125; else &#123; rk[j] = rk[las] + 1; &#125; &#125; las = j; &#125; if(unique) break; &#125; for(int i = 1, k = 0; i &lt;= sz; i ++) &#123; if(rk[i] == 1) &#123; k = 0; &#125; else &#123; if(k &gt; 0) k --; int j = sa[rk[i] - 1]; while(i + k &lt;= sz &amp;&amp; j + k &lt;= sz &amp;&amp; S[i + k] == S[j + k]) k ++; &#125; height[rk[i]] = k; &#125;&#125;int p[maxn], pd[maxn];int minv[maxn], maxv[maxn];void init_set() &#123; for(int i = 1; i &lt;= sz; i ++) &#123; p[i] = i; minv[i] = maxv[i] = sa[i]; pd[i] = 0; &#125;&#125;int get_fa(int x) &#123; if(p[x] == x) &#123; return x; &#125; else &#123; return (p[x] = get_fa(p[x])); &#125;&#125;void link_set(int x, int y) &#123; if(pd[x] &gt; pd[y]) std::swap(x, y); p[x] = y; minv[y] = std::min(minv[y], minv[x]); maxv[y] = std::max(maxv[y], maxv[x]); if(pd[x] == pd[y]) pd[y] ++;&#125;void merge_set(int x, int y) &#123; x = get_fa(x), y = get_fa(y); if(x != y) link_set(x, y);&#125;int solve() &#123; static std::vector&lt;int&gt; V[maxn]; process(); init_set(); for(int i = 1; i &lt;= sz; i ++) V[i].clear(); for(int i = 2; i &lt;= sz; i ++) &#123;#ifdef LOCAL printf("height[%d] : %d\n", i, height[i]);#endif V[height[i]].push_back(i); &#125; for(int i = sz; i &gt;= 1; i --) &#123; for(int j = 0; j &lt; V[i].size(); j ++) &#123; int u = V[i][j]; merge_set(u - 1, u); u = get_fa(u); if(maxv[u] - minv[u] &gt;= i) return i; &#125; &#125; return 0;&#125;int main() &#123; static int S2[maxn]; S[0] = 50000; while(scanf("%d", &amp;sz) == 1) &#123; if(!sz) break; for(int i = 1; i &lt;= sz; i ++) scanf("%d", &amp;S[i]); for(int i = sz; i &gt;= 1; i --) S[i] -= S[i - 1]; std::copy(S + 1, S + 1 + sz, S2 + 1); std::sort(S2 + 1, S2 + 1 + sz); int lsiz = std::unique(S2 + 1, S2 + 1 + sz) - S2 - 1; for(int i = 1; i &lt;= sz; i ++) &#123; S[i] = std::lower_bound(S2 + 1, S2 + 1 + lsiz, S[i]) - S2; &#125; int ret = solve() + 1; if(ret &gt;= 5) &#123; printf("%d\n", ret); &#125; else &#123; puts("0"); &#125; &#125; return 0;&#125; POJ 3415 Common Substrings Description 给出两个串\(A,B\)和一个一个正整数\(k\)，求出两个串长度不小于\(k\)的公共子串的数量。 \(1\leq |A|,|B|\leq 10^5,1\leq k\leq\min(|A|,|B|)\)，多组数据。两个串最多由全体拉丁字母组成。 Solution 首先还是考虑把\(\mathrm{height}[i] &lt; k\)的地方断开，剩下的地方连成块，然后剩下的每一块内部产生答案。 然后答案有两类，一类是在\(A\)中的后缀和排名比他小的\(B\)中的后缀产生答案，另一类情况是反过来的。那么会做第一类就会做第二类了。 考虑一个排名比\(i\)低的串，对\(i\)造成的贡献事两者的LCP再减\(k - 1\)，那么我们考虑怎么去维护所有串的贡献的和。我们注意到排名比\(\mathrm{sa}[i]\)越低，和\(\mathrm{sa}[i]\)的LCP就会越来越小，从左往右事单调递增的。所以我们可以用单调栈来维护这个东西。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;int idx(char c) &#123; if(c == '$') &#123; return 53; &#125; else if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') &#123; return c - 'a' + 1; &#125; else &#123; return c - 'A' + 27; &#125;&#125;const int maxn = 200005;char S[maxn]; int sz;int sa[maxn], rk[maxn], height[maxn];void process() &#123; static int fir[maxn], sec[maxn]; static int buf[maxn], tmp[maxn]; std::fill(buf, buf + std::max(sz, 53) + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[idx(S[i])] ++; for(int i = 1; i &lt;= 53; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) rk[i] = buf[idx(S[i]) - 1] + 1; for(int t = 1; t &lt;= sz; t &lt;&lt;= 1) &#123; for(int i = 1; i &lt;= sz; i ++) &#123; fir[i] = rk[i]; sec[i] = (i + t &gt; sz) ? 0 : rk[i + t]; &#125; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[sec[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) tmp[buf[sec[i]] --] = i; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[fir[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = sz; i &gt;= 1; i --) &#123; int j = tmp[i]; sa[buf[fir[j]] --] = j; &#125; bool unique = true; for(int i = 1, las = 0; i &lt;= sz; i ++) &#123; int j = sa[i]; if(!las) &#123; rk[j] = 1; &#125; else &#123; if(fir[j] == fir[las] &amp;&amp; sec[j] == sec[las]) &#123; unique = false; rk[j] = rk[las]; &#125; else &#123; rk[j] = rk[las] + 1; &#125; &#125; las = j; &#125; if(unique) break; &#125; for(int i = 1, k = 0; i &lt;= sz; i ++) &#123; if(rk[i] == 1) &#123; k = 0; &#125; else &#123; if(k &gt; 0) k --; int j = sa[rk[i] - 1]; while(i + k &lt;= sz &amp;&amp; j + k &lt;= sz &amp;&amp; S[i + k] == S[j + k]) k ++; &#125; height[rk[i]] = k; &#125;&#125;int s1, s2;bool check(int i) &#123; return (i &lt;= s1);&#125;struct Node &#123; int cnt, val; Node(int v, int c = 1) &#123; val = v; cnt = c; &#125; bool operator &lt;(const Node &amp;res) const &#123; return val &lt; res.val; &#125; bool operator ==(const Node &amp;res) const &#123; return val == res.val; &#125; bool operator &gt;(const Node &amp;res) const &#123; return val &gt; res.val; &#125;&#125;;int k;typedef long long ll;struct DStack &#123; std::stack&lt;Node&gt; S; ll ans; DStack() &#123; ans = 0; &#125; void clear() &#123; ans = 0; while(!S.empty()) S.pop(); &#125; void insert(Node x) &#123; while(!S.empty() &amp;&amp; (S.top() &gt; x || S.top() == x)) &#123; ll v = S.top().val, c = S.top().cnt; S.pop(); ans -= v * c; x.cnt += c; &#125; S.push(x); ans += (ll(x.cnt)) * (ll(x.val)); &#125;&#125;;ll solve(bool bs) &#123; DStack S; ll ans = 0; for(int i = 1; i &lt;= sz; i ++) &#123; if(height[i] &lt; k) &#123; S.clear(); continue; &#125; bool th = check(sa[i]); S.insert(Node(height[i] - k + 1, (check(sa[i - 1]) != bs) ? 1 : 0)); if(th == bs) ans += S.ans; &#125; return ans;&#125;int main() &#123; while(scanf("%d", &amp;k) == 1) &#123; if(!k) break; scanf("%s", S + 1); s1 = strlen(S + 1); S[s1 + 1] = '$'; scanf("%s", S + 2 + s1); sz = strlen(S + 1);#ifdef LOCAL printf("s1 : %d\nsz : %d\n", s1, sz); puts(S + 1);#endif process(); printf("%lld\n", solve(false) + solve(true)); &#125; return 0;&#125; LibreOJ 2059 「TJOI / HEOI2016」字符串 Description 给出一个长度为\(n\)的小写字母串\(S\)，\(m\)询问\(a, b, c, d\)，求出\(S[a\ldots b]\)的所有子串和\(S[c\ldots d]\)本身的LCP的最大值。 \(1\leq n, m\leq 10^5, 1\leq a\leq b\leq n, 1\leq c\leq d\leq n\)。 Solution 很显然这个东西的答案满足单调性……所以我们就二分答案吧。 那么考虑怎么判定呢。 假设当前二分出来的答案为\(k\)，那么和后缀\(c\ldots n\)的LCP为\(k\)的后缀在后缀数组中一定为一段区间（假设为\([l, r]\)），那么如果这段区间里有个\(i\)满足\(\mathrm{sa}[i]\in[a, b - k + 1]\)，那么显然答案合法，反之则不合法。 于是我们队后缀数组建主席树，然后每次判定就是确定\([l, r]\)（这个也可以二分答案搞）之后在一段区间里查询是否有值在一段区间里的位置就行了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;int idx(char c) &#123; if(c == '$') &#123; return 27; &#125; else &#123; return c - 'a' + 1; &#125;&#125;const int maxn = 100005;char S[maxn]; int sz;int sa[maxn], rk[maxn], height[maxn];void process() &#123; static int fir[maxn], sec[maxn]; static int buf[maxn], tmp[maxn]; std::fill(buf, buf + 28, 0); for(int i = 1; i &lt;= sz; i ++) buf[idx(S[i])] ++; for(int i = 1; i &lt;= 27; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) rk[i] = buf[idx(S[i]) - 1] + 1; for(int t = 1; t &lt;= sz; t &lt;&lt;= 1) &#123; for(int i = 1; i &lt;= sz; i ++) &#123; fir[i] = rk[i]; sec[i] = (i + t &gt; sz) ? 0 : rk[i + t]; &#125; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[sec[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) tmp[buf[sec[i]] --] = i; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[fir[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = sz; i &gt;= 1; i --) &#123; int j = tmp[i]; sa[buf[fir[j]] --] = j; &#125; bool unique = true; for(int i = 1, las = 0; i &lt;= sz; i ++) &#123; int j = sa[i]; if(!las) &#123; rk[j] = 1; &#125; else &#123; if(fir[j] == fir[las] &amp;&amp; sec[j] == sec[las]) &#123; unique = false; rk[j] = rk[las]; &#125; else &#123; rk[j] = rk[las] + 1; &#125; &#125; las = j; &#125; if(unique) break; &#125; for(int i = 1, k = 0; i &lt;= sz; i ++) &#123; if(rk[i] == 1) &#123; k = 0; &#125; else &#123; if(k &gt; 0) k --; int j = sa[rk[i] - 1]; while(i + k &lt;= sz &amp;&amp; j + k &lt;= sz &amp;&amp; S[i + k] == S[j + k]) k ++; &#125; height[rk[i]] = k; &#125;&#125;int minv[maxn][18], lim[maxn];void process_st() &#123; for(int i = 1; i &lt;= sz; i ++) &#123; minv[i][0] = height[i]; &#125; for(int j = 1; (1 &lt;&lt; j) &lt;= sz; j ++) &#123; for(int i = 1; (i + (1 &lt;&lt; j) - 1) &lt;= sz; i ++) &#123; minv[i][j] = std::min(minv[i][j - 1], minv[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; for(int i = 1; i &lt;= sz; i ++) &#123; int v = 0; while((1 &lt;&lt; (v + 1)) &lt;= i) v ++; lim[i] = v; &#125;&#125;int query(int l, int r) &#123; if(l &gt; r) return 0x7fffffff; int c = lim[r - l + 1]; return std::min(minv[l][c], minv[r - (1 &lt;&lt; c) + 1][c]);&#125;const int bufsiz = 100 * 1024 * 1024;char buf[bufsiz]; char *cur = buf;void *alloc(size_t size) &#123; if(buf - cur + size &gt; bufsiz) &#123; return malloc(size); &#125; else &#123; char *ret = cur; cur += size; return ret; &#125;&#125;struct Node &#123; Node *lc, *rc; int sumv;&#125;;Node *nil;void init_pool() &#123; nil = (Node*)alloc(sizeof(Node)); nil -&gt; sumv = 0; nil -&gt; lc = nil -&gt; rc = nil;&#125;Node *alloc_node(int v = 0, Node *lc = nil, Node *rc = nil) &#123; Node *ret = (Node*)alloc(sizeof(Node)); ret -&gt; sumv = v; ret -&gt; lc = lc; ret -&gt; rc = rc; return ret;&#125;Node *modify(Node *o, int L, int R, int p, int v) &#123; Node *ret = alloc_node(o -&gt; sumv + v, o -&gt; lc, o -&gt; rc); if(L &lt; R) &#123; int M = (L + R) / 2; if(p &lt;= M) &#123; ret -&gt; lc = modify(ret -&gt; lc, L, M, p, v); &#125; else &#123; ret -&gt; rc = modify(ret -&gt; rc, M + 1, R, p, v); &#125; &#125; return ret;&#125;int query(Node *o, int L, int R, int ql, int qr) &#123; if(ql &lt;= L &amp;&amp; R &lt;= qr) &#123; return o -&gt; sumv; &#125; else &#123; int ans = 0; int M = (L + R) / 2; if(ql &lt;= M) ans += query(o -&gt; lc, L, M, ql, qr); if(qr &gt; M) ans += query(o -&gt; rc, M + 1, R, ql, qr); return ans; &#125;&#125;Node *T[maxn];int query(int lt, int rt, int l, int r) &#123; return query(T[rt], 1, sz, l, r) - query(T[lt - 1], 1, sz, l, r);&#125;void process_tree() &#123; init_pool(); T[0] = nil; for(int i = 1; i &lt;= sz; i ++) &#123; T[i] = modify(T[i - 1], 1, sz, sa[i], 1); &#125;#ifdef LOCAL puts("Processing tree ended!"); fflush(stdout);#endif&#125;bool check(int x, int c, int l, int r) &#123; int L, R, lp = c, rp = c; L = 1, R = c - 1; while(true) &#123; if(R - L &lt;= 3) &#123; for(int i = L; i &lt;= R; i ++) &#123; if(query(i + 1, c) &gt;= x) &#123; lp = i; break; &#125; &#125; break; &#125; int M = (L + R) / 2; if(query(M + 1, c) &gt;= x) &#123; R = M; &#125; else &#123; L = M; &#125; &#125; L = c + 1, R = sz; while(true) &#123;#ifdef LOCAL printf("CState (%d, %d)\n", L, R); fflush(stdout);#endif if(R - L &lt;= 3) &#123; for(int i = R; i &gt;= L; i --) &#123; if(query(c + 1, i) &gt;= x) &#123; rp = i; break; &#125; &#125; break; &#125; int M = (L + R) / 2; if(query(c + 1, M) &gt;= x) &#123; L = M; &#125;else &#123; R = M; &#125; &#125;#ifdef LOCAL printf("%d : [%d, %d]\n", c, lp, rp); fflush(stdout);#endif return (query(lp, rp, l, r) &gt; 0);&#125;int solve(int a, int b, int c, int d) &#123; int L = 1, R = std::min(d - c + 1, b - a + 1); int ret = 0; while(true) &#123;#ifdef LOCAL printf("State (%d, %d)\n", L, R); fflush(stdout);#endif if(R - L &lt;= 3) &#123; for(int i = R; i &gt;= L; i --) &#123; if(check(i, rk[c], a, b - i + 1)) &#123; ret = i; break; &#125; &#125; break; &#125; int M = (L + R) / 2; if(check(M, rk[c], a, b - M + 1)) &#123; L = M; &#125; else &#123; R = M; &#125; &#125; return ret;&#125;int main() &#123; int q; scanf("%d%d%s", &amp;sz, &amp;q, S + 1); process(); process_st(); process_tree(); while(q --) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); printf("%d\n", solve(a, b, c, d)); &#125; return 0;&#125; 后缀自动机 介绍 还在路上，马上就来了（鸽并感） 题目 例题1 Description 给一个字母串，求出它的最小表示法（就是可以进行若干次循环位移，使得串的字典序尽可能小）。 \(n\leq 10^{5}\)。 Solution 把串复制两份接一块，那么很显然就是要求新串的一个长度为\(n\)的子串，使得这个串的字典序最小。 那么考虑建新串的后缀自动机。从根开始每一步走尽可能小的转移边即可。 LibreOJ 2033 「SDOI2016」生成魔咒 Description 有一个初始为空的整数串\(S\)，要求动态的往尾部加数，每次操作完后求数字串的本质不同子串数目。 操作次数不超过十万次，\(S\)中的数在\([1, 10^9]\)中。 Solution 参考原博客 SPOJ NSUBSTR Description 给一个字符串\(S\)，用\(F(x)\)表示所有\(S\)的长度为\(x\)的子串中出现次数的最大值。求\(F(1)\ldots F(|S|)\)。 \(|S|\leq 250000\)。 Solution 参考原博客 SPOJ LCS2 Description 给你至多十个串，求他们的最长公共子串。 每个串的大小不超过十万。 Solution 参考原博客 LibreOJ 2102 「TJOI2015」弦论 Description 对于一个长为\(n\)的小写字母串\(S\)，求它的第\(k\)小子串。 每组数据还给定一个\(T\)，表示对于不同位置的相同子串是否算一种。 \(n\leq 5\times 10^5, k\leq 10^9\)。 Solution 参考原博客 LibreOJ 2137 「ZJOI2015」诸神眷顾的幻想乡 Description 给出一个点上写着字符（这里字符定义为小于\(c\)的自然数）的树，度数为1的点的数量不超过20。定义其子串为从一个点延最短路走到另一个点（显然方案唯一），把经过的点上的字符顺次写下来所得到的字符串。 求这棵树有多少种本质不同子串。 \(1\leq n\leq 10^5, 1\leq c\leq 10\)。 Solution 参考原博客]]></content>
      <categories>
        <category>大坑</category>
      </categories>
      <tags>
        <tag>SPOJ</tag>
        <tag>LibreOJ</tag>
        <tag>TJOI</tag>
        <tag>后缀自动机</tag>
        <tag>后缀数组</tag>
        <tag>后缀树</tag>
        <tag>后缀平衡树</tag>
        <tag>POJ</tag>
        <tag>SDOI</tag>
        <tag>HEOI</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 6052 「雅礼集训 2017 Day11」DIV]]></title>
    <url>%2F2018%2F07%2F24%2Floj6052%2F</url>
    <content type="text"><![CDATA[Description 定义复数\(a + bi\)为\(k\)的约数，当且仅当\(a, b\)为整数且存在整数\(c, d\)满足\((a + bi)(c + di) = k\)。 给定\(n\)，求\(1\)到\(n\)中所有整数的实部大于\(0\)的约数的实部的和。 答案模1004535809。 \(n\leq 10^{10}\)。 Solution 为啥这题和某课件上的简化版差距这么大啊…… 考虑一个复数\((a + bi)(c + di) = k\)意味着什么，其实也就是下面两个式子： \[ ac - bd = k\\ ad + bc = 0 \] 由第二个式子可得： \[ \frac{a}{b} = -\frac{c}{d} \] 那么我们考虑将\(a, b\)约去他们两个之间的最大公约数，\(c, d\)也做一样的操作。那么上式还是成立的，并且等号两边的分式都已经最简化了，因此此时有\(a = c, b = -d\)。 带回最早的式子（两个复数的积那个）可以得到： \[ c(a^2 + b^2) = k \] 这个\(c\)是我们先前约去的常数的积。从此式也可以看出\((a^2+b^2)|k\)，并且贡献一定是\(a\)乘上一个常数。 那么我们枚举互质数对\((a, b)\)，其对答案的贡献是\(a\sigma(\frac{n}{a^2 + b^2})\)（这里\(\sigma\)表示\(\sigma_1\)，即约束之和）。 因此最终答案为： \[ \begin{aligned} \quad&amp;\sum_{i = 1}^n\sum_{a\perp b, (a^2 + b^2) | i} a\sigma(\frac{i}{a^2+b^2}) \end{aligned} \] 这玩怕不是几乎不可做……因此我们考虑枚举\(k = a^2 + b^2\)： \[ \begin{aligned} \quad&amp;\sum_{k = 1}^n\sum_{a\perp b, a^2 + b^2 = k} a\sum_{k | i}\sigma(\frac{i}{k})\\ =&amp;\sum_{k = 1}^n\sum_{a\perp b, a^2 + b^2 = k} aD(\lfloor\frac{n}{k}\rfloor)\\ =&amp;\sum_{k = 1}^nD(\lfloor\frac{n}{k}\rfloor)\sum_{a\perp b, a^2 + b^2 = k} a\\ =&amp;\sum_{k = 1}^nD(\lfloor\frac{n}{k}\rfloor)f(k) \end{aligned} \] 其中\(D\)为\(\sigma\)的前缀和，\(f(k)\)表记的是啥可以根据上下文推导一下（逃 这个形式几乎和杜教筛如出一辙……像杜教筛一样先大力数论分块，然后先考虑怎么处理\(D\)，很显然有一个\(O(\sqrt{n})\)的做法： \[ \sum_{i = 1}^n i\lfloor\frac{n}{i}\rfloor \] 如此一来我们可以考虑先预处理不大于\(n^\frac{2}{3}\)的\(D\)值，其他情况用上面的式子求（甚至不需要记忆化复杂度也是对的）。用杜教筛那种复杂度证明可以证出这部分的复杂度是\(O(n^\frac{2}{3})\)的。 然后我们发现我们其实也要处理\(f​\)的前缀和\(F​\)……但是有个互质在这这个玩意并不好处理。那么我们考虑类似于狄利克雷卷积的一些思路？定义一个\(G(x) = \sum_{1\leq a^2+b^2\leq x}a​\)，这个东西可以很方便的用\(O(\sqrt{n})​\)的复杂度求（\(G(x)=\sum_{i = 1}^{\lfloor\sqrt{x}\rfloor}i\lfloor\sqrt{x - i^2}\rfloor​\)），然后我们发现有： \[ G(x) = \sum_{i = 1}^{\lfloor\sqrt{x}\rfloor}iF(\lfloor\frac{x}{i^2}\rfloor) \] 然后这个还是有点像杜教筛的一些形式啊！我们发现我们要抽出来的事\(F(x)\)，因此移一下项就有了： \[ F(x)=G(x) - \sum_{i = 2}^{\lfloor\sqrt{x}\rfloor}iF(\lfloor\frac{x}{i^2}\rfloor) \] 还是如出一辙的处理套路啊……对于大于\(n^\frac{2}{3}\)的情况我们直接用这个式子\(O(\sqrt{n})\)求（顺便记忆化）；其他情况就要考虑预处理了，那么我们考虑预处理\(f(x)\)本身，这个东西可以通过枚举\(a\)然后枚举\(b\)最后判断是否互质的搞法在\(O(n^\frac{2}{3}\log n)\)的复杂度里搞出来。总复杂度证明还是和杜教筛如出一辙。 然后做完了？其实并没有。我们上面钦点了复数虚部为正整数。至于负整数和正整数的情况对称，答案完全一致。如果虚部为\(0\)的话那么参与运算的全都是正整数，因此此时答案就是\(D(n)\)了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;unordered_map&gt;const int N = 5000000;using ll = long long;const ll ha = 1004535809LL;ll d[N + 5], f[N + 5];int prm[N + 5]; bool vis[N + 5];int gcd(int a, int b) &#123; if(!b) &#123; return a; &#125; else &#123; return gcd(b, a % b); &#125;&#125;void sieve() &#123; int cnt = 0; vis[1] = true; d[1] = 1; f[1] = 0; for(int i = 2; i &lt;= N; i ++) &#123; if(!vis[i]) &#123; d[i] = i + 1; prm[cnt ++] = i; &#125; for(int j = 0; j &lt; cnt; j ++) &#123; int v = i * prm[j]; if(v &gt; N) break; vis[v] = true; if(i % prm[j] == 0) &#123; d[v] = d[i] * d[prm[j]] - (ll)prm[j] * d[i / prm[j]]; break; &#125; else &#123; d[v] = d[i] * d[prm[j]]; &#125; &#125; &#125; for(int i = 1; i * i &lt;= N; i ++) &#123; for(int j = 1; j * j + i * i &lt;= N; j ++) &#123; if(gcd(i, j) == 1) &#123; f[j * j + i * i] += i; &#125; &#125; &#125; for(int i = 1; i &lt;= N; i ++) &#123; d[i] = (d[i] + d[i - 1]) % ha; f[i] = (f[i] + f[i - 1]) % ha; &#125;&#125;std::unordered_map&lt;ll, ll&gt; ma_d;ll S(ll n) &#123; static const ll inv_2 = 502267905LL; ll ret = ((n % ha) * ((n + 1) % ha)) % ha; ret = (ret * inv_2) % ha; return ret;&#125;ll sigma(ll n) &#123; if(n &lt;= (ll)N) return d[n]; if(ma_d.count(n)) return ma_d[n]; ll ret = 0; for(ll i = 1; i &lt;= n;) &#123; ll next = n / (n / i); ll delta = (S(next) - S(i - 1) + ha) % ha; delta = (delta * ((n / i) % ha)) % ha; ret = (ret + delta) % ha; i = next + 1LL; &#125; ma_d[n] = ret; return ret;&#125;std::unordered_map&lt;ll, ll&gt; ma_f;ll calc_f(ll n) &#123; if(n &lt;= (ll)N) return f[n]; if(ma_f.count(n)) return ma_f[n]; ll ret = 0; for(ll i = 1; i * i &lt;= n; i ++) &#123; ll delta = floor(sqrt(n - i * i)); delta %= ha; delta = (delta * i) % ha; ret = (ret + delta) % ha; &#125; for(ll i = 2; i * i &lt;= n; i ++) &#123; ll delta = (calc_f(n / (i * i)) * i) % ha; ret = (ret - delta + ha) % ha; &#125; ma_f[n] = ret; return ret;&#125;ll calc(ll n) &#123; ll ret = 0, las = 0; for(ll i = 1; i &lt;= n;) &#123; ll next = n / (n / i); ll th = calc_f(next); ll delta = (th - las + ha) % ha; delta = (delta * sigma(n / i)) % ha; ret = (ret + delta) % ha; las = th; i = next + 1LL; &#125; return ret;&#125;int main() &#123; sieve(); ll n; scanf("%lld", &amp;n); printf("%lld\n", (calc(n) * 2LL + sigma(n)) % ha); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>狄利克雷卷积</tag>
        <tag>杜教筛</tag>
        <tag>LibreOJ</tag>
        <tag>雅礼集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 6053 简单的函数]]></title>
    <url>%2F2018%2F07%2F24%2Floj6053%2F</url>
    <content type="text"><![CDATA[Description 今有一积性函数\(f(x)\)，满足以下性质 \(f(1) = 1\)。 对任意质数\(p\)和正整数\(c\)，有\(f(p^c) = p\oplus c\)。 给定正整数\(n\)，求\(\sum_{i = 1}^n f(i)\)，答案模1000000007。 \(n\leq 10^{10}\)。 Solution 算是一道不那么水的Min_25筛板子题？ Min_25筛最核心的地方就是对于质数的答案求前缀和。那么我们考虑对任意质数\(p\)，\(f(p)\)的取值。然后我们会发现除了\(2\)以外的所有质数都是奇数，所以对于\(2\)有\(f(p) = p + 1\)，对其他质数有\(f(p) = p - 1\)。 那么我们把质数的答案分为两部分考虑：一部分是\(p\)，另一部分是后面的加减一。前面一部分就是质数本身的和，几乎就是最简单的Min_25筛；后面也不难，只需要对于小于等于2的情况特判一下就完了。 然后下面就是标准的Min_25筛了……Min_25筛真香！ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;const int maxn = 200005;using ll = long long;const ll ha = 1000000007LL;ll sqr(ll x) &#123; ll ret = 1; while((ret + 1LL) * (ret + 1LL) &lt;= x) ret ++; return ret;&#125;ll n, S; int cnt;ll A[2][maxn]; ll prm[maxn];void sieve_0() &#123; S = sqr(n); cnt = 0; for(int i = 1; i &lt;= S; i ++) &#123; A[0][i] = i; &#125; for(int i = 1; i &lt;= S; i ++) &#123; A[1][i] = (n / (ll(i))) % ha; &#125; for(int i = 2; i &lt;= S; i ++) &#123; if(A[0][i - 1] == A[0][i]) continue; prm[++ cnt] = i; ll lim = (ll(i)) * (ll(i)), v = A[0][i - 1]; for(int j = 1; j &lt;= S / i; j ++) &#123; ll delta = (A[1][j * i] - v + ha) % ha; A[1][j] = (A[1][j] - delta + ha) % ha; &#125; for(int j = S / i + 1; j &lt;= S; j ++) &#123; ll src = n / ((ll(j)) * (ll(i))); if(src &lt; (ll)i) break; ll delta = (A[0][src] - v + ha) % ha; A[1][j] = (A[1][j] - delta + ha) % ha; &#125; for(int j = S; (ll)j &gt;= lim; j --) &#123; ll delta = (A[0][j / i] - v + ha) % ha; A[0][j] = (A[0][j] - delta + ha) % ha; &#125; &#125; prm[++ cnt] = S + 1;&#125;ll B[2][maxn];ll S1(ll x) &#123; ll a = x, b = x + 1LL; if(x &amp; 1LL) &#123; b &gt;&gt;= 1; &#125; else &#123; a &gt;&gt;= 1; &#125; a %= ha; b %= ha; return (a * b) % ha;&#125;void sieve_1() &#123; S = sqr(n); cnt = 0; for(int i = 1; i &lt;= S; i ++) &#123; B[0][i] = S1(i); &#125; for(int i = 1; i &lt;= S; i ++) &#123; B[1][i] = S1(n / (ll(i))); &#125; for(int i = 2; i &lt;= S; i ++) &#123; if(B[0][i - 1] == B[0][i]) continue; prm[++ cnt] = i; ll lim = (ll(i)) * (ll(i)), v = B[0][i - 1]; for(int j = 1; j &lt;= S / i; j ++) &#123; ll delta = (B[1][j * i] - v + ha) % ha; delta = (delta * (ll(i))) % ha; B[1][j] = (B[1][j] - delta + ha) % ha; &#125; for(int j = S / i + 1; j &lt;= S; j ++) &#123; ll src = n / ((ll(j)) * (ll(i))); if(src &lt; (ll)i) break; ll delta = (B[0][src] - v + ha) % ha; delta = (delta * (ll(i))) % ha; B[1][j] = (B[1][j] - delta + ha) % ha; &#125; for(int j = S; (ll)j &gt;= lim; j --) &#123; ll delta = (B[0][j / i] - v + ha) % ha; delta = (delta * (ll(i))) % ha; B[0][j] = (B[0][j] - delta + ha) % ha; &#125; &#125; prm[++ cnt] = S + 1;#ifdef LOCAL for(int i = 1; i &lt;= cnt; i ++) &#123; printf("prm[%d] : %lld\n", i, prm[i]); &#125; for(int i = 1; i &lt;= S; i ++) &#123; printf("B[%d] : %lld\n", i, B[0][i]); &#125; for(int i = S; i &gt;= 1; i --) &#123; printf("B[%lld] : %lld\n", n / (ll(i)), B[1][i]); &#125;#endif&#125;ll query_0(ll x) &#123; if(x &lt;= 1LL) return 0; if(x == 2LL) return 1; ll ret; if(x &lt;= S) &#123; ret = A[0][x]; &#125; else &#123; ret = A[1][n / x]; &#125; ret --; ret = (2LL - ret + ha) % ha; return ret;&#125;ll query_1(ll x) &#123; if(x &lt;= S) &#123; return B[0][x]; &#125; else &#123; return B[1][n / x]; &#125;&#125;ll calc(ll m, int x) &#123; if(m &lt; prm[x]) return 0; ll ret = (query_0(m) + query_1(m)) % ha; ret = (ret - (query_0(prm[x] - 1) + query_1(prm[x] - 1)) % ha + ha) % ha; for(int i = x; i &lt;= cnt; i ++) &#123; ll st = prm[i]; if(st * prm[i] &gt; m) break; for(int j = 1; ; j ++) &#123; if(st * prm[i] &gt; m) break; ll delta = ((calc(m / st, i + 1) * (prm[i] ^ (ll(j)))) % ha + (prm[i] ^ (ll(j + 1)))) % ha; ret = (ret + delta) % ha; st *= prm[i]; &#125; &#125; return ret;&#125;int main() &#123; scanf("%lld", &amp;n); sieve_0(); sieve_1(); printf("%lld\n", (1LL + calc(n, 1)) % ha); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Min_25筛</tag>
        <tag>LibreOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4314 倍数？倍数！]]></title>
    <url>%2F2018%2F07%2F21%2FBZOJ4314%2F</url>
    <content type="text"><![CDATA[Description 要求你从\(Z_n\)（模\(n\)的剩余系）里选出\(k\)个不重复元素，使得他们的和模\(n\)为0。求方案数。 \(1\leq n\leq 10^9, 1\leq k\leq 10^3\)。 Solution 看上去就很像单位根反演的题？ 先放一下众所周知的单位根反演的式子： \[ \frac{1}{n}\sum_{i = 0}^{n - 1}(\xi_{n}^i)^k=[n | k] \] 证明很容易：假如有\(n | k\)，那么和式中每一项都是1，加起来除\(n\)后就事1了（这种情况下等比数列公比为1，所以不可以采用等比数列求和公式）；反之，我们采用等比数列求和公式可知原式中的和式为\(\frac{1 - \xi_n^{kn}}{1 - \xi_n^k}\)，这个东西的分子为0，那么自然和式左边为0。 那么考虑构造二元答案多项式\(f(x, y)\)： \[ f(x, y) = \prod_{i = 0}^{n - 1}(1 + x^iy) \] 这个多项式的每一项中\(x\)的次数表示和，\(y\)表示选数的数量。我们显然要求所有含\(y^k\)且\(x\)的次数为\(n\)的倍数的项的系数之和，那么考虑将\(y\)视为常数，对\(x\)进行单位根反演： \[ f(\xi_n^t, y)=\prod_{i = 0}^{n - 1}(1 + (\xi_n^{t})^iy) \] 观察到如果\(t\)和\(n\)不互质，那么两者可以同时约去一约数（反之，若有\(t\perp n\)，那么称\(\xi_n^t\)为一个\(n\)次本原单位根）。假设约完之后的单位根为\(\xi_a^b\)，那么我们发现当积式中枚举的\(i\)大于\(a\)时，会出现循环。所以我们只需要取循环节（显然长度为\(a\)，因为我们知道所有\(a\)阶单位根构成一个循环群，而\(a\)阶本原单位根一定是该群的生成元。原因事首先显然用\(\xi_a^1\)可以生成所有\(a\)阶单位根，所以所有\(a\)阶单位根构成一个循环群；然后你根据数论里的欧拉定理可以知道\(x^{\phi(p)}\equiv 1\pmod{p}(x\perp p)\)，那么对于任意本原单位根\(\xi_a^b\)有\(\xi_a^{b^{\phi(a)}} = \xi_a^1\)，式子左边的东西是\(\xi_a^b\)的若干次方，所以用\(\xi_a^b\)可以生成\(\xi_a^1\)，自然就可以生成整个循环群）的若干次方就行了，那么有： \[ f(\xi_a^b, y) = (\prod_{i = 0}^{a - 1}(1 + (\xi_a^b)^iy))^\frac{n}{a} \] 根据上面的说法，考虑里面的积式一定可以枚举到所有\(a\)阶单位根，所以这个积式也可以写成： \[ f(\xi_a^b, y) = (\prod_{i = 0}^{a - 1} (1 + \xi_a^iy))^\frac{n}{a} \] 这么一来，我们发现对于任意\(a\)阶本原单位根\(\xi_a^b\)，对答案的贡献都是一样的，而我们知道\(a\)阶本原单位根有\(\phi(a)\)个。只要我们对所有\(n\)的约数求出其所有本原单位根的贡献的和，那么这题就做完了。 那么我们考虑，如果我们知道了\(a\)，那么怎么快速求一个本原单位根的贡献呢？ 考虑那个多项式（里面的积式），首先很容易发现其0次项为1。然后我们从零点入手…… 然后我们发现这个多项式几乎没法求零点……那么我们做一步小转换吧： \[ \prod_{i = 0}^{a - 1}\xi_a^i(\xi_a^{a - i} + y) \] 然后我们发现\(\xi_a^{a - i}\)就枚举了所有单位根，所以零点集合就是所有单位根相反数的集合。 如果\(a\)为偶数，那么把所有单位根取相反数之后得到的集合其实和原集合事一样的……这个大致可以理解为所有单位根构成的图形关于原点中心对称。而我们知道\(x^a - 1 = 0\)的解就是全体\(a\)阶单位根，因此答案多项式和\(x^a - 1\)只有常数项的不同，而取反之后得到了\(1 - x^a\)，其零点、常数项都符合我们的要求。 如果\(a\)为奇数，那么考虑\(x^a\)，往里面带一个单位根的相反数的话，因为\(a\)为奇数所以会得到\(-1\)，所以该多项式的零点就是\(x^a + 1 = 0\)的全体解。而左边多项式的常数项也符合我们的要求，因此此时多项式为\(1 + x^a\)。 综上可得： \[ \prod_{i = 0}^{a - 1}(1 + \xi_a^iy) = 1 - (-y)^a \] 而最后的答案多项式为： \[ \frac{1}{n}\sum_{d | n}\phi(d)(1 - (-y)^d)^\frac{n}{d} \] 这个东西的\(y^k\)项的系数就是答案了…… Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;typedef long long ll;const ll ha = 1000000007LL;ll pow_mod(ll a, ll b) &#123; ll ans = 1LL, res = a; while(b) &#123; if(1LL &amp; b) ans = (ans * res) % ha; res = (res * res) % ha; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow_mod(x, ha - 2LL);&#125; ll sqrt(ll n) &#123; ll ans = 1; while((ans + 1LL) * (ans + 1LL) &lt;= n) ans ++; return ans;&#125;int phi(int n) &#123; int ans = n, m = sqrt(n); for(int i = 2; i &lt;= m; i ++) &#123; if(n % i == 0) &#123; ans = (ans / i) * (i - 1); while(n % i == 0) n /= i; &#125; &#125; if(n &gt; 1) ans = (ans / n) * (n - 1); return ans;&#125;ll C(int n, int m) &#123; if(n &lt; m) return 0; ll ans = 1; for(int i = 1; i &lt;= m; i ++) &#123; ans = (ans * (ll(n - i + 1))) % ha; ans = (ans * inv(i)) % ha; &#125; return ans;&#125;ll query(int d, int nd, int k) &#123; if(k % d != 0) return 0; ll ret = phi(d); if(d % 2 == 0 &amp;&amp; (k / d) % 2 != 0) &#123; ret = (ha - ret) % ha; &#125; ret = (ret * C(nd, k / d)) % ha; return ret;&#125;ll calc(int n, int k) &#123; int m = sqrt(n); ll ans = 0; for(int i = 1; i &lt;= m; i ++) &#123; if(n % i != 0) continue; ans = (ans + query(i, n / i, k)) % ha; if(i * i != n) ans = (ans + query(n / i, i, k)) % ha; &#125; ans = (ans * inv(n)) % ha; return ans;&#125; int main() &#123; int n, k; scanf("%d%d", &amp;n, &amp;k); printf("%lld\n", calc(n, k)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>单位根</tag>
        <tag>单位根反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ 221「NOI2016」循环之美]]></title>
    <url>%2F2018%2F07%2F21%2FNOI2016D1T3%2F</url>
    <content type="text"><![CDATA[Description 求有多少数值不同的分数\(\frac{x}{y}\)（\(1\leq x\leq n, 1\leq y\leq m\)），满足其在\(k\)进制下化为小数之后事纯循环小数（即小数部分是无限循环的）。 \(1\leq n, m\leq 10^9,2\leq k\leq 2000\)。 Solution 首先如果只统计最简分数就能保证数值相同辣（即钦点\(x\perp y\)，这里用垂直符号表示互质）。然后通过猜结论等手段可以发现纯循环小数其实限制了\(y\perp k\)。 然后考虑颓柿子： \[ \begin{aligned} \quad&amp;\sum_{x = 1}^n\sum_{y = 1}^m [x\perp y][y\perp k]\\ =&amp;\sum_{x = 1}^n\sum_{y = 1,y\perp k}^m \sum_{d | x, d | y}\mu(d)\\ =&amp;\sum_{d = 1,d\perp k}^{\min(n, m)}\mu(d)\lfloor\frac{n}{d}\rfloor\sum_{y = 1}^{\lfloor\frac{m}{d}\rfloor}[y\perp k] \end{aligned} \] 然后这样是个反演的形式……很容易想到数论分块罢…… 接下来首先要考虑对于所有\(\lfloor\frac{m}{d}\rfloor\)处理出范围内和\(k\)互质的数的数量，这个很容易想到洲阁筛的思路。考虑筛出\(k\)的所有质因子\(p_1,p_2,\ldots,p_c\)，定义状态\(f(i, j)\)表示不大于\(j\)且和\(p_1, p_2,\ldots,p_i\)互质的数的数目（边界为\(f(0, j) = j\)）。然后转移很显然是： \[ f(i, j) = f(i - 1, j) - f(i - 1, \lfloor\frac{j}{p_i}\rfloor) \] 然后我们还有一块硬骨头……就是对于所有\(\lfloor\frac{n}{d}\rfloor\)要求出范围内和\(k\)互质的\(d\)的\(\mu(d)\)的和。还是采用洲阁筛的思路，定义\(g(i, j)\)表示对于所有\(d\)满足\(d\leq j\)且\(d\perp p_1, p_2,\ldots, p_i\)的\(\mu(d)\)的和，这样边界\(g(0, j)\)也就是直接对\(\mu\)求一个前缀和，这个杜教筛处理。其他情况的话，我们要排除在一个没有前\(i\)个质因子的数的基础上乘上\(p_i\)的情况（如果有\(p_i\)这个质因子的话再乘一遍就变成0了，所以对答案没有影响），故转移如下： \[ g(i,j)=g(i - 1, j) + g(i, \lfloor\frac{j}{p_i}\rfloor) \] 考虑到这题\(k\)不大，所以第一维非常的小，甚至不需要用洲阁筛的一般加速方法。总复杂度为\(O(n^\frac{2}{3} + \omega(k)\sqrt{n})\)。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;unordered_map&gt;using ll = long long;const int N = 10000000;int mu[N + 5]; int mu_S[N + 5];int prm[N + 5]; bool vis[N + 5];void process() &#123; mu[1] = 1; vis[1] = true; int cnt = 0; for(int i = 2; i &lt;= N; i ++) &#123; if(!vis[i]) &#123; prm[cnt ++] = i; mu[i] = -1; &#125; for(int j = 0; j &lt; cnt &amp;&amp; i * prm[j] &lt;= N; j ++) &#123; int v = i * prm[j]; vis[v] = true; if(i % prm[j] == 0) &#123; mu[v] = 0; break; &#125; else &#123; mu[v] = -mu[i]; &#125; &#125; &#125; for(int i = 1; i &lt;= N; i ++) &#123; mu_S[i] = mu_S[i - 1] + mu[i]; &#125;&#125;int p[12]; int pcnt;void desc(int x) &#123; pcnt = 0; int l = sqrt(x + 0.5); for(int i = 2; i &lt;= l; i ++) &#123; if(x % i == 0) &#123; p[++ pcnt] = i; while(x % i == 0) x /= i; &#125; &#125; if(x &gt; 1) p[++ pcnt] = x;&#125;std::unordered_map&lt;int, ll&gt; h1[12];ll calc_1(int c, int n) &#123; if(c == 0) return n; if(n == 0) return 0; if(h1[c].count(n)) return h1[c][n]; ll ret = calc_1(c - 1, n) - calc_1(c - 1, n / p[c]); h1[c][n] = ret; return ret;&#125;std::unordered_map&lt;int, ll&gt; h2[12];ll calc_2(int c, int n) &#123; if(c == 0) &#123; if(n &lt;= N) return mu_S[n]; if(h2[0].count(n)) return h2[0][n]; ll ret = 1; for(int i = 2; i &lt;= n;) &#123; int next = n / (n / i); ret -= (ll(next - i + 1)) * calc_2(0, n / i); i = next + 1; &#125; h2[0][n] = ret; return ret; &#125; if(n == 0) return 0; if(h2[c].count(n)) return h2[c][n]; ll ret = calc_2(c - 1, n) + calc_2(c, n / p[c]); h2[c][n] = ret; return ret;&#125;ll calc(int n, int m, int k) &#123; desc(k); ll ans = 0; ll las = 0; for(int i = 1; i &lt;= std::min(n, m);) &#123; int next = std::min(n / (n / i), m / (m / i)); ll th = n / i; th *= (ll)calc_1(pcnt, m / i); ll ts = calc_2(pcnt, next); th *= (ts - las); ans += th; i = next + 1; las = ts; &#125; return ans;&#125;int main() &#123; process(); int n, m, k; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); printf("%lld\n", calc(n, m, k)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NOI</tag>
        <tag>洲阁筛</tag>
        <tag>UOJ</tag>
        <tag>狄利克雷卷积</tag>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3551「ONTAK2010」Peaks加强版]]></title>
    <url>%2F2018%2F07%2F18%2FBZOJ3551%2F</url>
    <content type="text"><![CDATA[真他X的是个弟弟。 初中会嘴巴的东西，高中不会了。 写了骗分，被多组数据雷普了，从75到5。 我谔谔，还事书这题罢，，， 这题大概可以用可持久化并查集套可持久化平衡树或权值线段树啥的做一下（逃 然后我们考虑用一种简单的做法…… 如果我们最后的并查集树中只有原图中的点的话，那么很多信息会非常难处理，那么是否可以考虑引入边？ 在Kruskal的过程中，边被从小到大加入。那么我们给每个边建一个点，用来维护经过这条边才能联通的点的信息。最后我们会得到一棵满二叉树。 这样的好处事有很多的……首先我们可以把信息维护在边上了。这个题要求\(k\)大，所以我们就用可持久化权值线段树吧，然后每个非叶子结点合并信息的时候直接可持久化的线段树合并就行了。 然后还有一个小好处，就是这棵树显然从叶子向上的边点的权值事单调不降的，这样我们可以直接倍增找到一个最往上的符合限制的祖先，用这个祖先的信息就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;const int maxn = 200005;const int maxm = 500005;int n, m;struct Edge &#123; int u, v, d; bool operator &lt;(const Edge &amp;res) const &#123; return d &lt; res.d; &#125;&#125;;Edge E[maxm];const int bufsiz = 1024 * 1024 * 40;char buf[bufsiz]; char *cur = buf;void *alloc(size_t size) &#123; if(cur - buf + size &gt; bufsiz) &#123; return malloc(size); &#125; else &#123; char *ret = cur; cur += size; return ret; &#125;&#125;struct Node &#123; int sumv; Node *lc, *rc;&#125;;Node *nil;void init_tree() &#123; nil = (Node*)alloc(sizeof(Node)); nil -&gt; sumv = 0; nil -&gt; lc = nil -&gt; rc = nil;&#125;Node *alloc_node(int v = 0, Node *lc = nil, Node *rc = nil) &#123; Node *ret = (Node*)alloc(sizeof(Node)); ret -&gt; sumv = v; ret -&gt; lc = lc; ret -&gt; rc = rc; return ret;&#125;Node *gen_chain(int L, int R, int p, int v) &#123; if(L == R) &#123; return alloc_node(v); &#125; else &#123; int M = (L + R) / 2; Node *lc = nil, *rc = nil; if(p &lt;= M) &#123; lc = gen_chain(L, M, p, v); &#125; else &#123; rc = gen_chain(M + 1, R, p, v); &#125; return alloc_node(v, lc, rc); &#125;&#125;Node *merge(Node *A, Node *B) &#123; if(A == nil) return B; if(B == nil) return A; Node *lc = merge(A -&gt; lc, B -&gt; lc); Node *rc = merge(A -&gt; rc, B -&gt; rc); Node *ret = alloc_node(A -&gt; sumv + B -&gt; sumv, lc, rc); return ret;&#125;int kth(Node *o, int L, int R, int k) &#123; if(o -&gt; sumv &lt; k) &#123; return 0; &#125; if(L == R) &#123; return L; &#125; else &#123; int M = (L + R) / 2; if(k &lt;= o -&gt; rc -&gt; sumv) &#123; return kth(o -&gt; rc, M + 1, R, k); &#125; else &#123; return kth(o -&gt; lc, L, M, k - o -&gt; rc -&gt; sumv); &#125; &#125;&#125;int p[maxn];void init_set() &#123; for(int i = 1; i &lt;= 2 * n; i ++) &#123; p[i] = i; &#125;&#125;int get_fa(int x) &#123; if(p[x] == x) &#123; return x; &#125; else &#123; return (p[x] = get_fa(p[x])); &#125;&#125;void merge_set(int x, int y) &#123; x = get_fa(x), y = get_fa(y); p[x] = y;&#125;bool is_same(int x, int y) &#123; return (get_fa(x) == get_fa(y));&#125;int h[maxn], h2[maxn]; int lsiz;void desc() &#123; std::copy(h + 1, h + 1 + n, h2 + 1); std::sort(h2 + 1, h2 + 1 + n); lsiz = std::unique(h2 + 1, h2 + 1 + n) - h2 - 1; for(int i = 1; i &lt;= n; i ++) &#123; h[i] = std::lower_bound(h2 + 1, h2 + 1 + lsiz, h[i]) - h2; &#125;&#125;int lim[maxn];int anc[maxn][19]; int cnt;Node *T[maxn];void build_tree() &#123; memset(anc, -1, sizeof(anc)); init_set(); init_tree(); desc(); for(int i = 1; i &lt;= n; i ++) &#123; T[i] = gen_chain(1, lsiz, h[i], 1); &#125; std::sort(E + 1, E + 1 + m); cnt = n; for(int i = 1; i &lt;= m; i ++) &#123; int u = E[i].u, v = E[i].v, l = E[i].d; if(is_same(u, v)) continue; u = get_fa(u); v = get_fa(v); cnt ++; lim[cnt] = l; T[cnt] = merge(T[u], T[v]); anc[u][0] = anc[v][0] = cnt; merge_set(u, cnt); merge_set(v, cnt); &#125; for(int j = 1; (1 &lt;&lt; j) &lt; cnt; j ++) &#123; for(int i = 1; i &lt;= cnt; i ++) &#123; int a = anc[i][j - 1]; if(a != -1) anc[i][j] = anc[a][j - 1]; &#125; &#125;&#125;int get_up(int x, int l) &#123; for(int j = 18; j &gt;= 0; j --) &#123; int a = anc[x][j]; if(a != -1 &amp;&amp; lim[a] &lt;= l) &#123; x = a; &#125; &#125; return x;&#125;int main() &#123; int q; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf("%d", &amp;h[i]); for(int i = 1; i &lt;= m; i ++) &#123; scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].d); &#125; build_tree(); int lastans = 0; h2[0] = -1; while(q --) &#123; int v, x, k; scanf("%d%d%d", &amp;v, &amp;x, &amp;k); if(lastans != -1) &#123; v ^= lastans; x ^= lastans; k ^= lastans; &#125; v = get_up(v, x); printf("%d\n", lastans = h2[kth(T[v], 1, lsiz, k)]);#ifdef LOCAL lastans = 0;#endif &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>ONTAK</tag>
        <tag>Kruskal重构树</tag>
        <tag>权值线段树</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2015」概率论]]></title>
    <url>%2F2018%2F07%2F17%2Floj2105%2F</url>
    <content type="text"><![CDATA[通过OEIS等传统艺能易知答案为\(\frac{n(n + 1)}{2(2n - 1)}\)。然后下面说一下怎么证明…… 令虑\(n\)个点的二叉树的方案数为\(H_n\)（其实很显然就是卡塔兰数列），令\(n\)个点的所有二叉树的叶子数的和为\(F_n\)。 考虑推导\(H_n\)的生成函数。我们知道（下面只考虑\(n &gt; 0\)，我们钦定\(H_0 = 1\)）： \[ H_n = \sum_{i = 0}^{n - 1} H_i H_{n - i - 1} \] 所以说对于\(H\)的生成函数，我们可以列方程： \[ H(x) = xH^2(x) + 1 \] 解得： \[ H(x) = \frac{1 \pm \sqrt{1 - 4x}}{2x} \] 通过收敛性可以得知（具体地说……如果取得是加号，那么\(H(x)\)在0处不收敛，与\(H(x)\)的零次项系数的取值有限的事实明显背道相驰），应取\(H(x) = \frac{1 - \sqrt{1 - 4x}}{2x}\)。 由于\(H\)就是卡塔兰数列，所以有\(H_n = \frac{1}{n + 1}\binom{2n}{n}\)。 然后对于\(F\)，我们考虑左右儿子分别的贡献，就可以列式得（这里考虑\(n &gt; 1\)的情况，\(F_1=1\)）： \[ F_n = 2\sum_{i = 1}^{n - 1} F_i H_{n - i - 1} \] 所以可以列出方程： \[ F(x) = 2xF(x)H(x) + x \] 然后解得： \[ F(x) = \frac{x}{\sqrt{1 - 4x}} \] 下面那个开根，看起来很不好弄。我们尝试用广义二项式定理展开它，就可以得到： \[ F(x) = \sum_{i = 1}^{+\infty} \binom{-0.5}{i - 1}(-4)^{i - 1} x^i \] 这里牵扯到了任意实数的组合数……定义可以参考维基（具体是二项式定理那篇）。然后我们去考虑\(F_n\)： \[ \begin{aligned} F_n &amp;= \frac{(-0.5)^{\underline{n - 1}}(-4)^{n - 1}}{(n - 1)!}\\ &amp;=\frac{1}{(n - 1)!}\prod_{i = 0}^{n - 2} (-0.5 - i)\cdot (-4)\\ &amp;=\frac{2^{n - 1}}{(n - 1)!}\prod_{i = 0}^{n - 2} (1 + 2i)\\ &amp;=\frac{2^{n - 1}}{(n - 1)!}\cdot\frac{(2n - 2)!}{2^{n - 1}(n - 1)!}\\ &amp;=\frac{(2n - 2)!}{(n - 1)!(n - 1)!}\\ &amp;=\binom{2n - 2}{n - 1} \end{aligned} \] 最后的答案是一个\(\frac{F_n}{H_n}\)，不妨推一下： \[ \begin{aligned} \frac{F_n}{H_n} &amp;= \frac{(n + 1)\binom{2n - 2}{n - 1}}{\binom{2n}{n}}\\ &amp;=\frac{(n + 1)(2n - 2)!n!n!}{(n-1)!(n-1)!(2n)!}\\ &amp;=\frac{(n + 1)n^2}{2n(2n - 1)}\\ &amp;=\frac{(n + 1)n}{2(2n - 1)} \end{aligned} \] 终于搞出来了…… 代码不用贴了吧……（逃]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>TJOI</tag>
        <tag>广义二项式定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min_25筛学习笔记]]></title>
    <url>%2F2018%2F07%2F14%2FMIN-25-sieve%2F</url>
    <content type="text"><![CDATA[一直想学洲阁筛吧……（这就是我学Min_25筛的理由？） 然后今天终于能yy出来洲阁筛的复杂度证明了……（然后不想写（逃 然后发现了一种更优越的求积性函数前缀和的方法，叫做Min_25筛的……（虽然算是烂大街了？） Min_25筛 假设现在有一个积性函数\(f\)，我们知道他在质数的幂\(p^c\)上的表现\(f(p^c)\)，然后要去求它的前缀和。 Min_25筛有个重要的要求就是……\(f(p)\)（\(p\)为质数）事一个低次多项式或者一个方便求前缀和的东西。下面就谈谈为什么…… 我们先考虑对于所有状态\(\lfloor\frac{n}{x}\rfloor\)，求出范围内所有质数的答案。 看起来蛮棘手的……但我们考虑模仿洲阁筛，定义一个状态\(g(i, x)\)，表示\(x\)范围内事质数或者和前\(i\)个质数都互质的数的答案之和。如果说\(p_i\)达到了\(\lfloor\sqrt{n}\rfloor\)，那么显然\(g(i, x)\)就是\(x\)范围内所有质数的答案了（\(p_i\)表示第\(i\)个质数，下同）。 那么考虑转移（接下来出现的\(f(p_i)\)是指质数的答案多项式中的某一项，因为答案多项式要分开考虑）……对所有\(x\geq p_i^2\)，使用\(g(i, x) = g(i - 1, x) - f(p_i)(g(i - 1,\lfloor\frac{x}{p_i}\rfloor) - g(i - 1, p_i - 1))\)转移（之所以后面又补了一个东西是因为要把多减去的含小于\(p_i\)的质数的合数补回来）；至于\(x &lt; p_i^2\)，我们会发现答案以后就不会变了，因为答案全部都是一堆质数的答案的和（其中不大于\(p_i\)的一定不是合数，否则必定有小于等于\(p_i\)的质因子；倘使大于\(p_i\)的话，没有小于等于\(p_i\)的质因子也只能有且仅有一个大于\(p_i\)的质因子，当然就是质数了）。 这一步操作和洲阁筛几乎如出一辙，复杂度证明也完全一致（复杂度为\(O(\frac{n^{\frac{3}{4}}}{\ln n})\)）。 但是光考虑质数的答案没完惹……再定义状态\(f(i, x)\)表示\(x\)范围内和小于\(p_i\)的质数都互质的数的答案，最终答案显然就是\(f(1) + f(1, n)\)。那么考虑一个很暴力的策略： 先把质数的答案都算进来（之前预处理了），然后考虑合数的答案。考虑枚举所有不小于\(p_i\)的质数\(p\)（假设是第\(j\)个质数），如果说\(p^2 &gt; x\)了那么就没法往下转移了（因为这样用上\(p\)就没法构造合数了），break出来就行了；反之则枚举\(p\)在数中所占的正指数\(e\)，对于所有\(p^{e + 1}\leq x\)，对答案做\(f(j + 1, \lfloor\frac{x}{p^e}\rfloor)f(p^e) + f(p^{e + 1})\)的贡献（其实就是枚举是否选够了\(e\)个\(p\)，然后考虑只用\(p\)的若干次方的情况）。 这个方法看起来极其暴力（甚至也没记忆化），但是复杂度很玄学（也很优秀）……可以参考朱老大的集训队论文。 例题：SPOJ DIVCNT3 这个题显然有\(f(p^c) = 3c + 1\)，然后根据上面说的搞就行了…… 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;const int maxn = 400005;using ll = long long;int prm[maxn]; ll A[maxn], B[maxn];ll sqr(ll x) &#123; ll ret = 1; while((ret + 1LL) * (ret + 1LL) &lt;= x) ret ++; return ret;&#125;ll n, S;int cnt;void process() &#123; S = sqr(n); cnt = 0;#ifdef LOCAL printf("S : %lld\n", S);#endif for(int i = 1; i &lt;= S; i ++) &#123; A[i] = i; &#125; for(int i = 1; i &lt;= S; i ++) &#123; B[i] = n / (ll(i)); &#125; for(int i = 2; i &lt;= S; i ++) &#123; if(A[i] == A[i - 1]) continue; ll v = A[i - 1], lim = (ll(i)) * (ll(i)); for(int j = 1; j &lt;= (S / i); j ++) &#123; B[j] -= B[j * i] - v; &#125; for(int j = S / i + 1; j &lt;= S; j ++) &#123; ll th = n / (ll(j)); if(th &lt; lim) break; B[j] -= A[th / (ll(i))] - v; &#125; for(int j = S; (ll)j &gt;= lim; j --) &#123; A[j] -= A[j / (ll(i))] - v; &#125; prm[++ cnt] = i; &#125; prm[++ cnt] = S + 1LL;&#125;inline ll query(ll x) &#123; if(x &lt;= S) &#123; return A[x]; &#125; else &#123; return B[n / x]; &#125;&#125;ll calc(ll m, int x) &#123; if(m &lt; (ll)prm[x]) return 0; ll ret = 4LL * (query(m) - query(prm[x] - 1)); for(int i = x; i &lt;= cnt; i ++) &#123; ll mul = prm[i]; if(mul * (ll(prm[i])) &gt; m) break; for(int j = 1; ; j ++) &#123; if(mul * (ll(prm[i])) &gt; m) break; ret += calc(m / mul, i + 1) * (ll(3 * j + 1)) + (ll(3 * j + 4)); mul *= (ll(prm[i])); &#125; &#125; return ret;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T --) &#123; scanf("%lld", &amp;n); process(); printf("%lld\n", calc(n, 1) + 1LL); &#125; return 0;&#125;]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Min_25筛</tag>
        <tag>洲阁筛</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4261」建设游乐场]]></title>
    <url>%2F2018%2F07%2F11%2FBZOJ4261%2F</url>
    <content type="text"><![CDATA[Description 给定一个\(n\times m\)网格图，其中有一些点是障碍，有一些点是平原。 现在要求你用若干无重边无自环的不相交简单环覆盖所有平原。有一些点\((i, j)\)如果满足经过的两条边一条是横着的一套是竖着的那么就会获得\(V_{i, j}\)的收益。 求是否有解，如果有解的话输出最大收益。 \(n\le 150\)，\(m\le 30\)，\(0\le V_{i, j}\le 100\)。 Solution 算是坑了很久的传统艺能题，，， 首先先来一步传统艺能：假设所有收益都能获得，然后问题转化成使笋丝尽可能小，也就变成了如果有一个地方是直的话就会有笋丝。 考虑黑白染色，我们钦点只从黑点往白点连边，这样的话每个黑点要向两个不同的白点（不能走到障碍上）连边。我们要希望所有点都弯着走，我们大可以把所有点全部拆成两个点，一个表示横着走一个表示竖着走，分别向源/汇连容量为1的边，同时他们再往相邻的横着/竖着相邻的点连容量为1的边。 但问题是有些时候有些点肯定只能直着走。那可以用“弯直转换”来表示，具体方法就是把一个点拆出来的横竖点互连容量为1费用为\(V_{i, j}\)的边。 最后关于是否有解的判定……最后的流量就是原网格图中用了的边的数量，对于每个环的边数都等于点数，因此总边数要等于总点数，因此最后的流量要等于平地的总数量才算有解。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int maxn = (150 * 30) * 2 + 5;struct Edge &#123; int u, v, cap, flow, cost;&#125;;std::vector&lt;int&gt; G[maxn];std::vector&lt;Edge&gt; E;inline void add_edge(int u, int v, int cap, int cost) &#123; E.push_back((Edge)&#123;u, v, cap, 0, cost&#125;); E.push_back((Edge)&#123;v, u, 0, 0, -cost&#125;); int m = E.size(); G[u].push_back(m - 2); G[v].push_back(m - 1);&#125;int a[maxn], d[maxn], p[maxn];bool inq[maxn];int num;const int INF = 0x3f3f3f3f;inline bool spfa(int s, int t, int &amp;flow, int &amp;cost) &#123; std::fill(a, a + num + 1, 0); std::fill(d, d + num + 1, INF); std::fill(p, p + num + 1, 0); std::fill(inq, inq + num + 1, false); std::queue&lt;int&gt; Q; Q.push(s); d[s] = 0; a[s] = INF; inq[s] = true; while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); inq[u] = false; for(int i = 0; i &lt; G[u].size(); i ++) &#123; Edge &amp;e = E[G[u][i]]; int v = e.v; if(e.cap &gt; e.flow &amp;&amp; d[u] + e.cost &lt; d[v]) &#123; d[v] = d[u] + e.cost; p[v] = G[u][i]; a[v] = std::min(a[u], e.cap - e.flow); if(!inq[v]) Q.push(v), inq[v] = true; &#125; &#125; &#125; if(d[t] &gt;= INF) return false; flow += a[t]; cost += d[t] * a[t];#ifdef LOCAL printf("flow delta : %d\n", a[t]); printf("cost delta : %d\n", d[t] * a[t]);#endif int u = t; while(u != s) &#123; Edge &amp;e = E[p[u]]; e.flow += a[t]; E[p[u] ^ 1].flow -= a[t]; u = e.u; &#125; return true;&#125;inline void MCMF(int s, int t, int &amp;flow, int &amp;cost) &#123; while(spfa(s, t, flow, cost));&#125;int n, m;inline int get_p(int i, int j, int t) &#123; int ret = (i - 1) * m + j; ret = ret * 2 - 1 + t; return ret;&#125;int A[155][35], V[155][35];int main() &#123; scanf("%d%d", &amp;n, &amp;m); int s = 0, t = n * m * 2 + 1; num = t; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; scanf("%d", &amp;A[i][j]); &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; scanf("%d", &amp;V[i][j]); if(!A[i][j]) ans += V[i][j]; &#125; &#125; int cnt = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; if(A[i][j]) continue; cnt ++; int p0 = get_p(i, j, 0), p1 = get_p(i, j, 1); add_edge(p0, p1, 1, V[i][j]); add_edge(p1, p0, 1, V[i][j]); if((i + j) &amp; 1) &#123; add_edge(p0, t, 1, 0); add_edge(p1, t, 1, 0); &#125; else &#123; add_edge(s, p0, 1, 0); add_edge(s, p1, 1, 0); if(i &gt; 1 &amp;&amp; !A[i - 1][j]) &#123; add_edge(p0, get_p(i - 1, j, 0), 1, 0); &#125; if(i &lt; n &amp;&amp; !A[i + 1][j]) &#123; add_edge(p0, get_p(i + 1, j, 0), 1, 0); &#125; if(j &gt; 1 &amp;&amp; !A[i][j - 1]) &#123; add_edge(p1, get_p(i, j - 1, 1), 1, 0); &#125; if(j &lt; m &amp;&amp; !A[i][j + 1]) &#123; add_edge(p1, get_p(i, j + 1, 1), 1, 0); &#125; &#125; &#125; &#125;#ifdef LOCAL printf("tot : %d\n", ans);#endif int flow = 0, cost = 0; MCMF(s, t, flow, cost); if(flow &lt; cnt) &#123; puts("-1"); &#125; else &#123; printf("%d\n", ans - cost); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝尔级数在积性函数毒瘤题中的应用]]></title>
    <url>%2F2018%2F07%2F11%2Fbell-series%2F</url>
    <content type="text"><![CDATA[嗯，OC！ 一直以来，数论生成函数在积性函数毒瘤题中的应用都不是很多…… 数论函数的生成函数大概有三种：狄利克雷级数（也叫数论生成函数）、贝尔级数、Lambert级数。Lambert级数不了解，狄利克雷级数太复杂（需要一些复分析的水平，恰好我没有……），能派上用场的也就只有贝尔级数力，，， 下文主要介绍贝尔级数的基本概念，在狄利克雷卷积中的应用，以及在积性函数求和（对我书得就事杜教筛）中的一些微小的应用…… 贝尔级数的概念 贝尔级数的定义 贝尔级数是一种形式幂级数。对于给定的数论函数\(f\)和质数\(p\)，我们定义\(f\)模\(p\)的贝尔级数为： \[ f_p(x)=\sum_{i = 0}^{+\infty} f(p^i)x^i \] 贝尔级数的基本性质 唯一定理 对于两个积性函数\(f\)和\(g\)，如果对于任意质数\(p\)都有\(f\)和\(g\)模\(p\)的贝尔级数相同，那两者相同。 这个定理我局的还事挺好理解的……两个积性函数在任何质数的幂的表现都相同，那么两者也相同。 因为一般的数论函数没有这么优秀的性质……所以下面提到的贝尔级数的应用基本上都针对积性函数…… 狄利克雷卷积 对任意两个数论函数\(f\)和\(g\)，有\((f\ast g)_p(x) = f_p(x)\cdot g_p(x)\)。 这是贝尔级数最有用的性质了……（没这个性质用它干啥？） 完全积性函数的贝尔级数 对于一个完全积性函数\(f\)，有\(f_p(x)=\frac{1}{1 - f(p)x}\)。 这个也不难理解，用的就是等比数列求和公式。不过好在事形式幂级数，并不需要考虑收敛的问题…… 常用积性函数函数的贝尔级数 关于狄利克雷卷积的单位元\(\epsilon\)（\(\epsilon(x) = [x=1]\)），不必自说当然是\(1\)。 首先对于\(f(x) = x^k(k\in N^0)\)这种东西，根据完全积性函数的贝尔级数公式可知有\(f_p(x)=\frac{1}{1 - p^kx}\)。 莫比乌斯函数比较有意思。显然\(\mu(1) = 1\)，\(\mu(p) = -1\)，但是\(\mu(p^k)=0(k\ge 2)\)。所以说其贝尔级数就是\(1-x\)。类似我们可以推导得\(\mu^2\)的贝尔级数为\(1+x\)。 欧拉函数直接推有些棘手……但注意到我们知道\(\varphi\ast 1 = \mathrm{id}\)，反演一下可以得知\(\mathrm{id}\ast\mu =\varphi\)，由此可得\(\varphi_p(x)=\frac{1 - x}{1 - px}\)。 接下来介绍一个非常好玩的函数：刘维尔函数。在此之前先定义\(\Omega(n)\)表示\(n\)的可重复质因子数（因此\(\Omega(4) = 2\)），那么刘维尔函数\(\lambda(x) = (-1)^{\Omega(x)}\)，这个函数很显然是完全积性函数，故\(\lambda_p(x)=\frac{1}{1 + x}\)。这个函数有些时候是肥肠有用的。 然后考虑约数好兄弟\(\sigma_k\)。很显然\(\sigma_k = \mathrm{id}^k\ast 1\)，因此可以推出\((\sigma_k)_p(x)=\frac{1}{1 - p^kx}\cdot\frac{1}{1 - x} = \frac{1}{1 - (1 + p^k)x + p^kx^2}\)。 至此常见积性函数已经推完力，，， 贝尔级数在狄利克雷卷积中的应用 这个还算是很显然吧…… 举个例子，让你证\((\mathrm{id}\cdot\mu)\ast\mathrm{id} = \epsilon\)。 这个东西用传统的计数解方法当然可行，但是多麻烦事有目共睹的（甚至于有些东西被我们的当结论记了）。用贝尔级数的话这个等式不就是\((1 - px)\cdot\frac{1}{1 - px} = 1\)嘛，非常简单。 还有一些比较复杂的例子，大家可以自行寻找。 贝尔级数在杜教筛中的应用 这个东西算是最大应用了吧…… 应用主要分为两部分：你知道\(f\)本身是啥，但是不知道找啥去卷比较好；你不知道\(f\)本身是啥（你只知道它在质数的幂上表现），但你还是要杜教筛。 利用贝尔级数构造合适的狄利克雷卷积 给一道题吧：求\(\mu^2\ast (\mathrm{id}\cdot\mu)\)这个东西的前缀和，\(n\le 10^{11}\)。 如果你不知道贝尔级数，你可能需要靠背上面提到的那个用传统方法很难证的结论来做这个题…… 但如果说你知道贝尔级数的话，你发现原函数贝尔级数为\((1 + x)(1 - px)\)，然后我们想肯定要消掉一部分或者全部式子。我们考虑卷上一个\(\mathrm{id}\)，弄完了之后的贝尔级数为\(1 + x\)，也就是\(\mu^2\)。 \(\mathrm{id}\)的前缀和自然好说，但是\(\mu^2\)的前缀和咋整？ 其实\(\mu^2\)就是判断它是否没有完全平方因子。因此我们直接枚举那个因子的平方根就好了，但是这样会重复，因此考虑用\(\mu\)容斥一下，得到： \[ \sum_{i = 1}^n\mu^2(i)=\sum_{i = 1}^{\lfloor\sqrt{n}\rfloor}\mu(i)\lfloor\frac{n}{i^2}\rfloor \] 因此\(\mu^2\)的前缀和是可以根号复杂度来求的，不会影响杜教筛总的转移复杂度。因此总复杂度为\(O(n^{\frac{2}{3}})\)。 在不知道函数本身是啥的时候杜教筛 还是给一道题： 有一个积性函数\(f(x)\)，你不知道它本身是啥，但是你知道他满足以下性质： \(f(1) = 1\)。 对于质数\(p\)和正整数\(a\)，有\(f(p^a) = p^a + (-1)^a\)。 求这玩意的前缀和，\(n\le 10^{11}\)。 其实你通过OEIS可以知道这个函数本身是啥（逃），但考虑到那样你也很难用常规手段杜教筛所以还事没啥用…… 首先考虑去构造这个玩意的贝尔级数。它看起来很像事\(\mathrm{id}\)和\(\lambda\)的贝尔级数加一下，但是考虑到\(f(1) = 1\)因此还要再减个1。最后得到： \[ f_p(x)=\frac{1}{1 - px} + \frac{1}{1 + x} - 1 \] 我们想要卷上一个\(g\)，那些分母看起来很不顺眼，干脆把他们都消掉了吧！因此我们规定\(g_p(x) = (1 - px)(1 + x)\)（因此我们得知\(g = (\mathrm{id}\cdot\mu)\ast\mu^2\)）。卷出来之后发现： \[ (f\ast g)_p(x) = 1 + x + 1 - px - 1 - x + px + px^2 = 1 + px^2 \] 然后我们弄了一大半顿我们还是不知道\(f\ast g\)具体是啥……但是我们观察到一点非常重要的性质：若\((f\ast g)(x)\ne 0\)，那么\(x\)起码也得是完全平方数，并且\(\mu^2(\sqrt{x}) = 1\)，并且对答案的贡献为\(\sqrt{x}\)！ 这下\(f\ast g\)虽然还不知道是啥，但是起码它前缀和好求了！我们对于对答案可能有贡献的\(x\)枚举其算术平方根即可，写出来就是： \[ \sum_{i = 1}^n(f\ast g)(i) = \sum_{i = 1}^{\lfloor\sqrt{n}\rfloor}\mu^2(i)i \] 这样的话求\(f\ast g\)的前缀和的复杂度就已经降到\(O(\sqrt{n})\)了，更进一步我们发现这个式子的答案只和\(\lfloor\sqrt{n}\rfloor\)有关，所以我们用\(O(\sqrt{n})\)的时间预处理所有这种和之后\(O(1)\)查询就好了。 剩下唯一的硬骨头就是\(g\)的前缀和，这个上一小节已经讲了。 虽说这玩意蛮有用的……但是无法阻止杜教筛过气，常熟优秀还好想的MIN_25筛已经要dssq力（悲）]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>狄利克雷卷积</tag>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
        <tag>贝尔级数</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些测试]]></title>
    <url>%2F2018%2F07%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[一级标题 二级标题 三级标题 四级标题 五级标题 行内公式：\(\int_{-\infty}^{+\infty}e^{x^2}\mathrm{d}x\)。 行间公式： \[ \int u\mathrm{d}v = uv - \int v\mathrm{d}u \] 123456// C++ code#include &lt;cstdio&gt;int main() &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); printf("%d\n", a + b); return 0;&#125; 嗯，OC！]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
