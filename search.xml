<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>「LibreOJ 2105」「TJOI 2015」概率论</title>
      <link href="/2018/07/17/loj2105/"/>
      <url>/2018/07/17/loj2105/</url>
      <content type="html"><![CDATA[<p><del>通过OEIS等传统艺能</del>易知答案为$\frac{n(n + 1)}{2(2n - 1)}$。然后下面说一下怎么证明……</p><a id="more"></a><p>令虑$n$个点的二叉树的方案数为$H_n$（其实很显然就是卡塔兰数列），令$n$个点的所有二叉树的叶子数的和为$F_n$。</p><p>考虑推导$H_n$的生成函数。我们知道（下面只考虑$n &gt; 0$，我们钦定$H_0 = 1$）：<br>$$<br>H_n = \sum_{i = 0}^{n - 1} H_i H_{n - i - 1}<br>$$<br>所以说对于$H$的生成函数，我们可以列方程：<br>$$<br>H(x) = xH^2(x) + 1<br>$$<br>解得：<br>$$<br>H(x) = \frac{1 \pm \sqrt{1 - 4x}}{2x}<br>$$<br>通过收敛性可以得知（具体地说……如果取得是加号，那么$H(x)$在0处不收敛，与$H(x)$的零次项系数的取值有限的事实明显背道相驰），应取$H(x) = \frac{1 - \sqrt{1 - 4x}}{2x}$。</p><p>由于$H$就是卡塔兰数列，所以有$H_n = \frac{1}{n + 1}\binom{2n}{n}$。</p><p>然后对于$F$，我们考虑左右儿子分别的贡献，就可以列式得（这里考虑$n &gt; 1$的情况，$F_1=1$）：<br>$$<br>F_n = 2\sum_{i = 1}^{n - 1} F_i H_{n - i - 1}<br>$$<br>所以可以列出方程：<br>$$<br>F(x) = 2xF(x)H(x) + x<br>$$<br>然后解得：<br>$$<br>F(x) = \frac{x}{\sqrt{1 - 4x}}<br>$$<br>下面那个开根，看起来很不好弄。我们尝试用广义二项式定理展开它，就可以得到：<br>$$<br>F(x) = \sum_{i = 1}^{+\infin} \binom{-0.5}{i - 1}(-4)^{i - 1} x^i<br>$$<br>这里牵扯到了任意实数的组合数……定义可以参考维基（具体是二项式定理那篇）。然后我们去考虑$F_n$：<br>$$<br>\begin{aligned}<br>F_n &amp;= \frac{(-0.5)^{\underline{n - 1}}(-4)^{n - 1}}{(n - 1)!}\<br>&amp;=\frac{1}{(n - 1)!}\prod_{i = 0}^{n - 2} (-0.5 - i)\cdot (-4)\<br>&amp;=\frac{2^{n - 1}}{(n - 1)!}\prod_{i = 0}^{n - 2} (1 + 2i)\<br>&amp;=\frac{2^{n - 1}}{(n - 1)!}\cdot\frac{(2n - 2)!}{2^{n - 1}(n - 1)!}\<br>&amp;=\frac{(2n - 2)!}{(n - 1)!(n - 1)!}\<br>&amp;=\binom{2n - 2}{n - 1}<br>\end{aligned}<br>$$<br>最后的答案是一个$\frac{F_n}{H_n}$，不妨推一下：<br>$$<br>\begin{aligned}<br>\frac{F_n}{H_n} &amp;= \frac{(n + 1)\binom{2n - 2}{n - 1}}{\binom{2n}{n}}\<br>&amp;=\frac{(n + 1)(2n - 2)!n!n!}{(n-1)!(n-1)!(2n)!}\<br>&amp;=\frac{(n + 1)n^2}{2n(2n - 1)}\<br>&amp;=\frac{(n + 1)n}{2(2n - 1)}<br>\end{aligned}<br>$$<br>终于搞出来了……</p><p>代码不用贴了吧……（逃</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LibreOJ </tag>
            
            <tag> TJOI </tag>
            
            <tag> 生成函数 </tag>
            
            <tag> 广义二项式定理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Min_25筛学习笔记</title>
      <link href="/2018/07/14/MIN-25-sieve/"/>
      <url>/2018/07/14/MIN-25-sieve/</url>
      <content type="html"><![CDATA[<p>一直想学洲阁筛吧……（<del>这就是我学Min_25筛的理由？</del>）</p><p>然后今天终于能yy出来洲阁筛的复杂度证明了……（然后不想写（逃</p><p>然后发现了一种更优越的求积性函数前缀和的方法，叫做Min_25筛的……（虽然算是烂大街了？）</p><a id="more"></a><h2 id="Min-25筛"><a href="#Min-25筛" class="headerlink" title="Min_25筛"></a>Min_25筛</h2><p>假设现在有一个积性函数$f$，我们知道他在质数的幂$p^c$上的表现$f(p^c)$，然后要去求它的前缀和。</p><p>Min_25筛有个重要的要求就是……$f(p)$（$p$为质数）事一个低次多项式或者一个方便求前缀和的东西。下面就谈谈为什么……</p><p>我们先考虑对于所有状态$\lfloor\frac{n}{x}\rfloor$，求出范围内所有质数的答案。</p><p>看起来蛮棘手的……但我们考虑模仿洲阁筛，定义一个状态$g(i, x)$，表示$x$范围内事质数或者和前$i$个质数都互质的数的答案之和。如果说$p_i$达到了$\lfloor\sqrt{n}\rfloor$，那么显然$g(i, x)$就是$x$范围内所有质数的答案了（$p_i$表示第$i$个质数，下同）。</p><p>那么考虑转移（接下来出现的$f(p_i)$是指质数的答案多项式中的某一项，因为答案多项式要分开考虑）……对所有$x\geq p_i^2$，使用$g(i, x) = g(i - 1, x) - f(p_i)(g(i - 1,\lfloor\frac{x}{p_i}\rfloor) - g(i - 1, p_i - 1))$转移（之所以后面又补了一个东西是因为要把多减去的小于$p_i$的质数补回来）；至于$x &lt; p_i^2$，我们会发现答案以后就不会变了，因为答案全部都是一堆质数的答案的和（其中不大于$p_i$的一定不是合数，否则必定有小于等于$p_i$的质因子；倘使大于$p_i$的话，没有小于等于$p_i$的质因子也只能有且仅有一个大于$p_i$的质因子，当然就是质数了）。</p><p>这一步操作和洲阁筛几乎如出一辙，复杂度证明也完全一致（复杂度为$O(\frac{n^{\frac{3}{4}}}{\ln n})$）。</p><p>但是光考虑质数的答案没完惹……再定义状态$f(i, x)$表示$x$范围内和小于$p_i$的质数都互质的数的答案，最终答案显然就是$f(1) + f(1, n)$。那么考虑一个很暴力的策略：</p><p>先把质数的答案都算进来（之前预处理了），然后考虑合数的答案。考虑枚举所有不小于$p_i$的质数$p$（假设是第$j$个质数），如果说$p^2 &gt; x$了那么就没法往下转移了（因为这样用上$p$就没法构造合数了），<code>break</code>出来就行了；反之则枚举$p$在数中所占的正指数$e$，对于所有$p^{e + 1}\leq x$，对答案做$f(j + 1, \lfloor\frac{x}{p^e}\rfloor)f(p^e) + f(p^{e + 1})$的贡献（其实就是枚举是否选够了$e$个$p$，然后考虑只用$p$的若干次方的情况）。</p><p>这个方法看起来极其暴力（甚至也没记忆化），但是复杂度很玄学（也很优秀）……可以参考朱老大的集训队论文。</p><h2 id="例题：SPOJ-DIVCNT3"><a href="#例题：SPOJ-DIVCNT3" class="headerlink" title="例题：SPOJ DIVCNT3"></a>例题：SPOJ DIVCNT3</h2><p>这个题显然有$f(p^c) = 3c + 1$，然后根据上面说的搞就行了……</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">400005</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">int</span> prm[maxn]; ll A[maxn], B[maxn];</span><br><span class="line"><span class="function">ll <span class="title">sqr</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  ll ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>((ret + <span class="number">1L</span>L) * (ret + <span class="number">1L</span>L) &lt;= x) ret ++;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, S;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  S = sqr(n); cnt = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"S : %lld\n"</span>, S);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; i ++) &#123;</span><br><span class="line">    A[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S; i ++) &#123;</span><br><span class="line">    B[i] = n / (ll(i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= S; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(A[i] == A[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    ll v = A[i - <span class="number">1</span>], lim = (ll(i)) * (ll(i));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (S / i); j ++) &#123;</span><br><span class="line">      B[j] -= B[j * i] - v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = S / i + <span class="number">1</span>; j &lt;= S; j ++) &#123;</span><br><span class="line">      ll th = n / (ll(j)); <span class="keyword">if</span>(th &lt; lim) <span class="keyword">break</span>;</span><br><span class="line">      B[j] -= A[th / (ll(i))] - v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = S; (ll)j &gt;= lim; j --) &#123;</span><br><span class="line">      A[j] -= A[j / (ll(i))] - v;</span><br><span class="line">    &#125;</span><br><span class="line">    prm[++ cnt] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  prm[++ cnt] = S + <span class="number">1L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= S) &#123;</span><br><span class="line">    <span class="keyword">return</span> A[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> B[n / x];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll m, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(m &lt; (ll)prm[x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  ll ret = <span class="number">4L</span>L * (query(m) - query(prm[x] - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= cnt; i ++) &#123;</span><br><span class="line">    ll mul = prm[i];</span><br><span class="line">    <span class="keyword">if</span>(mul * (ll(prm[i])) &gt; m) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; ; j ++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(mul * (ll(prm[i])) &gt; m) <span class="keyword">break</span>;</span><br><span class="line">      ret += calc(m / mul, i + <span class="number">1</span>) * (ll(<span class="number">3</span> * j + <span class="number">1</span>)) + (ll(<span class="number">3</span> * j + <span class="number">4</span>));</span><br><span class="line">      mul *= (ll(prm[i]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> T; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">  <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    process();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, calc(n, <span class="number">1</span>) + <span class="number">1L</span>L);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Min_25筛 </tag>
            
            <tag> 洲阁筛 </tag>
            
            <tag> SPOJ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「BZOJ 4261」建设游乐场</title>
      <link href="/2018/07/11/BZOJ4261/"/>
      <url>/2018/07/11/BZOJ4261/</url>
      <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一个$n\times m$网格图，其中有一些点是障碍，有一些点是平原。</p><p>现在要求你用若干无重边无自环的不相交简单环覆盖所有平原。有一些点$(i, j)$如果满足经过的两条边一条是横着的一套是竖着的那么就会获得$V_{i, j}$的收益。</p><p>求是否有解，如果有解的话输出最大收益。</p><p>$n\le 150$，$m\le 30$，$0\le V_{i, j}\le 100$。</p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>算是坑了很久的传统艺能题，，，</p><p>首先先来一步传统艺能：假设所有收益都能获得，然后问题转化成使笋丝尽可能小，也就变成了如果有一个地方是直的话就会有笋丝。</p><p>考虑黑白染色，我们钦点只从黑点往白点连边，这样的话每个黑点要向两个不同的白点（不能走到障碍上）连边。我们要希望所有点都弯着走，我们大可以把所有点全部拆成两个点，一个表示横着走一个表示竖着走，分别向源/汇连容量为1的边，同时他们再往相邻的横着/竖着相邻的点连容量为1的边。</p><p>但问题是有些时候有些点肯定只能直着走。那可以用“弯直转换”来表示，具体方法就是把一个点拆出来的横竖点互连容量为1费用为$V_{i, j}$的边。</p><p>最后关于是否有解的判定……最后的流量就是原网格图中用了的边的数量，对于每个环的边数都等于点数，因此总边数要等于总点数，因此最后的流量要等于平地的总数量才算有解。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (<span class="number">150</span> * <span class="number">30</span>) * <span class="number">2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, cap, flow, cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; E;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> cap, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">  E.push_back((Edge)&#123;u, v, cap, <span class="number">0</span>, cost&#125;);</span><br><span class="line">  E.push_back((Edge)&#123;v, u, <span class="number">0</span>, <span class="number">0</span>, -cost&#125;);</span><br><span class="line">  <span class="keyword">int</span> m = E.size();</span><br><span class="line">  G[u].push_back(m - <span class="number">2</span>); G[v].push_back(m - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], d[maxn], p[maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn];</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> &amp;flow, <span class="keyword">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::fill(a, a + num + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">std</span>::fill(d, d + num + <span class="number">1</span>, INF);</span><br><span class="line">  <span class="built_in">std</span>::fill(p, p + num + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">std</span>::fill(inq, inq + num + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q; Q.push(s);</span><br><span class="line">  d[s] = <span class="number">0</span>; a[s] = INF; inq[s] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = Q.front(); Q.pop(); inq[u] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); i ++) &#123;</span><br><span class="line">      Edge &amp;e = E[G[u][i]]; <span class="keyword">int</span> v = e.v;</span><br><span class="line">      <span class="keyword">if</span>(e.cap &gt; e.flow &amp;&amp; d[u] + e.cost &lt; d[v]) &#123;</span><br><span class="line">        d[v] = d[u] + e.cost; p[v] = G[u][i];</span><br><span class="line">        a[v] = <span class="built_in">std</span>::min(a[u], e.cap - e.flow);</span><br><span class="line">        <span class="keyword">if</span>(!inq[v]) Q.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(d[t] &gt;= INF) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  flow += a[t]; cost += d[t] * a[t];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"flow delta : %d\n"</span>, a[t]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"cost delta : %d\n"</span>, d[t] * a[t]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> u = t;</span><br><span class="line">  <span class="keyword">while</span>(u != s) &#123;</span><br><span class="line">    Edge &amp;e = E[p[u]];</span><br><span class="line">    e.flow += a[t]; E[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">    u = e.u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MCMF</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> &amp;flow, <span class="keyword">int</span> &amp;cost)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(spfa(s, t, flow, cost));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_p</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = (i - <span class="number">1</span>) * m + j;</span><br><span class="line">  ret = ret * <span class="number">2</span> - <span class="number">1</span> + t;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">155</span>][<span class="number">35</span>], V[<span class="number">155</span>][<span class="number">35</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>, t = n * m * <span class="number">2</span> + <span class="number">1</span>; num = t;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V[i][j]);</span><br><span class="line">      <span class="keyword">if</span>(!A[i][j]) ans += V[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(A[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">      cnt ++; <span class="keyword">int</span> p0 = get_p(i, j, <span class="number">0</span>), p1 = get_p(i, j, <span class="number">1</span>);</span><br><span class="line">      add_edge(p0, p1, <span class="number">1</span>, V[i][j]); add_edge(p1, p0, <span class="number">1</span>, V[i][j]);</span><br><span class="line">      <span class="keyword">if</span>((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        add_edge(p0, t, <span class="number">1</span>, <span class="number">0</span>); add_edge(p1, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        add_edge(s, p0, <span class="number">1</span>, <span class="number">0</span>); add_edge(s, p1, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; !A[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">          add_edge(p0, get_p(i - <span class="number">1</span>, j, <span class="number">0</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n &amp;&amp; !A[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">          add_edge(p0, get_p(i + <span class="number">1</span>, j, <span class="number">0</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">1</span> &amp;&amp; !A[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">          add_edge(p1, get_p(i, j - <span class="number">1</span>, <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; m &amp;&amp; !A[i][j + <span class="number">1</span>]) &#123;</span><br><span class="line">          add_edge(p1, get_p(i, j + <span class="number">1</span>, <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"tot : %d\n"</span>, ans);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> flow = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">  MCMF(s, t, flow, cost);</span><br><span class="line">  <span class="keyword">if</span>(flow &lt; cnt) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - cost);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BZOJ </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>贝尔级数在积性函数毒瘤题中的应用</title>
      <link href="/2018/07/11/bell-series/"/>
      <url>/2018/07/11/bell-series/</url>
      <content type="html"><![CDATA[<p>嗯，OC！</p><p>一直以来，数论生成函数在积性函数毒瘤题中的应用都不是很多……</p><p>数论函数的生成函数大概有三种：狄利克雷级数（也叫数论生成函数）、贝尔级数、Lambert级数。Lambert级数不了解，狄利克雷级数太复杂（需要一些复分析的水平，恰好我没有……），能派上用场的也就只有贝尔级数力，，，</p><p>下文主要介绍贝尔级数的基本概念，在狄利克雷卷积中的应用，以及在积性函数求和（对我书得就事杜教筛）中的一些微小的应用……</p><a id="more"></a><h2 id="贝尔级数的概念"><a href="#贝尔级数的概念" class="headerlink" title="贝尔级数的概念"></a>贝尔级数的概念</h2><h3 id="贝尔级数的定义"><a href="#贝尔级数的定义" class="headerlink" title="贝尔级数的定义"></a>贝尔级数的定义</h3><p>贝尔级数是一种形式幂级数。对于给定的数论函数$f$和质数$p$，我们定义$f$模$p$的贝尔级数为：<br>$$<br>f_p(x)=\sum_{i = 0}^{+\infty} f(p^i)x^i<br>$$</p><h3 id="贝尔级数的基本性质"><a href="#贝尔级数的基本性质" class="headerlink" title="贝尔级数的基本性质"></a>贝尔级数的基本性质</h3><h4 id="唯一定理"><a href="#唯一定理" class="headerlink" title="唯一定理"></a>唯一定理</h4><p>对于两个积性函数$f$和$g$，如果对于任意质数$p$都有$f$和$g$模$p$的贝尔级数相同，那两者相同。</p><p>这个定理我局的还事挺好理解的……两个积性函数在任何质数的幂的表现都相同，那么两者也相同。</p><p>因为一般的数论函数没有这么优秀的性质……所以下面提到的贝尔级数的应用基本上都针对积性函数……</p><h4 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h4><p>对任意两个数论函数$f$和$g$，有$(f\ast g)_p(x) = f_p(x)\cdot g_p(x)$。</p><p>这是贝尔级数最有用的性质了……（没这个性质用它干啥？）</p><h4 id="完全积性函数的贝尔级数"><a href="#完全积性函数的贝尔级数" class="headerlink" title="完全积性函数的贝尔级数"></a>完全积性函数的贝尔级数</h4><p>对于一个完全积性函数$f$，有$f_p(x)=\frac{1}{1 - f(p)x}$。</p><p>这个也不难理解，用的就是等比数列求和公式。不过好在事形式幂级数，并不需要考虑收敛的问题……</p><h3 id="常用积性函数函数的贝尔级数"><a href="#常用积性函数函数的贝尔级数" class="headerlink" title="常用积性函数函数的贝尔级数"></a>常用积性函数函数的贝尔级数</h3><p>关于狄利克雷卷积的单位元$\epsilon$（$\epsilon(x) = [x=1]$），不必自说当然是$1$。</p><p>首先对于$f(x) = x^k(k\in N^0)$这种东西，根据完全积性函数的贝尔级数公式可知有$f_p(x)=\frac{1}{1 - p^kx}$。</p><p>莫比乌斯函数比较有意思。显然$\mu(1) = 1$，$\mu(p) = -1$，但是$\mu(p^k)=0(k\ge 2)$。所以说其贝尔级数就是$1-x$。类似我们可以推导得$\mu^2$的贝尔级数为$1+x$。</p><p>欧拉函数直接推有些棘手……但注意到我们知道$\varphi\ast 1 = \mathrm{id}$，反演一下可以得知$\mathrm{id}\ast\mu =\varphi$，由此可得$\varphi_p(x)=\frac{1 - x}{1 - px}$。</p><p>接下来介绍一个非常好玩的函数：刘维尔函数。在此之前先定义$\Omega(n)$表示$n$的<strong>可重复</strong>质因子数（因此$\Omega(4) = 2$），那么刘维尔函数$\lambda(x) = (-1)^{\Omega(x)}$，这个函数很显然是完全积性函数，故$\lambda_p(x)=\frac{1}{1 + x}$。这个函数有些时候是肥肠有用的。</p><p>然后考虑约数好兄弟$\sigma_k$。很显然$\sigma_k = \mathrm{id}^k\ast 1$，因此可以推出$(\sigma_k)_p(x)=\frac{1}{1 - p^kx}\cdot\frac{1}{1 - x} = \frac{1}{1 - (1 + p^k)x + p^kx^2}$。</p><p>至此常见积性函数已经推完力，，，</p><h2 id="贝尔级数在狄利克雷卷积中的应用"><a href="#贝尔级数在狄利克雷卷积中的应用" class="headerlink" title="贝尔级数在狄利克雷卷积中的应用"></a>贝尔级数在狄利克雷卷积中的应用</h2><p>这个还算是很显然吧……</p><p>举个例子，让你证$(\mathrm{id}\cdot\mu)\ast\mathrm{id} = \epsilon$。</p><p>这个东西用传统的计数解方法当然可行，但是多麻烦事有目共睹的（甚至于有些东西被我们的当结论记了）。用贝尔级数的话这个等式不就是$(1 - px)\cdot\frac{1}{1 - px} = 1$嘛，非常简单。</p><p>还有一些比较复杂的例子，大家可以自行寻找。</p><h2 id="贝尔级数在杜教筛中的应用"><a href="#贝尔级数在杜教筛中的应用" class="headerlink" title="贝尔级数在杜教筛中的应用"></a>贝尔级数在杜教筛中的应用</h2><p>这个东西算是最大应用了吧……</p><p>应用主要分为两部分：你知道$f$本身是啥，但是不知道找啥去卷比较好；你不知道$f$本身是啥（你只知道它在质数的幂上表现），但你还是要杜教筛。</p><h3 id="利用贝尔级数构造合适的狄利克雷卷积"><a href="#利用贝尔级数构造合适的狄利克雷卷积" class="headerlink" title="利用贝尔级数构造合适的狄利克雷卷积"></a>利用贝尔级数构造合适的狄利克雷卷积</h3><p>给一道题吧：求$\mu^2\ast (\mathrm{id}\cdot\mu)$这个东西的前缀和，$n\le 10^{11}$。</p><p>如果你不知道贝尔级数，你可能需要靠背上面提到的那个用传统方法很难证的结论来做这个题……</p><p>但如果说你知道贝尔级数的话，你发现原函数贝尔级数为$(1 + x)(1 - px)$，然后我们想肯定要消掉一部分或者全部式子。我们考虑卷上一个$\mathrm{id}$，弄完了之后的贝尔级数为$1 + x$，也就是$\mu^2$。</p><p>$\mathrm{id}$的前缀和自然好说，但是$\mu^2$的前缀和咋整？</p><p>其实$\mu^2$就是判断它是否没有完全平方因子。因此我们直接枚举那个因子的平方根就好了，但是这样会重复，因此考虑用$\mu$容斥一下，得到：<br>$$<br>\sum_{i = 1}^n\mu^2(i)=\sum_{i = 1}^{\lfloor\sqrt{n}\rfloor}\mu(i)\lfloor\frac{n}{i^2}\rfloor<br>$$<br>因此$\mu^2$的前缀和是可以根号复杂度来求的，不会影响杜教筛总的转移复杂度。因此总复杂度为$O(n^{\frac{2}{3}})$。</p><h3 id="在不知道函数本身是啥的时候杜教筛"><a href="#在不知道函数本身是啥的时候杜教筛" class="headerlink" title="在不知道函数本身是啥的时候杜教筛"></a>在不知道函数本身是啥的时候杜教筛</h3><p>还是给一道题：</p><p>有一个积性函数$f(x)$，你不知道它本身是啥，但是你知道他满足以下性质：</p><ul><li>$f(1) = 1$。</li><li>对于质数$p$和正整数$a$，有$f(p^a) = p^a + (-1)^a$。</li></ul><p>求这玩意的前缀和，$n\le 10^{11}$。</p><p>其实你通过OEIS可以知道这个函数本身是啥（逃），但考虑到那样你也很难用常规手段杜教筛所以还事没啥用……</p><p>首先考虑去构造这个玩意的贝尔级数。它看起来很像事$\mathrm{id}$和$\lambda$的贝尔级数加一下，但是考虑到$f(1) = 1$因此还要再减个1。最后得到：<br>$$<br>f_p(x)=\frac{1}{1 - px} + \frac{1}{1 + x} - 1<br>$$<br>我们想要卷上一个$g$，那些分母看起来很不顺眼，干脆把他们都消掉了吧！因此我们规定$g_p(x) = (1 - px)(1 + x)$（因此我们得知$g = (\mathrm{id}\cdot\mu)\ast\mu^2$）。卷出来之后发现：<br>$$<br>(f\ast g)_p(x) = 1 + x + 1 - px - 1 - x + px + px^2 = 1 + px^2<br>$$<br>然后我们弄了一大半顿我们还是不知道$f\ast g$具体是啥……但是我们观察到一点非常重要的性质：若$(f\ast g)(x)\ne 0$，那么$x$起码也得是完全平方数，并且$\mu^2(\sqrt{x}) = 1$，并且对答案的贡献为$\sqrt{x}$！</p><p>这下$f\ast g$虽然还不知道是啥，但是起码它前缀和好求了！我们对于对答案可能有贡献的$x$枚举其算术平方根即可，写出来就是：<br>$$<br>\sum_{i = 1}^n(f\ast g)(i) = \sum_{i = 1}^{\lfloor\sqrt{n}\rfloor}\mu^2(i)i<br>$$<br>这样的话求$f\ast g$的前缀和的复杂度就已经降到$O(\sqrt{n})$了，更进一步我们发现这个式子的答案只和$\lfloor\sqrt{n}\rfloor$有关，所以我们用$O(\sqrt{n})$的时间预处理所有这种和之后$O(1)$查询就好了。</p><p>剩下唯一的硬骨头就是$g$的前缀和，这个上一小节已经讲了。</p><p><del>虽说这玩意蛮有用的……但是无法阻止杜教筛过气，常熟优秀还好想的MIN_25筛已经要dssq力（悲）</del></p>]]></content>
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
            <tag> 贝尔级数 </tag>
            
            <tag> 杜教筛 </tag>
            
            <tag> 狄利克雷卷积 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些测试</title>
      <link href="/2018/07/11/test/"/>
      <url>/2018/07/11/test/</url>
      <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p>行内公式：$\int_{-\infty}^{+\infty}e^{x^2}\mathrm{d}x$。</p><p>行间公式：<br>$$<br>\int u\mathrm{d}v = uv - \int v\mathrm{d}u<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，OC！</p>]]></content>
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
