<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「BZOJ 4261」建设游乐场]]></title>
    <url>%2F2018%2F07%2F11%2FBZOJ4261%2F</url>
    <content type="text"><![CDATA[Description给定一个$n\times m$网格图，其中有一些点是障碍，有一些点是平原。 现在要求你用若干无重边无自环的不相交简单环覆盖所有平原。有一些点$(i, j)$如果满足经过的两条边一条是横着的一套是竖着的那么就会获得$V_{i, j}$的收益。 求是否有解，如果有解的话输出最大收益。 $n\le 150$，$m\le 30$，$0\le V_{i, j}\le 100$。 Solution算是坑了很久的传统艺能题，，， 首先先来一步传统艺能：假设所有收益都能获得，然后问题转化成使笋丝尽可能小，也就变成了如果有一个地方是直的话就会有笋丝。 考虑黑板染色，我们钦点只从黑点往白点连边，这样的话每个黑点要向两个不同的白点（不能走到障碍上）连边。我们要希望所有点都弯着走，我们大可以把所有点全部拆成两个点，一个表示横着走一个表示竖着走，分别向源/汇连容量为1的边，同时他们再往相邻的横着/竖着相邻的点连容量为1的边。 但问题是有些时候有些点肯定只能直着走。那可以用“弯直转换”来表示，具体方法就是把一个点拆出来的横竖点互联容量为1费用为$V_{i, j}$的边。 最后关于是否有解的判定……最后的流量就是用了的边的数量，对于每个环的边数都等于点数，因此总边数要等于总点数，因此最后的流量要等于平地的总数量才算有解。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int maxn = (150 * 30) * 2 + 5;struct Edge &#123; int u, v, cap, flow, cost;&#125;;std::vector&lt;int&gt; G[maxn];std::vector&lt;Edge&gt; E;inline void add_edge(int u, int v, int cap, int cost) &#123; E.push_back((Edge)&#123;u, v, cap, 0, cost&#125;); E.push_back((Edge)&#123;v, u, 0, 0, -cost&#125;); int m = E.size(); G[u].push_back(m - 2); G[v].push_back(m - 1);&#125;int a[maxn], d[maxn], p[maxn];bool inq[maxn];int num;const int INF = 0x3f3f3f3f;inline bool spfa(int s, int t, int &amp;flow, int &amp;cost) &#123; std::fill(a, a + num + 1, 0); std::fill(d, d + num + 1, INF); std::fill(p, p + num + 1, 0); std::fill(inq, inq + num + 1, false); std::queue&lt;int&gt; Q; Q.push(s); d[s] = 0; a[s] = INF; inq[s] = true; while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); inq[u] = false; for(int i = 0; i &lt; G[u].size(); i ++) &#123; Edge &amp;e = E[G[u][i]]; int v = e.v; if(e.cap &gt; e.flow &amp;&amp; d[u] + e.cost &lt; d[v]) &#123; d[v] = d[u] + e.cost; p[v] = G[u][i]; a[v] = std::min(a[u], e.cap - e.flow); if(!inq[v]) Q.push(v), inq[v] = true; &#125; &#125; &#125; if(d[t] &gt;= INF) return false; flow += a[t]; cost += d[t] * a[t];#ifdef LOCAL printf("flow delta : %d\n", a[t]); printf("cost delta : %d\n", d[t] * a[t]);#endif int u = t; while(u != s) &#123; Edge &amp;e = E[p[u]]; e.flow += a[t]; E[p[u] ^ 1].flow -= a[t]; u = e.u; &#125; return true;&#125;inline void MCMF(int s, int t, int &amp;flow, int &amp;cost) &#123; while(spfa(s, t, flow, cost));&#125;int n, m;inline int get_p(int i, int j, int t) &#123; int ret = (i - 1) * m + j; ret = ret * 2 - 1 + t; return ret;&#125;int A[155][35], V[155][35];int main() &#123; scanf("%d%d", &amp;n, &amp;m); int s = 0, t = n * m * 2 + 1; num = t; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; scanf("%d", &amp;A[i][j]); &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; scanf("%d", &amp;V[i][j]); if(!A[i][j]) ans += V[i][j]; &#125; &#125; int cnt = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; if(A[i][j]) continue; cnt ++; int p0 = get_p(i, j, 0), p1 = get_p(i, j, 1); add_edge(p0, p1, 1, V[i][j]); add_edge(p1, p0, 1, V[i][j]); if((i + j) &amp; 1) &#123; add_edge(p0, t, 1, 0); add_edge(p1, t, 1, 0); &#125; else &#123; add_edge(s, p0, 1, 0); add_edge(s, p1, 1, 0); if(i &gt; 1 &amp;&amp; !A[i - 1][j]) &#123; add_edge(p0, get_p(i - 1, j, 0), 1, 0); &#125; if(i &lt; n &amp;&amp; !A[i + 1][j]) &#123; add_edge(p0, get_p(i + 1, j, 0), 1, 0); &#125; if(j &gt; 1 &amp;&amp; !A[i][j - 1]) &#123; add_edge(p1, get_p(i, j - 1, 1), 1, 0); &#125; if(j &lt; m &amp;&amp; !A[i][j + 1]) &#123; add_edge(p1, get_p(i, j + 1, 1), 1, 0); &#125; &#125; &#125; &#125;#ifdef LOCAL printf("tot : %d\n", ans);#endif int flow = 0, cost = 0; MCMF(s, t, flow, cost); if(flow &lt; cnt) &#123; puts("-1"); &#125; else &#123; printf("%d\n", ans - cost); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝尔级数在积性函数毒瘤题中的应用]]></title>
    <url>%2F2018%2F07%2F11%2Fbell-series%2F</url>
    <content type="text"><![CDATA[嗯，OC！ 一直以来，数论生成函数在积性函数毒瘤题中的应用都不是很多…… 数论函数的生成函数大概有三种：狄利克雷级数（也叫数论生成函数）、贝尔级数、Lambert级数。Lambert级数不了解，狄利克雷级数太复杂（需要一些复分析的水平，恰好我没有……），能派上用场的也就只有贝尔级数力，，， 下文主要介绍贝尔级数的基本概念，在狄利克雷卷积中的应用，以及在积性函数求和（对我书得就事杜教筛）中的一些微小的应用…… 贝尔级数的概念贝尔级数的定义贝尔级数是一种形式幂级数。对于给定的数论函数$f$和质数$p$，我们定义$f$模$p$的贝尔级数为：$$f_p(x)=\sum_{i = 0}^{+\infty} f(p^i)x^i$$ 贝尔级数的基本性质唯一定理对于两个积性函数$f$和$g$，如果对于任意质数$p$都有$f$和$g$模$p$的贝尔级数相同，那两者相同。 这个定理我局的还事挺好理解的……两个积性函数在任何质数的幂的表现都相同，那么两者也相同。 因为一般的数论函数没有这么优秀的性质……所以下面提到的贝尔级数的应用基本上都针对积性函数…… 狄利克雷卷积对任意两个数论函数$f$和$g$，有$(f\ast g)_p(x) = f_p(x)\cdot g_p(x)$。 这是贝尔级数最有用的性质了……（没这个性质用它干啥？） 完全积性函数的贝尔级数对于一个完全积性函数$f$，有$f_p(x)=\frac{1}{1 - f(p)x}$。 这个也不难理解，用的就是等比数列求和公式。不过好在事形式幂级数，并不需要考虑收敛的问题…… 常用积性函数函数的贝尔级数关于狄利克雷卷积的单位元$\epsilon$（$\epsilon(x) = [x=1]$），不必自说当然是$1$。 首先对于$f(x) = x^k(k\in N^0)$这种东西，根据完全积性函数的贝尔级数公式可知有$f_p(x)=\frac{1}{1 - p^kx}$。 莫比乌斯函数比较有意思。显然$\mu(1) = 1$，$\mu(p) = -1$，但是$\mu(p^k)=0(k\ge 2)$。所以说其贝尔级数就是$1-x$。类似我们可以推导得$\mu^2$的贝尔级数为$1+x$。 欧拉函数直接推有些棘手……但注意到我们知道$\varphi\ast 1 = \mathrm{id}$，反演一下可以得知$\mathrm{id}\ast\mu =\varphi$，由此可得$\varphi_p(x)=\frac{1 - x}{1 - px}$。 接下来介绍一个非常好玩的函数：刘维尔函数。在此之前先定义$\Omega(n)$表示$n$的可重复质因子数（因此$\Omega(4) = 2$），那么刘维尔函数$\lambda(x) = (-1)^{\Omega(x)}$，这个函数很显然是完全积性函数，故$\lambda_p(x)=\frac{1}{1 + x}$。这个函数有些时候是肥肠有用的。 然后考虑约数好兄弟$\sigma_k$。很显然$\sigma_k = \mathrm{id}^k\ast 1$，因此可以推出$(\sigma_k)_p(x)=\frac{1}{1 - p^kx}\cdot\frac{1}{1 - x} = \frac{1}{1 - (1 + p^k)x + p^kx^2}$。 至此常见积性函数已经推完力，，， 贝尔级数在狄利克雷卷积中的应用这个还算是很显然吧…… 举个例子，让你证$(\mathrm{id}\cdot\mu)\ast\mathrm{id} = \epsilon$。 这个东西用传统的计数解方法当然可行，但是多麻烦事有目共睹的（甚至于有些东西被我们的当结论记了）。用贝尔级数的话这个等式不就是$(1 - px)\cdot\frac{1}{1 - px} = 1$嘛，非常简单。 还有一些比较复杂的例子，大家可以自行寻找。 贝尔级数在杜教筛中的应用这个东西算是最大应用了吧…… 应用主要分为两部分：你知道$f$本身是啥，但是不知道找啥去卷比较好；你不知道$f$本身是啥（你只知道它在质数的幂上表现），但你还是要杜教筛。 利用贝尔级数构造合适的狄利克雷卷积给一道题吧：求$\mu^2\ast (\mathrm{id}\cdot\mu)$这个东西的前缀和，$n\le 10^{11}$。 如果你不知道贝尔级数，你可能需要靠背上面提到的那个用传统方法很难证的结论来做这个题…… 但如果说你知道贝尔级数的话，你发现原函数贝尔级数为$(1 + x)(1 - px)$，然后我们想肯定要消掉一部分或者全部式子。我们考虑卷上一个$\mathrm{id}$，弄完了之后的贝尔级数为$1 + x$，也就是$\mu^2$。 $\mathrm{id}$的前缀和自然好说，但是$\mu^2$的前缀和咋整？ 其实$\mu^2$就是判断它是否没有完全平方因子。因此我们直接枚举那个因子的平方根就好了，但是这样会重复，因此考虑用$\mu$容斥一下，得到：$$\sum_{i = 1}^n\mu^2(i)=\sum_{i = 1}^{\lfloor\sqrt{n}\rfloor}\mu(i)\lfloor\frac{n}{i^2}\rfloor$$因此$\mu^2$的前缀和是可以根号复杂度来求的，不会影响杜教筛总的转移复杂度。因此总复杂度为$O(n^{\frac{2}{3}})$。 在不知道函数本身是啥的时候杜教筛还是给一道题： 有一个积性函数$f(x)$，你不知道它本身是啥，但是你知道他满足以下性质： $f(1) = 1$。 对于质数$p$和正整数$a$，有$f(p^a) = p^a + (-1)^a$。 求这玩意的前缀和，$n\le 10^{11}$。 其实你通过OEIS可以知道这个函数本身是啥（逃），但考虑到那样你也很难用常规手段杜教筛所以还事没啥用…… 首先考虑去构造这个玩意的贝尔级数。它看起来很像事$\mathrm{id}$和$\lambda$的贝尔级数加一下，但是考虑到$f(1) = 1$因此还要再减个1。最后得到：$$f_p(x)=\frac{1}{1 - px} + \frac{1}{1 + x} - 1$$我们想要卷上一个$g$，那些分母看起来很不顺眼，干脆把他们都消掉了吧！因此我们规定$g_p(x) = (1 - px)(1 + x)$（因此我们得知$g = (\mathrm{id}\cdot\mu)\ast\mu^2$）。卷出来之后发现：$$(f\ast g)_p(x) = 1 + x + 1 - px - 1 - x + px + px^2 = 1 + px^2$$然后我们弄了一大半顿我们还是不知道$f\ast g$具体是啥……但是我们观察到一点非常重要的性质：若$(f\ast g)(x)\ne 0$，那么$x$起码也得是完全平方数，并且$\mu^2(\sqrt{x}) = 1$，并且对答案的贡献为$\sqrt{x}$！ 这下$f\ast g$虽然还不知道是啥，但是起码它前缀和好求了！我们对于对答案可能有贡献的$x$枚举其算术平方根即可，写出来就是：$$\sum_{i = 1}^n(f\ast g)(i) = \sum_{i = 1}^{\lfloor\sqrt{n}\rfloor}\mu^2(i)i$$这样的话求$f\ast g$的前缀和的复杂度就已经降到$O(\sqrt{n})$了，更进一步我们发现这个式子的答案只和$\lfloor\sqrt{n}\rfloor$有关，所以我们用$O(\sqrt{n})$的时间预处理所有这种和之后$O(1)$查询就好了。 剩下唯一的硬骨头就是$g$的前缀和，这个上一小节已经讲了。 虽说这玩意蛮有用的……但是无法阻止杜教筛过气，常熟优秀还好想的MIN_25筛已经要dssq力（悲）]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>贝尔级数</tag>
        <tag>生成函数</tag>
        <tag>杜教筛</tag>
        <tag>狄利克雷卷积</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些测试]]></title>
    <url>%2F2018%2F07%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[一级标题二级标题三级标题四级标题五级标题行内公式：$\int_{-\infty}^{+\infty}e^{x^2}\mathrm{d}x$。 行间公式：$$\int u\mathrm{d}v = uv - \int v\mathrm{d}u$$ 123456// C++ code#include &lt;cstdio&gt;int main() &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); printf("%d\n", a + b); return 0;&#125; 嗯，OC！]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
