<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LibreOJ 2542 「PKUWC2018」随机游走]]></title>
    <url>%2F2018%2F08%2F09%2Floj2542%2F</url>
    <content type="text"><![CDATA[Description 有一个\(n\)个点的树，有一个固定的点为\(x\)。 \(Q\)次询问，每次给你一个集合。要求你求出从\(x\)出发，每一步都等概率随机选择一条邻边走过去，将集合中每个点都走了至少一遍的话期望的步数为多少（\(x\)视为一开始就经过了）。答案模\(998244353\)输出。 \(1\leq n\leq 18, Q\leq 5000\)。 Solution 高，高啊.jpg 考虑期望步数的实质是集合中最晚一个经过的点被经过的期望步数。最大值不好算，我们就考虑用MIN-MAX容斥，转成最小值。因此问题转化成了从\(x\)出发最早走到一个集合中至少一个点的期望步数。 这个东西的话，先枚举那个集合\(S\)，然后考虑期望DP。设状态\(f_i\)表示从\(i\)出发的期望步数，那么有： \[ f_i = \begin{cases} 0 &amp; \text{if } i\in S,\\ \frac{f_{\mathrm{fa}_i}+\sum f_{\mathrm{ch}_{i, j}}}{d_i} + 1 &amp; \text{if }i\notin S. \end{cases} \] 其中\(\mathrm{fa_i}\)表示\(i\)的父亲，\(\mathrm{ch}_{i, j}\)表示\(i\)的第\(j\)个儿子，\(d_i\)表示\(i\)的度数。如果这样直接高消做的话，那么DP+高消部分的复杂度是\(O(2^nn^3)\)，有点吃不消（但据说可以过的）。 考虑到这样一件事：对于任意叶子或者是属于\(S\)的点，他们的\(f\)都可以表示为父亲的\(f\)的若干倍加上一个常数。那么我们DFS一遍，一个只有这两类点儿子的父亲\(i\)在DFS完了自己所有儿子之后，就能知道\(\sum f_{\mathrm{ch}_{i, j}}\)这个东西可以如何用\(f_i\)的若干倍加上一个常数来表示，这样一来移项再整理一下\(f_i\)也就可以用\(f_{\mathrm{fa}_i}\)的若干倍加上一个常数来表示了。如此往上一直推，推到根节点的话根节点的父亲的答案为0，所以最终答案就是那个最后的常数了。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;using ll = long long;const ll ha = 998244353LL;ll pow_mod(ll a, ll b) &#123; ll ans = 1, res = a; while(b) &#123; if(1LL &amp; b) ans = ans * res % ha; res = res * res % ha; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow_mod(x, ha - 2LL);&#125;struct Rec &#123; ll x, y; Rec(ll a = 0, ll b = 0) &#123; x = a; y = b; &#125;&#125;;Rec operator +(const Rec &amp;a, const Rec &amp;b) &#123; return Rec((a.x + b.x) % ha, (a.y + b.y) % ha);&#125;Rec operator -(const Rec &amp;a, const Rec &amp;b) &#123; return Rec((a.x - b.x + ha) % ha, (a.y - b.y + ha) % ha);&#125;Rec operator *(const Rec &amp;a, const ll &amp;v) &#123; return Rec(a.x * v % ha, a.y * v % ha);&#125;Rec operator *(const ll &amp;v, const Rec &amp;a) &#123; return Rec(a.x * v % ha, a.y * v % ha);&#125;const int maxn = 20;std::vector&lt;int&gt; G[maxn]; int deg[maxn];Rec dfs(int s, int x, int fa) &#123; if((1 &lt;&lt; (x - 1)) &amp; s) return Rec(); Rec lt(deg[x], ha - deg[x]); for(int v : G[x]) &#123; if(v != fa) &#123; lt = lt - dfs(s, v, x); &#125; &#125; ll inv_A = inv(lt.x); return Rec(inv_A, ((ha - lt.y) % ha) * inv_A % ha);&#125;ll minv[1 &lt;&lt; 18], ps[1 &lt;&lt; 18];int cnt[1 &lt;&lt; 18];ll dir(int x) &#123; if(x &amp; 1) &#123; return 1; &#125; else &#123; return ha - 1LL; &#125;&#125;int main() &#123; int n, Q, x; scanf("%d%d%d", &amp;n, &amp;Q, &amp;x); for(int i = 1; i &lt;= n - 1; i ++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); deg[u] ++; deg[v] ++; &#125; for(int s = 1; s &lt; (1 &lt;&lt; n); s ++) &#123; minv[s] = dfs(s, x, -1).y; &#125; for(int s = 1; s &lt; (1 &lt;&lt; n); s ++) &#123; for(int i = 0; i &lt; n; i ++) &#123; if((1 &lt;&lt; i) &amp; s) cnt[s] ++; &#125; &#125; while(Q --) &#123; int k; scanf("%d", &amp;k); int s = 0; while(k --) &#123; int x; scanf("%d", &amp;x); s |= (1 &lt;&lt; (x - 1)); &#125; ll ret = 0; for(int t = s; t; t = (t - 1) &amp; s) &#123; ret = (ret + (dir(cnt[t]) * minv[t]) % ha) % ha; &#125; printf("%lld\n", ret); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>容斥原理</tag>
        <tag>期望DP</tag>
        <tag>概率与期望</tag>
        <tag>LibreOJ</tag>
        <tag>PKUWC</tag>
        <tag>树上DP</tag>
        <tag>高斯消元</tag>
        <tag>MIN-MAX容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 2541 「PKUWC2018」猎人杀]]></title>
    <url>%2F2018%2F08%2F09%2Floj2541%2F</url>
    <content type="text"><![CDATA[Description 有\(n\)个人，第\(i\)人有一个正整数权值\(w_i\)。 每个人死后要开枪打死另一个人，假设剩下的人权值和为\(S\)，那么编号为\(i\)的活人被选中的概率为\(\frac{w_i}{S}\)。至于第一枪的话，随机选择一个人，第\(i\)个人被选中的概率为\(\frac{w_i}{\sum_{i = 1}^nw_i}\)。 问编号为\(1\)的人有多少概率成为最后一个死的人。 \(\sum_{i = 1}^n w_i\leq 10^5\)。 Solution 这思路ao神，，， 一个非常毒瘤的事情是每个人被打死的概率都在时刻变动，我们考虑让每个人被击中的概率不变。 这样的话我们规定可以向死人开枪，但是一个人不能死两次（大雾），但他可以接着往下开枪。这样的话其实和原来的模型是一样的，下面证明一下： 首先先说一个引理吧：级数\(\sum_{i = 0}^{+\infty} a^ig=\frac{g}{1 - a}(0\leq a&lt;1)\)。 证明倒还简单。把\(g\)提出来，然后后面用等比数列求和公式可以得到\(\frac{1-a^{\infty}}{1-a}\)，而\(\lim_{x\rightarrow +\infty} a^x = 0(0\leq a &lt; 1)\)，带回去就得到了\(\frac{1}{1-a}\)，乘上\(g\)就是\(\frac{g}{1-a}\)。 然后我们考虑假设现在死掉的人的权值和为\(T\)，总权值和为\(S\)。那么下一个死掉的人是\(i\)的概率就是： \[ \sum_{k = 0}^{\infty} (\frac{T}{S})^k\frac{w_i}{S} \] 应用上面的结论，这个东西可以化简为\(\frac{w_i}{S}\cdot\frac{S}{S - T} = \frac{w_i}{S - T}\)，正是我们想要的那个概率…… 但接下来还不好做……然后我们想一想我们直接做是要求了恰好0个人在\(1\)之后死，那要是我们求至少\(k\)个人在\(1\)之后死呢？ 假设这\(k\)个人的权值和为\(T\)，总权值和为\(S\)。那么这个集合对答案的贡献为： \[ (-1)^k\sum_{i = 0}^{\infty}(1 - \frac{T + w_1}{S})^i \frac{w_1}{S} \] 前面的\((-1)^k\)是容斥系数，然后后面的级数又可以应用上面的引理了！这次可以推出来后面的级数为\(\frac{w_1}{T + w_1}\)。 虽然推出来了式子，不过我们总不能枚举子集再容斥吧？注意到如果两个集合\(T\)一样的话，那么他们（不考虑容斥系数的话）对答案贡献一样。所以我们考虑如何去搞每个\(T\)的所有对应集合的容斥系数之和就行了，这个东西的生成函数显然是： \[ \prod_{i = 2}^n(1-x^{w_i}) \] 然后这玩意就是分治FFT的经典题了…… Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;vector&gt;using ll = long long;const ll ha = 998244353LL;ll pow_mod(ll a, ll b) &#123; ll ans = 1, res = a; while(b) &#123; if(1LL &amp; b) ans = ans * res % ha; res = res * res % ha; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow_mod(x, ha - 2LL);&#125;int flip(int bi, int x) &#123; int ans = 0; for(int i = 0; i &lt; bi; i ++) &#123; if((1 &lt;&lt; i) &amp; x) &#123; ans |= (1 &lt;&lt; (bi - i - 1)); &#125; &#125; return ans;&#125;void NTT(ll *A, int bi, bool flag = false) &#123; int n = 1 &lt;&lt; bi; for(int i = 0; i &lt; n; i ++) &#123; int f = flip(bi, i); if(f &lt; i) std::swap(A[f], A[i]); &#125; for(int L = 1; L &lt; n; L &lt;&lt;= 1) &#123; ll xi_n = pow_mod(3LL, (ha - 1LL) / (ll(L &lt;&lt; 1))); if(flag) xi_n = inv(xi_n); for(int i = 0; i &lt; n; i += (L &lt;&lt; 1)) &#123; ll xi = 1; for(int j = i; j &lt; i + L; j ++) &#123; ll x = A[j], y = A[j + L]; A[j] = (x + (y * xi) % ha) % ha; A[j + L] = (x - (y * xi) % ha + ha) % ha; xi = xi * xi_n % ha; &#125; &#125; &#125; if(flag) &#123; ll inv_n = inv(n); for(int i = 0; i &lt; n; i ++) &#123; A[i] = A[i] * inv_n % ha; &#125; &#125;&#125;struct Poly &#123; ll *A; int n; Poly(int len) &#123; A = (ll*)calloc(len + 1, sizeof(ll)); n = len; &#125; ~Poly() &#123; free(A); &#125;&#125;;const int maxn = 100005;int n; int w[maxn];Poly *div_con(int L, int R) &#123; if(L == R) &#123; Poly *ret = new Poly(w[L]); ret -&gt; A[0] = 1; ret -&gt; A[w[L]] = ha - 1LL; return ret; &#125; else &#123; static ll A[maxn &lt;&lt; 2], B[maxn &lt;&lt; 2]; int M = (L + R) / 2; Poly *l = div_con(L, M), *r = div_con(M + 1, R); int rn = l -&gt; n + r -&gt; n; int bi = 0, len = 1; while(len &lt;= rn) &#123; len &lt;&lt;= 1; bi ++; &#125; std::copy((l -&gt; A), (l -&gt; A) + l -&gt; n + 1, A); std::copy((r -&gt; A), (r -&gt; A) + r -&gt; n + 1, B); std::fill(A + l -&gt; n + 1, A + len, 0LL); std::fill(B + r -&gt; n + 1, B + len, 0LL); delete l; delete r; NTT(A, bi); NTT(B, bi); for(int i = 0; i &lt; len; i ++) A[i] = A[i] * B[i] % ha; NTT(A, bi, true); Poly *ret = new Poly(rn); std::copy(A, A + rn + 1, ret -&gt; A); return ret; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i ++) scanf("%d", &amp;w[i]); Poly *P = div_con(2, n); ll *A = P -&gt; A; int len = P -&gt; n; ll ans = 0; for(int i = 0; i &lt;= len; i ++) &#123; ll delta = A[i]; delta = delta * (ll(w[1])) % ha; delta = delta * inv(w[1] + i) % ha; ans = (ans + delta) % ha; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>概率与期望</tag>
        <tag>多项式卷积</tag>
        <tag>LibreOJ</tag>
        <tag>生成函数</tag>
        <tag>PKUWC</tag>
        <tag>分治FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 2537 「PKUWC2018」Minimax]]></title>
    <url>%2F2018%2F08%2F09%2Floj2537%2F</url>
    <content type="text"><![CDATA[Description 有一个\(n\)个点的以\(1\)为根的树，每个点至多有两个儿子。 对于每个叶子，他的权值事确定的，且两两不同。对于一个非叶子结点\(i\)，他有一个系数\(p_i(0&lt;p_i&lt;1)\)，满足有\(p_i\)的概率该点权值为子节点权值最大值，其他情况下为最小值。 那么我们会发现每种权值根节点都可能取到，假设有\(m\)种权值，第\(i\)小的权值为\(v_i\)，\(v_i\)成为根节点权值的概率为\(d_i\)。那么求： \[ \sum_{i = 1}^m i\cdot v_i\cdot d_i^2 \] \(1\leq n\leq 300000, 0\leq v_i\leq 10^9\)。 Solution 从PKUWC开始，苦思冥想了很久，然后看到了一句每个点至多有两个儿子。 我想脱口而出一句μαλάκας。 考虑使用线段树来存储一个点所有可能的权值的概率。那么叶子很好处理，只有一个儿子的点只需要用儿子的树就行了，唯一麻烦的就是有两个儿子的点。 这个东西很显然可以线段树合并吧……注意到右边树第\(i\)小的概率\(p_i\)会发生如下变化： \[ p_i = p_i&#39;(pS_{l, 1\ldots i - 1} + (1 - p)S_{l, i+1\ldots n}) \] 这里\(S_{l,a\ldots b}\)代表左边树本来\([a, b]\)这一段的和，\(p_i&#39;\)代表变换前的\(p_i\)，\(p\)就是这一个结点取最大的概率。 因此线段树合并的时候维护一下两边树分别在当前合并结点两侧的和就行了…… Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;using ll = long long;const ll ha = 998244353LL;ll pow_mod(ll a, ll b) &#123; ll ans = 1, res = a; while(b) &#123; if(1LL &amp; b) ans = ans * res % ha; res = res * res % ha; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow_mod(x, ha - 2LL);&#125;const int bufsiz = 50 * 1024 * 1024;char buf[bufsiz];void *alloc(size_t size) &#123; static char *cur = buf; if(cur - buf + size &gt; bufsiz) &#123; return malloc(size); &#125; else &#123; char *ret = cur; cur += size; return ret; &#125;&#125;struct Node &#123; Node *lc, *rc; ll s, mulv; void maintain(); void paint(ll v); void pushdown();&#125;;Node *nil;void Node::maintain() &#123; s = (lc -&gt; s + rc -&gt; s) % ha;&#125;void Node::paint(ll v) &#123; if(this != nil) &#123; mulv = mulv * v % ha; s = s * v % ha; &#125;&#125;void Node::pushdown() &#123; if(mulv != 1LL) &#123; lc -&gt; paint(mulv); rc -&gt; paint(mulv); mulv = 1LL; &#125;&#125;void init_pool() &#123; nil = (Node*)alloc(sizeof(Node)); nil -&gt; lc = nil -&gt; rc = nil; nil -&gt; s = 0; nil -&gt; mulv = 1;&#125;Node *alloc_node(ll s = 1, Node *lc = nil, Node *rc = nil) &#123; Node *ret = (Node*)alloc(sizeof(Node)); ret -&gt; s = s; ret -&gt; mulv = 1; ret -&gt; lc = lc; ret -&gt; rc = rc; return ret;&#125;Node *modify(Node *o, int L, int R, int p, ll v) &#123; if(o == nil) o = alloc_node(v, nil, nil); if(L &lt; R) &#123; int M = (L + R) / 2; if(p &lt;= M) &#123; o -&gt; lc = modify(o -&gt; lc, L, M, p, v); &#125; else &#123; o -&gt; rc = modify(o -&gt; rc, M + 1, R, p, v); &#125; &#125; return o;&#125;Node *merge(Node *l, Node *r, const ll &amp;p, ll lp, ll ls, ll rp, ll rs) &#123; if(l == nil &amp;&amp; r == nil) return nil; if(l == nil) &#123; ll v1 = p * lp % ha; ll v2 = ((1LL - p + ha) % ha) * ls % ha; r -&gt; paint((v1 + v2) % ha); return r; &#125; if(r == nil) &#123; ll v1 = p * rp % ha; ll v2 = ((1 - p + ha) % ha) * rs % ha; l -&gt; paint((v1 + v2) % ha); return l; &#125; l -&gt; pushdown(); r -&gt; pushdown(); ll l1 = l -&gt; lc -&gt; s, l2 = l -&gt; rc -&gt; s; ll r1 = r -&gt; lc -&gt; s, r2 = r -&gt; rc -&gt; s; l -&gt; lc = merge(l -&gt; lc, r -&gt; lc, p, lp, (ls + l2) % ha, rp, (rs + r2) % ha); l -&gt; rc = merge(l -&gt; rc, r -&gt; rc, p, (lp + l1) % ha, ls, (rp + r1) % ha, rs); l -&gt; maintain(); return l;&#125;const int maxn = 300005;int cnt;ll A[maxn], p[maxn];std::vector&lt;int&gt; G[maxn];Node *solve(int x) &#123; if(G[x].size() == 0) &#123; int v = std::lower_bound(A + 1, A + 1 + cnt, p[x]) - A; return modify(nil, 1, cnt, v, 1); &#125; else if(G[x].size() == 1) &#123; return solve(G[x][0]); &#125; else &#123; static const ll inv_w = inv(10000); p[x] = p[x] * inv_w % ha; Node *l = solve(G[x][0]), *r = solve(G[x][1]); return merge(l, r, p[x], 0, 0, 0, 0); &#125;&#125;ll calc(Node *o, int L, int R) &#123; if(o == nil) return 0; if(L == R) &#123; ll prob = o -&gt; s; ll ret = prob * prob % ha; ret = ret * ((ll)L * (A[L] % ha) % ha) % ha; return ret; &#125; else &#123; o -&gt; pushdown(); ll ret = 0; int M = (L + R) / 2; ret = (ret + calc(o -&gt; lc, L, M)) % ha; ret = (ret + calc(o -&gt; rc, M + 1, R)) % ha; return ret; &#125;&#125;int main() &#123; init_pool(); int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i ++) &#123; int fa; scanf("%d", &amp;fa); G[fa].push_back(i); &#125; cnt = 0; for(int i = 1; i &lt;= n; i ++) &#123; scanf("%lld", &amp;p[i]); if(G[i].empty()) &#123; A[++ cnt] = p[i]; &#125; &#125; std::sort(A + 1, A + 1 + cnt); printf("%lld\n", calc(solve(1), 1, cnt)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树合并</tag>
        <tag>PKUWC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 2112 「HNOI2015」亚瑟王]]></title>
    <url>%2F2018%2F08%2F08%2Floj2112%2F</url>
    <content type="text"><![CDATA[Description 给你\(n\)张用\(1\ldots n\)编号的牌，第\(i\)张牌发动概率为\(p_i\)，造成伤害为\(d_i\)。 然后有\(r\)回合，每回合会从当前没用过的牌里从小到大考虑，依次试图去发动（如果有一个成功发动的话就不会往下接着尝试，这回合结束）。求期望造成的伤害。 每个点共\(T(1\leq T\leq 444)\)组数据，\(1\leq n\leq 220, 0\leq r\leq 132, 0&lt;p_i&lt;1, 0\leq d_i\leq 1000\)。 Solution 这DP有毒.jpg 直接做是肯定不可做的……因此我们考虑利用期望线性性，分别考虑每张牌可能对答案有什么贡献。 然后还是一脸不可做……但是注意到对于每张牌，我们计算他的贡献的时候并不关心之前具体有哪些牌发动了，我们只关心他自己被考虑了多少次……（这里假设一张牌即使被用了还是会被考虑只不过不会再发动，下同） 然后考虑定义状态\(f_{i, j}\)表示第\(i\)张牌被恰好考虑了\(j\)次的概率。这样DP的话只需要考虑上一张牌发动与否即可，所以有： \[ f_{i, j} = f_{i - 1, j}(1-p_{i - 1})^j + f_{i - 1, j + 1}(1 - (1 - p_{i - 1})^{j + 1}) \] 状态转移方程还是很好懂的……前面一项就是前一张牌一直没有被发动，第二项就是前面一项曾经被发动过。 然后就没有然后了……顺便注意预处理\((1 - p_i)\)的幂能快不少。 Code 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;typedef double R;const int maxn = 225;R p[maxn], d[maxn], f[maxn][maxn], G[maxn][maxn];int main() &#123; int T; scanf("%d", &amp;T); while(T --) &#123; int n, r; scanf("%d%d", &amp;n, &amp;r); for(int i = 1; i &lt;= n; i ++) &#123; scanf("%lf%lf", &amp;p[i], &amp;d[i]); &#125; std::fill(f[0], f[0] + r + 2, 0.00); f[0][r] = 1; for(int i = 0; i &lt;= n; i ++) &#123; R bs = 1 - p[i]; G[i][0] = 1; for(int j = 1; j &lt;= r + 1; j ++) &#123; G[i][j] = G[i][j - 1] * bs; &#125; &#125; for(int i = 1; i &lt;= n; i ++) &#123; f[i][r + 1] = 0; for(int j = 1; j &lt;= r; j ++) &#123; f[i][j] = 0; f[i][j] += f[i - 1][j] * G[i - 1][j]; f[i][j] += f[i - 1][j + 1] * (1 - G[i - 1][j + 1]); &#125; &#125; R ans = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= r; j ++) &#123; ans += f[i][j] * (1 - G[i][j]) * d[i]; &#125; &#125; printf("%.10lf\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>期望DP</tag>
        <tag>LibreOJ</tag>
        <tag>HNOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 2478 「九省联考 2018」林克卡特树]]></title>
    <url>%2F2018%2F08%2F08%2Floj2478%2F</url>
    <content type="text"><![CDATA[Description 有一个\(n\)个点的带边权树，要求你取出\(k + 1\)条点不相交的链（链可以只有一个单点），使得这些链的边权和最大。 \(0\leq k&lt; n\leq 3\times 10^5\)，边权绝对值不超过\(10^6\)。 Solution wqs二分第三题…… 下面说的\(k\)默认都是原题中的\(k + 1\)。 要是\(nk\)不大的话，那么有一个经典的搞法就是树上DP，记状态\(f_{i,s.0/1/2}\)表示点\(i\)这个子树总共取了\(k\)条链，\(i\)本身在这些链中度数为\(0/1/2\)的情况的最优解，转移还是比较显（fan）然（suo）的…… 然后\(nk\)很大……但是发现这种东西取了有收益，然后还有数量限制，要素察觉（意味深） 虽然这个东西的凸性只能感性理解或者打表理解了……我真的不会证啊 然后考虑wqs二分……具体方法就是wqs二分，里面的DP就把上面的DP去掉链数限制就行了。 然后存在一个问题就是，假设二分出来一个\(v\)，但是代价为\(v\)的时候链数比\(k\)小，代价为\(v-1\)的时候链数就比\(k\)多了。这样的话当代价为\(v\)的时候照样存在\(k\)条链的最优解，所以在\(v\)时的最优解中补上一个\(kv\)就完了…… Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;const int maxn = 300005;const int maxm = maxn &lt;&lt; 1;int first[maxn];int next[maxm], to[maxm], dist[maxm];void add_edge(int u, int v, int d) &#123; static int cnt = 0; cnt ++; next[cnt] = first[u]; first[u] = cnt; to[cnt] = v; dist[cnt] = d;&#125;void ins_edge(int u, int v, int d) &#123; add_edge(u, v, d); add_edge(v, u, d);&#125;typedef long long ll;struct pii &#123; ll a; int b; pii() &#123;&#125; pii(ll x, int y) &#123; a = x; b = y; &#125; bool operator &lt;(const pii &amp;res) const &#123; if(a == res.a) &#123; return b &gt; res.b; &#125; else &#123; return a &lt; res.a; &#125; &#125; bool operator ==(const pii &amp;res) const &#123; return (a == res.a) &amp;&amp; (b == res.b); &#125;&#125;;pii operator +(const pii &amp;a, const pii &amp;b) &#123; return pii(a.a + b.a, a.b + b.b);&#125;pii d[maxn][3];void dfs(int x, int fa, const ll &amp;cost) &#123; d[x][0] = pii(0LL, 0); d[x][1] = d[x][2] = pii(-cost, 1); for(int i = first[x]; i; i = next[i]) &#123; int v = to[i]; if(v != fa) &#123; dfs(v, x, cost); pii maxv = std::max(d[v][0], std::max(d[v][1], d[v][2])); pii t2 = std::max(maxv + d[x][2], d[x][1] + d[v][1] + pii((ll)dist[i] + cost, -1)); d[x][2] = std::max(d[x][2], t2); pii t1 = std::max(maxv + d[x][1], d[x][0] + d[v][1] + pii((ll)dist[i], 0)); d[x][1] = std::max(d[x][1], t1); d[x][0] = std::max(d[x][0], d[x][0] + maxv); &#125; &#125;&#125;int main() &#123; int n, k; scanf("%d%d", &amp;n, &amp;k); k ++; ll L = 0LL, R = 0LL; for(int i = 1; i &lt;= n - 1; i ++) &#123; int u, v, w; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); ins_edge(u, v, w); R += std::max(0, w); L = std::min(L, (ll)-w); &#125; while(L &lt; R) &#123;#ifdef LOCAL printf("Range (%lld, %lld)\n", L, R); fflush(stdout);#endif ll M = L + (R - L) / 2LL; dfs(1, -1, M); pii t = std::max(d[1][0], std::max(d[1][1], d[1][2])); if(t.b &lt;= k) &#123; R = M; &#125; else &#123; L = M + 1LL; &#125; &#125; dfs(1, -1, L); pii t = std::max(d[1][0], std::max(d[1][1], d[1][2])); printf("%lld\n", t.a + (ll)k * L); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>wqs二分</tag>
        <tag>多省联考</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF739E Gosha is hunting]]></title>
    <url>%2F2018%2F08%2F08%2FCF739E%2F</url>
    <content type="text"><![CDATA[Description 有\(n\)个精灵，你手里有\(A\)个普通球和\(B\)个超级球。对于第\(i\)个精灵，只用普通球捕获的概率为\(p_i\)，只用超级球捕获的概率为\(u_i\)。对于每只精灵，你可以不去捕获他，也可以选择用普通球和超级球中的一种去捕获，也可以先用一种再用另一种，但是要注意不能在同一个精灵上使用多个普通球或者多个超级球。 请你安排一种合理的策略，使得捕获精灵的期望尽可能大，并输出最大期望。 \(2\leq n\leq 2000,0\leq A, B\leq n, 0\leq p_i,u_i\leq 1\)。 Solution wqs二分第二题…… 看到个数限制，每个有收益，要素察觉（意味深） 然后考虑往wqs二分上靠，但是限制有两种，那么我们就要考虑用wqs二分套wqs二分了。 然后下面考虑那玩意是不是真的有凸性……这个东西是三维的情况，普通球限制（设为\(x\)）、超级球限制（设为\(y\)）和收益（设为\(z\)）这三维，那么我们要求\(x\)固定的时候\(y\)是凸的，并且每种\(x\)的最优解也是凸的。 固定\(x\)的话，我们考虑\(y\)不断增大的情况。在\(x\)固定且限制存在的情况下，我们会发现每个超级球能给答案带来的最大贡献是一定的，那么考虑将这些贡献排序，我们一定会取前\(y\)项的和。也就是说超级球给答案的贡献是一个前缀和，差分一下就会得到原序列，而原序列是一个递减的序列，所以斜率递减，自然就凸力，，， 那么\(x\)的最优解是凸的，证明也是前缀和这一套理论……\(x\)限制存在时一定会优先选贡献最大的，然后排序之后就相当于前缀和，前缀和差分完了是递减的所以凸。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;const int maxn = 100005;using R = double;const R eps = 1e-9;R f[maxn], p[maxn], u[maxn];int cnt_a[maxn], cnt_b[maxn];int n;bool dp(R v1, R v2) &#123; f[0] = 0; cnt_a[0] = cnt_b[0] = 0; for(int i = 1; i &lt;= n; i ++) &#123; f[i] = f[i - 1]; cnt_a[i] = cnt_a[i - 1]; cnt_b[i] = cnt_b[i - 1]; if(f[i - 1] + p[i] - v1 &gt; f[i]) &#123; f[i] = f[i - 1] + p[i] - v1; cnt_a[i] = cnt_a[i - 1] + 1; cnt_b[i] = cnt_b[i - 1]; &#125; if(f[i - 1] + u[i] - v2 &gt; f[i]) &#123; f[i] = f[i - 1] + u[i] - v2; cnt_a[i] = cnt_a[i - 1]; cnt_b[i] = cnt_b[i - 1] + 1; &#125; if(f[i - 1] + 1 - (1 - p[i]) * (1 - u[i]) - v1 - v2 &gt; f[i]) &#123; f[i] = f[i - 1] + 1 - (1 - p[i]) * (1 - u[i]) - v1 - v2; cnt_a[i] = cnt_a[i - 1] + 1; cnt_b[i] = cnt_b[i - 1] + 1; &#125; &#125; return true;&#125;int main() &#123; int A, B; scanf("%d%d%d", &amp;n, &amp;A, &amp;B); for(int i = 1; i &lt;= n; i ++) scanf("%lf", &amp;p[i]); for(int i = 1; i &lt;= n; i ++) scanf("%lf", &amp;u[i]); R l1 = 0, r1 = 1, l2, r2; while(r1 - l1 &gt; eps) &#123; R m1 = (l1 + r1) / 2; l2 = 0, r2 = 1; while(r2 - l2 &gt; eps) &#123; R m2 = (l2 + r2) / 2; if(dp(m1, m2) &amp;&amp; cnt_b[n] &gt; B) &#123; l2 = m2; &#125; else &#123; r2 = m2; &#125; &#125; if(dp(m1, r2) &amp;&amp; cnt_a[n] &gt; A) &#123; l1 = m1; &#125; else &#123; r1 = m1; &#125; &#125; dp(r1, r2); printf("%.5lf\n", f[n] + (R)A * r1 + (R)B * r2); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Codeforces</tag>
        <tag>wqs二分</tag>
        <tag>期望DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3569 DZY Loves Chinese II]]></title>
    <url>%2F2018%2F08%2F07%2FBZOJ3569%2F</url>
    <content type="text"><![CDATA[Description 有一个\(n\)个点\(m\)条边的简单无向联通图，\(q\)组询问。每组询问给定一个\(k\)，再给\(k\)条边，输出假设这\(k\)条边不存在，那么图是否联通（询问互相独立）。并且强制在线。 \(n\leq 10^5, m\leq 5\times 10^5, q\leq 5\times 10^4, k\leq 15\)。 Solution 好像做了整整五个月罢……真的事大脑满级人罢，，， 考虑构造随便构造一个DFS树，然后给所有非树边随出来一个权值，树边的权值定义为覆盖它的所有非树边权的异或和。然后我们发现如果给定\(k\)条边可以凑出来一个子集使得其异或和为\(0\)，那么就事不联通的。 至于如何判断是否有异或和为\(0\)的子集。注意到如果把二进制数搞成一个向量，那么这个条件等价于这些向量线性相关。线性相关的话就等价于线性基数小于总数，所以用线性基判一下。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;climits&gt;#include &lt;utility&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;tr1/random&gt;const int maxn = 100005;const int maxm = 1000005;int first[maxn];int next[maxm], to[maxm], rev[maxm];int gcnt = 0;int add_edge(int u, int v) &#123; gcnt ++; next[gcnt] = first[u]; first[u] = gcnt; to[gcnt] = v; return gcnt;&#125;void ins_edge(int u, int v) &#123; int e1 = add_edge(u, v); int e2 = add_edge(v, u); rev[e1] = e2; rev[e2] = e1;&#125; typedef unsigned long long ull;ull xs[maxm], d[maxm];bool vis[maxn], used[maxm];bool no_tree[maxm];int anc[maxn][18], dep[maxn];typedef std::pair&lt;int, int&gt; pii;#define mp std::make_pairstd::vector&lt;pii&gt; V;std::tr1::mt19937 gen;inline ull rand64() &#123; static std::tr1::uniform_int&lt;ull&gt; dist(0, (1ULL &lt;&lt; 41) - 1ULL); return gen();&#125;void dfs_1(int x, int fa = -1) &#123; vis[x] = true; anc[x][0] = fa; for(int i = first[x]; i; i = next[i]) &#123; if(used[i]) continue; used[i] = used[rev[i]] = true; int v = to[i]; if(vis[v]) &#123; xs[rev[i]] = rand64(); xs[i] = xs[rev[i]]; V.push_back(mp(x, i)); &#125; else &#123; dep[v] = dep[x] + 1; dfs_1(v, x); &#125; &#125;&#125;int n, m;void process_1() &#123; gen.seed(192608); dfs_1(1); for(int i = 0; i &lt; V.size(); i ++) &#123; int u = V[i].first, id = V[i].second; int v = to[id]; d[u] ^= xs[id]; d[v] ^= xs[id]; &#125; memset(vis, 0, sizeof(vis));&#125;void dfs_2(int x) &#123; vis[x] = true; for(int i = first[x]; i; i = next[i]) &#123; int v = to[i]; if(!vis[v]) &#123; dfs_2(v); d[x] ^= d[v]; xs[i] = xs[rev[i]] = d[v]; &#125; &#125;&#125; const int bs = 32;ull A[bs];int insert(ull x) &#123; for(int i = bs - 1; i &gt;= 0; i --) &#123; if(!x) break; if(!((1ULL &lt;&lt; i) &amp; x)) continue; if(A[i]) &#123; x ^= A[i]; &#125; else &#123; for(int j = i - 1; j &gt;= 0; j --) if((1ULL &lt;&lt; j) &amp; x) x ^= A[j]; for(int j = i + 1; j &lt; bs; j ++) if((1ULL &lt;&lt; i) &amp; A[j]) A[j] ^= x; A[i] = x; return i; &#125; &#125; return 0;&#125; void getint(int &amp;x) &#123; char c = getchar(); x = 0; while(!isdigit(c)) c = getchar(); while(isdigit(c)) &#123; x = x * 10 + c - '0'; c = getchar(); &#125;&#125;int main() &#123; getint(n); getint(m); V.resize(m); for(int i = 1; i &lt;= m; i ++) &#123; int u, v; getint(u); getint(v); ins_edge(u, v); &#125; process_1(); dfs_2(1); int q; int tot = 0; getint(q); if(q &lt;= 0) return 0; while(q --) &#123; memset(A, 0, sizeof(A)); int cnt = 0; int k; getint(k); int rec[20]; for(int i = 1; i &lt;= k; i ++) &#123; int c; getint(c); c ^= tot; rec[i] = insert(xs[c * 2 - 1]); if(rec[i]) cnt ++; &#125; if(cnt == k) &#123; tot ++; puts("Connected"); &#125; else &#123; puts("Disconnected"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>线性基</tag>
        <tag>DFS树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARC062F Painting Graphs with AtCoDeer]]></title>
    <url>%2F2018%2F08%2F07%2Farc062F%2F</url>
    <content type="text"><![CDATA[Description 有一个\(n\)个点\(m\)条边的简单（即无重边无自环）无向图，现在有\(k\)种颜色，要求你给每条边染色。 然后你每次可以选择一个简单环，进行一次循环位移。如果一个染色方案能经过若干次该种操作来变成另一种染色方案，那么称这两种染色方案本质相同。 求有多少种不同的染色方案，答案对\(10^9+7\)取模。 \(1\le n\leq 50, 1\leq m, k\leq 100\)。 Solution 首先一件很显然的事情是，每个点双之间是互相独立的，也就是说最后的答案是所有点双的答案之积。所以先求一遍点双再说。 然后点双可以分为三种情况来考虑： 第一种：只有一条边的点双。这种很好处理，答案就是\(k\)。 第二种：只有一个简单环的点双。这个可以转化为一个序列染色，然后可以做若干次循环位移。假设序列（环）长\(l\)，那么做\(x\)次循环位移得到的置换的轮换数为\(\gcd(l, x)\)，套用一下Pólya定理就可以得到答案： \[ \frac{1}{l}\sum_{i = 0}^{l - 1}k^{\gcd(l, i)} \] 第三种：其他情况。这样的话一定会出现环套环的现象，可以证明这样可以凑出所有的置换。那么只要两种方案不同，那么他们一定会在某种颜色的使用次数上不同。所以问题就转化为了\(x_1 + x_2+\ldots+x_k = l\)（\(l\)为该点双中的边数，其中每个变量为自然数）的解的数量。这是一个经典的隔板法问题，答案为： \[ \binom{l + k - 1}{k - 1} \] Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;stack&gt;using ll = long long;const ll ha = 1000000007LL;ll pow_mod(ll a, ll b) &#123; ll ans = 1, res = a; while(b) &#123; if(1LL &amp; b) ans = ans * res % ha; res = res * res % ha; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow_mod(x, ha - 2LL);&#125;ll fac[200005], ifac[200005];void process() &#123; int n = 200000; fac[0] = 1; for(int i = 1; i &lt;= n; i ++) fac[i] = (ll)i * fac[i - 1] % ha; ifac[n] = inv(fac[n]); for(int i = n - 1; i &gt;= 0; i --) ifac[i] = (ll(i + 1)) * ifac[i + 1] % ha;&#125;ll C(int n, int m) &#123; if(n &lt; m) return 0; ll ret = fac[n] * ifac[n - m] % ha; ret = ret * ifac[m] % ha; return ret;&#125;const int maxn = 100005;const int maxm = 200005;std::vector&lt;int&gt; G[maxn];void add_edge(int u, int v) &#123; G[u].push_back(v);&#125;void ins_edge(int u, int v) &#123; add_edge(u, v); add_edge(v, u);&#125;int n, m, k;int bcnt = 0, clk = 0;int pre[maxn], bccno[maxn];int pn[maxm], en[maxm];using pii = std::pair&lt;int, int&gt;;int dfs(int x, int fa = -1) &#123; static std::stack&lt;pii&gt; S; int lowu = pre[x] = ++ clk; for(int v : G[x]) &#123; pii e = pii(x, v); if(!pre[v]) &#123; S.push(e); int lowv = dfs(v, x); lowu = std::min(lowu, lowv); if(lowv &gt;= pre[x]) &#123; bcnt ++; pn[bcnt] = en[bcnt] = 0; while(true) &#123; pii ee = S.top(); S.pop(); int a = ee.first, b = ee.second; en[bcnt] ++; if(bccno[a] != bcnt) pn[bcnt] ++, bccno[a] = bcnt; if(bccno[b] != bcnt) pn[bcnt] ++, bccno[b] = bcnt; if(a == x &amp;&amp; v == b) break; &#125; &#125; &#125; else if(v != fa &amp;&amp; pre[v] &lt; pre[x]) &#123; S.push(e); lowu = std::min(lowu, pre[v]); &#125; &#125; return lowu;&#125;void calc_bcc() &#123; for(int i = 1; i &lt;= n; i ++) &#123; if(!pre[i]) dfs(i); &#125;&#125;int gcd(int a, int b) &#123; if(!b) return a; else return gcd(b, a % b);&#125;ll calc(int x) &#123; if(en[x] == 1) &#123; return k; &#125; else if(en[x] == pn[x]) &#123; ll ret = 0; for(int i = 0; i &lt; en[x]; i ++) &#123; ret = (ret + pow_mod(k, gcd(i, en[x]))) % ha; &#125; ret = ret * inv(en[x]) % ha; return ret; &#125; else &#123; return C(en[x] + k - 1, k - 1); &#125;&#125;int main() &#123; process(); scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= m; i ++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); ins_edge(u, v); &#125; calc_bcc(); ll ans = 1LL; for(int i = 1; i &lt;= bcnt; i ++) &#123; ans = ans * calc(i) % ha; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>点-双连通分量</tag>
        <tag>Pólya定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC005F Many Easy Problems]]></title>
    <url>%2F2018%2F08%2F07%2Fagc005F%2F</url>
    <content type="text"><![CDATA[Description 有一棵\(n\)个点的树，假设有一个常数\(k(1\leq k\leq n)\)，我们从树中任意选出\(k\)个点（这样的方案数显然为\(\binom{n}{k}\)） ，并且选出这\(k\)个点之外的尽可能少的原树点使得这些点和那\(k\)个点的导出子图联通（显然这样的方案唯一），我们称这个导出子图的总点数为这个方案的价值。 对于每个\(k(1\leq k\leq n)\)，求出所有从树中选出\(k\)个点的方案的价值之和。 \(1\leq n\leq 200000\)，答案模\(924844033\)输出。 Solution ao秒啊，，， 如果考虑那个导出子图中点的贡献，是肥肠苦难滴。那么我们尝试转化成边的贡献。 注意到那个导出子图一定是一棵树，所以点数等于边数加一。那个加一最后做出的总贡献显然为\(\binom{n}{k}\)，因此我们接下来考虑处理边的贡献就行了。 但直接考虑边的贡献还是不可做滴，所以考虑使用补集转换，用所有情况减去不做贡献的情况。不做贡献的话那么选出的\(k\)个点一定在那条边的两侧。因此对于每条边，如果其一侧的子树大小为\(a\)，那么这条边对答案的贡献为\(\binom{n}{k} - \binom{a}{k} - \binom{n - a}{k}\)。 可是要对所有\(k\)都求一遍的话，全都DFS一遍非常的不现实。硬骨头在于减号后面的东西，其意义就是每一个边的一侧大小为\(a\)，那么就要在总答案里减去一个\(\binom{a}{k}\)。因此我们考虑把每个边两侧的子树大小都放到一个桶\(b\)里，其中\(b_i\)表示大小为\(i\)的子树出现了多少次。那么最后答案要在\(n\binom{n}{k}\)的基础上减去一个： \[ a_k = \sum_{i = 1}^n b_i\binom{i}{k} \] 但是这个东西不好递推也不好卷积，我们尝试两边乘\(k\)再整理整理： \[ a_kk!=\sum_{i = 1}^n b_ii!\cdot\frac{1}{(i - k)!} \] 然而这还是一个不好递推也不好卷积的东西……但是我们采用一种传统艺能：把一个串反过来。因此我们定义\(c_i = \frac{1}{(n - i)!}\)，这样原式就化成了： \[ a_kk!=\sum_{i = 1}^n b_ii!c_{n - i + k} \] 显然有\(n - i + k + i = n + k\)，因此这个物事就可以卷积力，，， 但是模数除了是质数以外，好像题里面也没告诉别的。但是通过WolframAlpha可以发现这个模数减一之后是\(2^{21}\)的倍数，并且这个模数本身有一个原根为\(5\)，所以是一个相当优秀的NTT模数。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;using ll = long long;const ll ha = 924844033;const ll bs = 5;ll pow_mod(ll a, ll b) &#123; ll ans = 1, res = a; while(b) &#123; if(1LL &amp; b) ans = ans * res % ha; res = res * res % ha; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow_mod(x, ha - 2LL);&#125;ll fac[200005], ifac[200005];void process() &#123; int n = 200000; fac[0] = 1; for(int i = 1; i &lt;= n; i ++) fac[i] = (ll)i * fac[i - 1] % ha; ifac[n] = inv(fac[n]); for(int i = n - 1; i &gt;= 0; i --) ifac[i] = (ll(i + 1)) * ifac[i + 1] % ha;&#125;ll C(int n, int m) &#123; if(n &lt; m) return 0; ll ret = fac[n] * ifac[n - m] % ha; ret = ret * ifac[m] % ha; return ret;&#125;int flip(int bi, int x) &#123; int ans = 0; for(int i = 0; i &lt; bi; i ++) &#123; if((1 &lt;&lt; i) &amp; x) &#123; ans |= (1 &lt;&lt; (bi - i - 1)); &#125; &#125; return ans;&#125;void NTT(ll *A, int bi, bool flag = false) &#123; int n = 1 &lt;&lt; bi; for(int i = 0; i &lt; n; i ++) &#123; int f = flip(bi, i); if(f &lt; i) std::swap(A[f], A[i]); &#125; for(int L = 1; L &lt; n; L &lt;&lt;= 1) &#123; ll xi_n = pow_mod(bs, (ha - 1LL) / (ll(L &lt;&lt; 1))); if(flag) xi_n = inv(xi_n); for(int i = 0; i &lt; n; i += (L &lt;&lt; 1)) &#123; ll xi = 1LL; for(int j = i; j &lt; i + L; j ++) &#123; ll x = A[j], y = A[j + L]; A[j] = (x + (y * xi) % ha) % ha; A[j + L] = (x - (y * xi) % ha + ha) % ha; xi = xi * xi_n % ha; &#125; &#125; &#125; if(flag) &#123; ll inv_n = inv(n); for(int i = 0; i &lt; n; i ++) A[i] = A[i] * inv_n % ha; &#125;&#125;std::vector&lt;int&gt; G[200005];void add_edge(int u, int v) &#123; G[u].push_back(v);&#125;void ins_edge(int u, int v) &#123; add_edge(u, v); add_edge(v, u);&#125;ll a[800005], b[800005]; int siz[200005], n;void dfs(int x, int fa = -1) &#123; siz[x] = 1; for(int v : G[x]) &#123; if(v != fa) &#123; dfs(v, x); b[siz[v]] ++; b[n - siz[v]] ++; siz[x] += siz[v]; &#125; &#125;&#125;int main() &#123; process(); scanf("%d", &amp;n); for(int i = 1; i &lt;= n - 1; i ++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); ins_edge(u, v); &#125; dfs(1); for(int i = 0; i &lt;= n; i ++) &#123; b[i] = b[i] * fac[i] % ha; a[i] = ifac[n - i]; &#125; int bi = 0, len = 1; while(len &lt;= 2 * n) &#123; bi ++; len &lt;&lt;= 1; &#125; NTT(a, bi); NTT(b, bi); for(int i = 0; i &lt; len; i ++) a[i] = a[i] * b[i] % ha; NTT(a, bi, true); for(int i = 1; i &lt;= n; i ++) &#123; ll ret = (ll)n * C(n, i) % ha; ret = (ret - a[n + i] * ifac[i] % ha + ha) % ha; printf("%lld\n", ret); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AtCoder</tag>
        <tag>多项式卷积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 1566 「NOI2009」管道取珠]]></title>
    <url>%2F2018%2F08%2F07%2FBZOJ1566%2F</url>
    <content type="text"><![CDATA[Description 有两个长度分别为\(n,m\)的珠子序列\(S,T\)，每种珠子可能是黑色或者白色，同色的珠子视为本质相同。 我们进行\(n + m\)次操作，每次从\(S,T\)中的一个的头部取出一个珠子，放到我们结果序列的尾部，这样能形成一个新的序列。定义两种方案不同，当且仅当存在一步使得这一步两种方案一个从\(S\)取一个从\(T\)取。那么我们假设最后可能的结果序列有\(k\)种，我们把他们用\(1\ldots k\)编号，假设\(a_k\)为编号为\(k\)的序列的操作方案数量，求： \[ \sum_{i = 1}^k a_i^2 \] \(n,m\leq 500\)。 Solution 那个平方是不是很不好处理啊…… 那么\(a_i\)一定可以表示为若干个\(1\)相加，每个\(1\)都代表了一种可以形成序列\(i\)的操作方案，平方之后这些\(1\)就会两两配对（参考二项式定理？）。 那么问题就转化成了求有多少对（可以相同也可以不相同的）操作序列可以生成同样的结果序列。这个DP一下就好力，，， Code 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;const int ha = 1024523;int d[2][505][505];char S[505], T[505];int main() &#123; int n, m; scanf("%d%d%s%s", &amp;n, &amp;m, S + 1, T + 1); d[0][0][0] = 1; for(int i = 1; i &lt;= n + m; i ++) &#123; int now = i &amp; 1; int pre = now ^ 1; memset(d[now], 0, sizeof(d[now])); for(int j = 0; j &lt;= i &amp;&amp; j &lt;= n; j ++) &#123; if(i - j &gt; m) continue; for(int k = 0; k &lt;= i &amp;&amp; k &lt;= n; k ++) &#123; if(i - k &gt; m) continue; int &amp;ans = d[now][j][k]; bool A0 = j &gt; 0, B0 = k &gt; 0; bool A1 = j &lt; i, B1 = k &lt; i; if(A0 &amp;&amp; B0 &amp;&amp; S[j] == S[k]) ans = (ans + d[pre][j - 1][k - 1]) % ha; if(A1 &amp;&amp; B1 &amp;&amp; T[i - j] == T[i - k]) ans = (ans + d[pre][j][k]) % ha; if(A0 &amp;&amp; B1 &amp;&amp; S[j] == T[i - k]) ans = (ans + d[pre][j - 1][k]) % ha; if(A1 &amp;&amp; B0 &amp;&amp; T[i - j] == S[k]) ans = (ans + d[pre][j][k - 1]) % ha;#ifdef LOCAL printf("d[%d][%d][%d] : %d\n", i, j, k, ans);#endif &#125; &#125; &#125; printf("%d\n", d[(n + m) &amp; 1][n][n]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>NOI</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AGC001E BBQ Hard]]></title>
    <url>%2F2018%2F08%2F06%2Fagc001E%2F</url>
    <content type="text"><![CDATA[Description 你有\(n\)个串，第\(i\)个串上有\(A_i\)块肉和\(B_i\)块菜。现在选出两个串，将他们中的肉和菜放在一起重新排列，求总方案数。 \(2\leq n\leq 200000, 1\leq A_i,B_i\leq 2000\)。 Solution 很显然对于两个串\(i, j\)，对答案的贡献是： \[ \binom{A_i + B_i + A_j + B_j}{A_i + A_j} \] 这个东西有什么组合意义吗？答案是有的。就是在一个平面上从原点走到\((A_i + A_j, B_i + B_j)\)，每次只向上或者向右走一格的方案数，然后我们把整个坐标系平移一下就可以把这个东西变成从\((-A_i, -B_i)\)走到\((A_j, B_j)\)。 然后我们建出所有的点，就是要我们求所有正点走到所有负点的方案数之和。这个东西很好DP，我们先把横纵坐标都加2000，然后根据到\((0, 0)\)的曼哈顿距离从小到大递推即可。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;utility&gt;using pii = std::pair&lt;int, int&gt;;const int ha = 1000000007;using ll = long long;ll pow_mod(ll a, ll b) &#123; ll ans = 1, res = a; while(b) &#123; if(1LL &amp; b) ans = ans * res % (ll)ha; res = res * res % (ll)ha; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow_mod(x, ha - 2);&#125;ll fac[10005], ifac[10005];void process() &#123; int n = 10000; fac[0] = 1; for(int i = 1; i &lt;= n; i ++) &#123; fac[i] = (fac[i - 1] * (ll(i))) % (ll)ha; &#125; ifac[n] = inv(fac[n]); for(int i = n - 1; i &gt;= 0; i --) &#123; ifac[i] = ifac[i + 1] * (ll(i + 1)) % (ll)ha; &#125;&#125;ll C(int x, int y) &#123; ll ret = fac[x]; ret = ret * ifac[x - y] % (ll)ha; ret = ret * ifac[y] % (ll)ha; return ret;&#125;pii P[200005]; int d[4005][4005];int n;int dp() &#123;#ifdef LOCAL puts("11111"); fflush(stdout);#endif for(int i = 1; i &lt;= n; i ++) &#123; int x = P[i].first, y = P[i].second; d[2000 - x][2000 - y] ++; &#125; for(int dis = 1; dis &lt;= 8000; dis ++) &#123; for(int i = std::max(0, dis - 4000); i &lt;= std::min(4000, dis); i ++) &#123; int j = dis - i; if(i &gt; 0) d[i][j] = (d[i][j] + d[i - 1][j]) % ha; if(j &gt; 0) d[i][j] = (d[i][j] + d[i][j - 1]) % ha; &#125; &#125;#ifdef LOCAL puts("Gou!"); fflush(stdout);#endif int ans = 0; for(int i = 1; i &lt;= n; i ++) &#123; int x = P[i].first, y = P[i].second; ans = (ans + d[x + 2000][y + 2000]) % ha; ans = (ans - C(2 * x + 2 * y, 2 * x) + ha) % ha; &#125; static const ll inv_2 = 500000004; ans = (((ll(ans)) * inv_2) % (ll)ha); return ans;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i ++) &#123; scanf("%d%d", &amp;P[i].first, &amp;P[i].second); &#125; process(); printf("%d\n", dp()); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4671 异或图]]></title>
    <url>%2F2018%2F08%2F06%2FBZOJ4671%2F</url>
    <content type="text"><![CDATA[Description 定义两个点数相同的图\(G_1,G_2\)的异或为一个新图\(G\)。\(G\)的点数和原来两个图一样，并且对于一条边\((i, j)\)，如果在\(G_1,G_2\)中的出现次数异或起来为\(1\)的话，那么\((i, j)\)会出现在\(G\)中，反之则不会出现。 给出\(s\)个有\(n\)个点的图\(G_1, G_2,\ldots,G_s\)，求这些图有多少个子集异或起来得到的图是一个联通图。 \(2\leq n\leq 10, 1\leq s\leq 60\)。 Solution 数数题，启动！ 恰好有一个连通块的情况是不好统计的，但是至少有一个连通块的情况很好统计。我们只需要枚举\(n\)个点的集合划分（\(B_{10} = 21147\)，所以不虚），保证不同集合之间没有边就行了。这样假设划出来了\(c\)个集合，那么最后的连通块数一定不小于\(c\)。 考虑不同集合之间没有边的条件如何处理。注意到这样就要求了包含这条边的图只用了偶数个，那么把所有这种条件列成一个方程组就是一个\(s\)元异或方程组。而我们知道一个\(s\)元异或方程组（假设其矩阵为\(A\)）的解数为\(2^{s - r(A)}\)，而\(r(A)\)就等于该矩阵的线性基数量，用线性基那一套传统艺能就可以求了。 然后我们现在只求出了至少\(c\)个连通块的方案，要想知道只有一个连通块的方案，势必要容斥一下。根据容斥系数那一套理论，我们要求右边的条件是\([n = 1]\)，因此容斥系数\(\mathrm{coef}_i\)应当满足： \[ \sum_{i = 1}^n \begin{Bmatrix}n\\i\end{Bmatrix}\mathrm{coef}_i = [n = 1] \] 使用打表等传统艺能可知\(\mathrm{coef}_i = (-1)^{i - 1}(i - 1)!\)，然后这题就做完力…… Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;bitset&gt;typedef long long ll;const int maxn = 12;const int maxs = 62;const int maxm = 60;ll lowbit(ll x) &#123; return x &amp; (-x);&#125;int n, m, s;ll L[maxn][maxn];ll M[maxm];ll gj() &#123; static ll bas[maxs]; std::fill(bas, bas + s, 0LL); int cnt = 0; for(int i = 1; i &lt;= m; i ++) &#123; ll x = M[i]; for(int j = s - 1; j &gt;= 0; j --) &#123; if(!((1LL &lt;&lt; (ll(j))) &amp; x)) continue; if(bas[j]) &#123; x ^= bas[j]; &#125; else &#123; cnt ++; bas[j] = x; break; &#125; &#125; &#125; return (1LL &lt;&lt; (ll(s - cnt)));&#125;int bel[maxn]; ll f[maxn];void dfs(int x, int cnt) &#123; if(x &gt; n) &#123; m = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = i + 1; j &lt;= n; j ++) &#123; if(bel[i] == bel[j]) continue; M[++ m] = L[i][j]; &#125; &#125; f[cnt] += gj(); return; &#125; for(int i = 1; i &lt;= cnt + 1; i ++) &#123; bel[x] = i; dfs(x + 1, std::max(i, cnt)); &#125;&#125;int main() &#123; scanf("%d", &amp;s); for(int i = 0; i &lt; s; i ++) &#123; char S[maxs]; scanf("%s", S); if(!n) &#123; int l = strlen(S); n = (1 + (int((sqrt(1 + 8 * l))))) / 2; &#125; int cnt = 0; for(int j = 1; j &lt;= n; j ++) &#123; for(int k = j + 1; k &lt;= n; k ++) &#123; if(S[cnt] == '1') &#123; L[j][k] ^= (1LL &lt;&lt; (ll(i))); &#125; cnt ++; &#125; &#125; &#125;#ifdef LOCAL printf("n : %d\n", n);#endif dfs(1, 0); ll ans = 0, fac = 1; for(int i = 1; i &lt;= n; i ++) &#123; ll delta = fac * f[i]; if(!(i &amp; 1)) delta *= -1LL;#ifdef LOCAL printf("delta(%d) : %lld\n", i, delta);#endif ans += delta; fac *= (ll)i; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>容斥原理</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 6076 「2017 山东一轮集训 Day6」三元组]]></title>
    <url>%2F2018%2F08%2F04%2Floj6076%2F</url>
    <content type="text"><![CDATA[Description 给定正整数\(a,b,c\)，求： \[ \sum_{i = 1}^a\sum_{j = 1}^b\sum_{k = 1}^c [i\perp j][i\perp k][j\perp k] \] \(a,b,c\leq 5\times 10^5\)。 Solution 下面钦点\(a\leq b\leq c\)。 \[ \begin{aligned} \quad&amp;\sum_{i = 1}^a\sum_{j = 1}^b\sum_{k = 1}^c [i\perp j][j\perp k][i\perp k]\\ =&amp;\sum_{i = 1}^a\sum_{j = 1,j\perp i}^b\sum_{k = 1,k\perp i}^c [j\perp k]\\ =&amp;\sum_{i = 1}^a\sum_{j = 1,j\perp i}^b\sum_{k = 1,k\perp i}^c \sum_{d | j, d | k}\mu(d)\\ =&amp;\sum_{i = 1}^a\sum_{d = 1, d\perp i}^b \mu(d)S_i(\lfloor\frac{b}{d}\rfloor)S_i(\lfloor\frac{c}{d}\rfloor) \end{aligned} \] 其中\(S_a(n)\)表示\([1, n]\)中和\(a\)互质的正整数数量。 后面那一块很显然可以整除分块罢……然后接下来我们需要考虑处理\([1, n]\)中和\(a\)互质的数的\(\mu\)和\(1\)的和，这个东西很显然可以用洲阁筛/Min_25筛的思想。考虑将\(i\)质因数分解为，其质因子有\(p_1, p_2,\ldots, p_k\)。定义状态\(f_i(n)\)表示\([1, n]\)中和前\(i\)个质因子互质的\(\mu\)的和，类似的用\(g_i(n)\)表示\(1\)的和。那么转移很显然是： \[ f_i(n) = f_{i - 1}(n) + f_i(\lfloor\frac{n}{p_i}\rfloor)\\ g_i(n) = g_{i - 1}(n) - g_{i - 1}(\lfloor\frac{n}{p_i}\rfloor) \] 考虑到状态全部是\(\lfloor\frac{n}{x}\rfloor\)的形式，所以我们要是对每个\(i\)都这么做一遍的话，每个\(i\)的总状态数（也是时间复杂度）就是\(O(\omega(i)\sqrt{i})\)。因此总的复杂度大约就是\(O(n\sqrt{n}\log n)\)，并且还很不满，看起来很稳是不是啊…… 然后我直接写了一个东西交上去，然后T到60……卡了卡常之后T到了80…… 然后注意到如果两个\(i\)的质因子构成是完全一致的话，那么他们对答案的贡献也就一样……所以我们再额外对这个东西记忆化一下，然后就能卡过去了。这之后有没有一个可以推出来的更紧的上界，我就不知道了……有没有先辈会算这个啊……有的话麻烦在评论区书一下qwq Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;unordered_map&gt;#include &lt;map&gt;#include &lt;stack&gt;const int N = 50005;int mu[N + 1], minp[N + 1];int prm[N + 1]; bool vis[N + 1];void sieve() &#123; int cnt = 0; mu[1] = 1; minp[1] = 1; vis[1] = true; for(int i = 2; i &lt;= N; i ++) &#123; if(!vis[i]) &#123; mu[i] = -1; minp[i] = i; prm[cnt ++] = i; &#125; for(int j = 0; j &lt; cnt; j ++) &#123; int v = i * prm[j]; if(v &gt; N) break; vis[v] = true; minp[v] = prm[j]; if(i % prm[j] == 0) &#123; mu[v] = 0; break; &#125; else &#123; mu[v] = -mu[i]; &#125; &#125; &#125; for(int i = 1; i &lt;= N; i ++) &#123; mu[i] += mu[i - 1]; &#125;&#125;using ll = long long;using ull = unsigned long long;const ll ha = 1000000007LL;const int maxn = 50005;int p[16], pcnt;const int INF = 0x7f7f7f7f;int ma[16][maxn]; int st1[16][maxn], top1[16];int calc_S(int c, int n) &#123; if(c == 0) return n; if(n == 0) return 0; if(ma[c][n] != INF) return ma[c][n]; st1[c][top1[c] ++] = n; int ret = (calc_S(c - 1, n) - calc_S(c - 1, n / p[c])); ma[c][n] = ret; return ret;&#125;int ma_mu[16][maxn]; int st2[16][maxn], top2[16];int calc_mu(int c, int n) &#123; if(c == 0) return (mu[n]); if(n == 0) return 0; if(ma_mu[c][n] != INF) return ma_mu[c][n]; st2[c][top2[c] ++] = n; int ret = (calc_mu(c - 1, n) + calc_mu(c, n / p[c])); ma_mu[c][n] = ret; return ret;&#125;ll sqr(ll x) &#123; ll ret = 1; while((ret + 1LL) * (ret + 1LL) &lt;= x) ret ++; return ret;&#125;const ull seed = 200261ULL;int main() &#123; sieve(); int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); if(a &gt; b) std::swap(a, b); if(a &gt; c) std::swap(a, c); if(b &gt; c) std::swap(b, c); static int rec[50005]; memset(rec, -1, sizeof(rec)); memset(ma, 0x7f, sizeof(ma)); memset(ma_mu, 0x7f, sizeof(ma_mu)); ll ans = 0; for(int i = 1; i &lt;= a; i ++) &#123; pcnt = 0; int u = i; while(u &gt; 1) &#123; int tp = minp[u]; p[++ pcnt] = tp; while(u % tp == 0) u /= tp; &#125; int hs = 1; for(int i = 1; i &lt;= pcnt; i ++) &#123; hs *= p[i]; &#125; if(rec[hs] != -1) &#123; ans = (ans + (ll)rec[hs]) % ha; continue; &#125; ll las = 0, ret = 0LL; for(int j = 1; j &lt;= b;) &#123; int next = std::min(b / (b / j), c / (c / j)); ll th = calc_mu(pcnt, next); // th = (th + ha) % ha; ll delta = (th - las + ha) % ha; delta = (delta * (ll)calc_S(pcnt, b / j)); delta = (delta * (ll)calc_S(pcnt, c / j)) % ha; ret = (ret + delta); if(ret &gt; ha) ret -= ha; las = th; j = next + 1; &#125; for(int j = 1; j &lt;= pcnt; j ++) &#123; while(top1[j] &gt; 0) &#123; int p = st1[j][-- top1[j]]; ma[j][p] = INF; &#125; while(top2[j] &gt; 0) &#123; int p = st2[j][-- top2[j]]; ma_mu[j][p] = INF; &#125; &#125; rec[hs] = ret; ans = (ans + ret) % ha; &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Min_25筛</tag>
        <tag>洲阁筛</tag>
        <tag>LibreOJ</tag>
        <tag>山东省队集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 2219 数论之神]]></title>
    <url>%2F2018%2F08%2F04%2FBZOJ2219%2F</url>
    <content type="text"><![CDATA[Description 给定正整数\(A, B, K\)，求方程\(x^A\equiv B\pmod{2K+1}\)在\(Z_{2K+1}\)中的解的数量。 多组询问，组数不超过1000。 \(1\leq A,B\leq 10^9, 1\leq K\leq 5\times 10^8\)。 Solution 算是一道综合性很强的题目了…… 先将模数分解质因数，对每一种质因子幂单独求解，然后由中国剩余定理之类的知道最后的解数是每一部分的解数的积。 那么考虑每种质因子的幂\(m=p^c\)的解数。先把\(B\)取下模，要是\(B = 0\)的话那么\(x\)是\(p^{\lceil\frac{c}{A}\rceil}\)的倍数就行了，因此答案是\(p^{c-\lceil\frac{c}{A}\rceil}\)。 那么考虑\(B\neq 0\)的情况。你可以对两边取指标（因为\(m\)事奇质数的幂，所以一定有原根，原根当然很好找了），就得到了\(A\mathrm{ind}x\equiv\mathrm{ind}B\pmod{\varphi(m)}\)，然后根据线性同余方程那套理论，假设\(d=\gcd(A,\varphi(m))\)，如果\(d|\mathrm{ind}B\)才有解，且解的数量为\(d\)。 但是有一个问题就是可能有\(\gcd(B, m)&gt;1\)，这样的话\(\mathrm{ind}B\)就不一定存在。那么我们在原始的式子里，把两边疯狂除\(p\)直到右边没有\(p\)了，那么假设\(B=p^su\)，那么可知新的方程为\(\frac{x^A}{p^s}\equiv u\pmod{p^{c - s}}\)。可以发现如果\(A\)不是\(s\)的因子的话那么凉了，要是是的话假设\(s = At\)，那么新的方程也可以写作\((\frac{x}{p^t})^A\equiv u\pmod{p^{c - s}}\)，这样的话就得到了一个新的方程，且\(u\)和现在的模数是互质的，因此可以直接用上面的方法做。需要注意的是我们现在只是求出了模\(p^{c-s}\)的解数，对应到\(p^c\)要乘上\(p^s\)。但是解肯定要乘上一个\(p^t\)，因此解数还要在除一下\(p^t\)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cassert&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;tr1/unordered_map&gt;typedef long long ll;ll gcd(ll a, ll b) &#123; if(!b) &#123; return a; &#125; else &#123; return gcd(b, a % b); &#125;&#125;void exgcd(ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y) &#123; if(!b) &#123; d = a; x = 1; y = 0; &#125; else &#123; ll nx, ny; exgcd(b, a % b, d, nx, ny); x = ny; y = nx - ny * (a / b); &#125;&#125;ll inv(ll v, ll p) &#123; ll d, x, y; exgcd(v, p, d, x, y); return (x + p) % p;&#125;ll pow_mod(ll a, ll b, ll p) &#123; ll ans = 1, res = a; while(b) &#123; if(1LL &amp; b) ans = ans * res % p; res = res * res % p; b &gt;&gt;= 1; &#125; return ans;&#125;void desc(ll x, std::vector&lt;int&gt; &amp;V) &#123; ll bd = floor(sqrt((double)x) + 0.5); for(ll i = 2; i &lt;= bd; i ++) &#123; if(x % i == 0LL) &#123; V.push_back(i); while(x % i == 0LL) x /= i; &#125; &#125; if(x &gt; 1LL) V.push_back(int(x));&#125;ll find_g(ll p, ll phi, std::vector&lt;int&gt; &amp;V) &#123; if(p == 2LL) return 1; for(ll i = 2; i &lt; p; i ++) &#123; bool ok = true; for(int j = 0; j &lt; V.size(); j ++) &#123; ll c = phi / (ll)V[j]; if(pow_mod(i, c, p) == 1LL) &#123; ok = false; break; &#125; &#125; if(ok) return i; &#125; return -1LL;&#125;ll bsgs(ll a, ll b, ll p) &#123; if(a == 0LL) &#123; return (b == 0LL) ? 1LL : -1LL; &#125; int bd = ceil(sqrt((double)p)); std::tr1::unordered_map&lt;ll, ll&gt; ma; ll blk = 1LL; for(int i = 0; i &lt; bd; i ++) &#123; if(!ma.count(blk)) ma[blk] = i; blk = blk * a % p; &#125; ll bs = 1LL; blk = inv(blk, p); for(int i = 0; (ll)i * (ll)bd &lt; p; i ++) &#123; ll th = b * bs % p; if(ma.count(th)) return ma[th] + i * bd; bs = bs * blk % p; &#125; assert(false); return -1;&#125;ll equation(ll a, ll b, ll p) &#123; ll ret = gcd(a, p); if(b % ret != 0LL) return 0; else return ret;&#125;ll solve(ll a, ll b, ll mod, ll p, ll c) &#123; if(b == 0LL) &#123; ll ret = ceil((double(c)) / (double(a))); return pow_mod(p, c - ret, 2000000007LL); &#125; else &#123; if(b % p == 0LL) &#123; ll nc = 0; while(b % p == 0LL) nc ++, b /= p, mod /= p; if(nc % a != 0LL) return 0LL; ll t = nc / a; return solve(a, b, mod, p, c - nc) * pow_mod(p, (a - 1LL) * t, 2000000007LL); &#125; else &#123; ll phi = mod / p * (p - 1LL); std::vector&lt;int&gt; d_phi; desc(phi, d_phi); ll g = find_g(mod, phi, d_phi); return equation(a, bsgs(g, b, mod), phi); &#125; &#125;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T --) &#123; int a, b, k; scanf("%d%d%d", &amp;a, &amp;b, &amp;k); k = 2 * k + 1; int bd = floor(sqrt((double)k) + 0.5); int ans = 1; for(int i = 2; i &lt;= bd; i ++) &#123; if(k % i == 0) &#123; int c = 0, mod = 1; while(k % i == 0) k /= i, c ++, mod *= i; ans *= solve(a, b % mod, mod, i, c); &#125; &#125; if(k &gt; 1) ans *= solve(a, b % k, k, k, 1); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>BSGS</tag>
        <tag>原根</tag>
        <tag>指标</tag>
        <tag>同余方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 2014 「SCOI2016」萌萌哒]]></title>
    <url>%2F2018%2F08%2F02%2Floj2014%2F</url>
    <content type="text"><![CDATA[Description 有一个长度为\(n\)的无前导零数字串。 现在给你\(m\)组信息，形如\((a,b,c,d)\)（保证\(a\leq b, c\leq d,b - a = d - c\)），表示数字串\(a\ldots b\)这一段子串和\(c\ldots d\)这一段子串是一样的。 求最后的数字串有多少种可能。 \(1\leq n, m\leq 10^5, 1\leq a,b,c,d\leq n\)。 Solution ao劲啊这种题，，， 肯定要上并查集辣……但是暴力建图一定会炸，线段树优化建图在这也不好用（两边子树的形态可能差异巨大）。那么考虑用倍增优化建图。 建出形如\(v(i, j)\)的点表示从\(i\)开始长度为\(2^j\)的子串。然后这样用类似于ST表的方式就可以处理所有信息了，具体方式就是把对应的两组点在并查集上连一下。 然后考虑最后如何统计答案。这个也不难，你把并查集的关系逐层往下推就行。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int maxn = 100005;const int maxs = maxn * 17;using ll = long long;const ll ha = 1000000007LL;ll pow_mod(ll a, ll b) &#123; ll ans = 1LL, res = a; while(b) &#123; if(1LL &amp; b) ans = ans * res % ha; res = res * res % ha; b &gt;&gt;= 1; &#125; return ans;&#125;int p[maxs], rk[maxs];void init_set(int s) &#123; for(int i = 1; i &lt;= s; i ++) &#123; p[i] = i; rk[i] = 0; &#125;&#125;int get_fa(int x) &#123; if(p[x] == x) &#123; return x; &#125; else &#123; return (p[x] = get_fa(p[x])); &#125;&#125;void link_set(int x, int y) &#123; if(rk[x] &gt; rk[y]) std::swap(x, y); p[x] = y; if(rk[x] == rk[y]) rk[y] ++;&#125;void merge_set(int x, int y) &#123; x = get_fa(x); y = get_fa(y); if(x != y) link_set(x, y);&#125;int n, cnt;int lst[maxn];int num[maxn][17], lc[maxs], rc[maxs];void process() &#123; lst[1] = 0; for(int i = 2; i &lt;= n; i ++) &#123; lst[i] = lst[i - 1]; while((1 &lt;&lt; (lst[i] + 1)) &lt;= i) lst[i] ++; &#125; cnt = 0; for(int j = 0; (1 &lt;&lt; j) &lt;= n; j ++) &#123; for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i ++) &#123; num[i][j] = ++ cnt; if(j &gt; 0) &#123; lc[cnt] = num[i][j - 1]; rc[cnt] = num[i + (1 &lt;&lt; (j - 1))][j - 1]; &#125; &#125; &#125; init_set(cnt);&#125;void update(int a, int b, int c, int d) &#123; int g = lst[b - a + 1];#ifdef LOCAL printf("Operation (%d, %d, %d, %d) %d\n", a, b, c, d, g);#endif merge_set(num[a][g], num[c][g]); merge_set(num[b - (1 &lt;&lt; g) + 1][g], num[d - (1 &lt;&lt; g) + 1][g]);&#125;int main() &#123; int m; scanf("%d%d", &amp;n, &amp;m); process(); while(m --) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); update(a, b, c, d); &#125; for(int i = cnt; i &gt; n; i --) &#123; int fa = get_fa(i); merge_set(lc[i], lc[fa]); merge_set(rc[i], rc[fa]); &#125; int blk = 0; for(int i = 1; i &lt;= n; i ++) &#123; if(get_fa(i) == i) blk ++; &#125; ll ans = 9LL * pow_mod(10LL, blk - 1) % ha; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LibreOJ</tag>
        <tag>SCOI</tag>
        <tag>倍增</tag>
        <tag>倍增优化建图</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛23]]></title>
    <url>%2F2018%2F07%2F28%2FNCTraining25%2F</url>
    <content type="text"><![CDATA[昨晚打了一场比赛……感觉不太难的？（E题除外） 还事撸一篇题解罢？ A Description 懒得写了……（逃 Solution 贪心且尽量选最大的，然后没了…… Code 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;int v1[7] = &#123;100, 50, 20, 10, 5, 2, 1&#125;;int v2[6] = &#123;50, 20, 10, 5, 2, 1&#125;;int main() &#123; int T; scanf("%d", &amp;T); while(T --) &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); for(int i = 0; i &lt; 7; i ++) &#123; int g = a / v1[i]; if(i &gt; 0) putchar(' '); printf("%d", g); a -= v1[i] * g; &#125; for(int i = 0; i &lt; 6; i ++) &#123; int g = b / v2[i]; printf(" %d", g); b -= v2[i] * g; &#125; puts(""); &#125; return 0;&#125; B Description 还事懒得写……（逃 Solution 如果你自己试过的话会发现尽量均分事很合理的……证明啥的画画函数图像就行了（逃 Code 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;using ll = long long;std::unordered_map&lt;int, ll&gt; ma;ll dp(int n) &#123; if(n == 1) return 0; if(ma.count(n)) return ma[n]; ll x = n / 2; ll y = n - x; ll ret = x * y + dp(x) + dp(y); ma[n] = ret; return ret;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T --) &#123; int n; scanf("%d", &amp;n); printf("%lld\n", dp(n)); &#125; return 0;&#125; C Description 给定一自然数序列\(a\)，选出一个子序列\(b\)使得\(b\)中所有元素按位与的lowbit尽可能大。要求你输出这个\(b\)。 此外，如果有多解那么取一个\(b\)尽可能长的。 \(n\leq 10^5,a_i&lt;2^{31}\)。 Solution 我们可以枚举那个lowbit是哪一位，然后我们至少要保证\(b\)中每个元素都含有这一位。 然后我们要求按位与起来更低的位都要是0。然后我们知道参与按位与运算的元素越多，每一位就不可能会变大。那么只要取出所有含有我们要求的那一位元素构成\(b\)，还是有更低位元素为1的话，那么我们枚举的这一位就一定不是答案了。 更好的性质是，这种方法是一定能保证\(b\)尽可能长的。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;climits&gt;int lowbit(int x) &#123; return x &amp; (-x);&#125;const int maxn = 100005;int a[maxn];int main() &#123; int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i ++) &#123; scanf("%d", &amp;a[i]); &#125; int ans = 0; for(int j = 0; j &lt;= 30; j ++) &#123; int sv = INT_MAX; for(int i = 1; i &lt;= n; i ++) &#123; if((1 &lt;&lt; j) &amp; a[i]) sv &amp;= a[i]; &#125; if(sv != 0 &amp;&amp; lowbit(sv) &gt;= (1 &lt;&lt; j)) &#123; ans = std::max(ans, (1 &lt;&lt; j)); &#125; &#125; if(ans == 0) &#123; puts("0"); return 0; &#125; std::vector&lt;int&gt; vec; for(int i = 1; i &lt;= n; i ++) &#123; if(a[i] &amp; ans) &#123; vec.push_back(a[i]); &#125; &#125; printf("%d\n", vec.size()); for(int i = 0; i &lt; vec.size(); i ++) &#123; if(i &gt; 0) putchar(' '); printf("%d", vec[i]); &#125; puts(""); return 0;&#125; D Description 给你一个由\(a\ldots i\)为组成字符的字符串\(S\)（\(|S|\leq 3000\)），求有多少abcdefghi的排列使得该排列为\(S\)的子序列。 Solution 我们考虑枚举排列再判定吧。 我们直接搞出来\(S\)的子序列自动机，然后再扔进去一遍就行了。子序列自动机也不难，你每个点的每种字符的边往他后面第一次这个字符出现的地方连就行。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;const int maxn = 3005;int go[maxn][9]; int n;char S[maxn]; int las[9];void process() &#123; for(int i = n; i &gt;= 0; i --) &#123; memcpy(go[i], las, sizeof(las)); if(i &gt; 0) las[S[i] - 'a'] = i; &#125;&#125;bool check(char *s) &#123; int l = strlen(s); int u = 0; for(int i = 0; i &lt; l; i ++) &#123; int c = s[i] - 'a'; if(!go[u][c]) return false; u = go[u][c]; &#125; return true;&#125;char s[10] = "abcdefghi";int main() &#123; scanf("%s", S + 1); n = strlen(S + 1); process(); int ans = 0; do &#123; if(check(s)) ans ++; &#125; while(std::next_permutation(s, s + 9)); printf("%d\n", ans); return 0;&#125; E Description 给定正整数\(n, x\)，要你求一个最大的\(b\)满足\(1&lt;b&lt;x\)，且在\(b\)进制下存在一个长为\(n\)的正整数\(a\)（允许有前导0），满足把\(a\)的\(b\)进制表示看成一个序列之后，做出来的\(n\)种循环位移互不相同，且分别可以由\(a\cdot l(1\leq l\leq n)\)得到。 \(n\leq 5\cdot 10^6,x\leq 10^9\)。 Solution 可以书事最难的题力，，， 我们考虑那个\(a\)吧，就当\(b = 10, a = 142857\)来说，构造一个小数\(c\)满足： \[ c = 0.\overline{142857} \] 这个东西既然是个小数，那么一定可以表示为一个分数\(\frac{p}{q}(p\perp q)\)。然后我们发现如果\(a\)合法，那么\(a\cdot b^l(0\leq l &lt; n)\)的小数部分组成的集合和\(a\cdot l(1\leq l\leq n)\)组成的集合事完全一致的。 小数部分显然只会由分子模\(q\)的结果决定，那么上面的结论就等价于\(p\cdot b^l(0\leq l &lt; n)\)组成的集合和\(p\cdot l(1\leq l\leq n)\)组成的集合事一致的。而\(p^{-1}\bmod{q}\)存在，那么给两个集合都乘上这玩意，那么就得到了\(b^l(0\leq l &lt; n)\)和\(l(1\leq l\leq n)\)，然后就会发现\(b\)的这若干次幂和\(Z_{n + 1}\)中的正数一一对应……换言之\(b\)为\(n + 1\)的原根且\(n + 1\)必须为质数。 找原根的话直接枚举判定就行了……要知道原根很密集的（逃 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;queue&gt;#include &lt;set&gt;const int N = 10000000;int phi[N + 5], minp[N + 5];int prm[N + 5]; bool vis[N + 5];void sieve() &#123; phi[1] = 1; vis[1] = true; int cnt = 0; for(int i = 2; i &lt;= N; i ++) &#123; if(!vis[i]) &#123; phi[i] = i - 1; minp[i] = i; prm[cnt ++] = i; &#125; for(int j = 0; j &lt; cnt &amp;&amp; prm[j] &lt;= N / i; j ++) &#123; int v = i * prm[j]; if(v &gt; N) break; vis[v] = true; minp[v] = prm[j]; if(i % prm[j] == 0) &#123; phi[v] = phi[i] * prm[j]; break; &#125; else &#123; phi[v] = phi[i] * phi[prm[j]]; &#125; &#125; &#125;&#125;using ll = long long;ll pow_mod(ll a, ll b, ll p) &#123; ll ans = 1, res = a % p; while(b) &#123; if(1LL &amp; b) ans = (ans * res) % p; res = (res * res) % p; b &gt;&gt;= 1; &#125; return ans;&#125;bool has_phi(int x) &#123; return !vis[x];&#125;std::vector&lt;int&gt; V;void desc(int x) &#123; while(x &gt; 1) &#123; int p = minp[x]; V.push_back(p); while(x % p == 0) x /= p; &#125;&#125;bool check(int x, int t, int p) &#123; for(int v : V) &#123; ll ans = pow_mod(x, t / v, p); if(ans == 1LL) return false; &#125; return true;&#125;int gcd(int a, int b) &#123; if(!b) return a; else return gcd(b, a % b);&#125;int main() &#123; sieve(); int n, x; scanf("%d%d", &amp;n, &amp;x); if(x &lt;= 2 || vis[n + 1]) &#123; puts("-1"); return 0; &#125;/* if(n == 1) &#123; printf("%d\n", x - 1); return 0; &#125;*/ int p = n + 1; int t = n; desc(t); bool ok = false; for(int i = x - 1; i &gt; 1; i --) &#123; if((gcd(i, p) == 1) &amp;&amp; check(i, t, p)) &#123; printf("%d\n", i); ok = true; break; &#125; &#125; if(!ok) puts("-1"); return 0;&#125; F Description 给一颗\(n\)个点的以1为根的树，每次随机选择剩下点中的一个将其子树删掉，等没点了游戏终止。 求期望删除次数。 Solution 怎么感觉是一道经典题…… 根据期望线性性，我们考虑每个点对答案的贡献。 每个点首先他和他祖先中势必会有一个点被删除，要是祖先被删了那也没它什么戏了。 所以在它做出贡献时必定他和他祖先都在，然后删了它。无论是在什么情况下，他被删了他祖先却没被动的概率都是\(\frac{1}{d}\)（其中\(d\)为他和他祖先的数量）。 然后加起来就好了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;using ll = long long;const ll ha = 998244353LL;ll pow_mod(ll a, ll b) &#123; ll ans = 1, res = a; while(b) &#123; if(1LL &amp; b) ans = (ans * res) % ha; res = (res * res) % ha; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow_mod(x, ha - 2LL);&#125;std::vector&lt;int&gt; G[100005];void ins_edge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u);&#125;ll dfs(int x, int fa, int depth) &#123; ll ret = inv(depth); for(auto v : G[x]) &#123; if(v != fa) &#123; ret = (ret + dfs(v, x, depth + 1)) % ha; &#125; &#125; return ret;&#125;int main() &#123; int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n - 1; i ++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); ins_edge(u, v); &#125; printf("%lld\n", dfs(1, -1, 1)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>原根</tag>
        <tag>NowCoder</tag>
        <tag>贪心</tag>
        <tag>子序列自动机</tag>
        <tag>位运算</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀XXX可持久化大坑]]></title>
    <url>%2F2018%2F07%2F25%2Fsuffix%2F</url>
    <content type="text"><![CDATA[我谔谔，我今天才学的后缀数组（之前只会后缀自动机）。 然后就想开个后缀家族大坑？ 后缀数组 介绍 虽然说可能在各位巨佬眼里这已经是烂大街的东西了……但我现在才会（逃 思想很简单吧，对于原串的所有后缀排个序（按字典序升序），形成了一个数组\(\mathrm{sa}\)，就叫做后缀数组，方便起见定义\(\mathrm{rk}[i]\)表示\(i\ldots n\)这一段后缀在\(\mathrm{sa}\)中的排名。 然后考虑怎么求这玩意吧…… 倍增排序求SA 如果直接按照定义，快排加暴力比较弄的话，\(O(n^2\log n)\)的复杂度没什么用（其实有个比较贱的方法事你可以预处理哈希然后二分比较两个后缀就匪快了）。 我们考虑采取倍增的思想，依次比较各个后缀的长度为\(1,2,4,8,16,\ldots\)的前缀，这样的话总是可以比较出最后的结果。 更大的好处是，假如我们已经有了\(2^t\)下的答案，我们要对\(2^{t + 1}\)的情况排序。那么每个后缀我们可以直接视为一个二元组\((a, b)\)，其中\(a,b\)分别是\(2^t\)下的排名。 这样的话我们可以直接用这种思想套上快排，复杂度\(O(n\log^2 n)\)。但观察到二元组的两元的值域都不超过\(n\)，所以把快排改成桶排，这样复杂度就是\(O(n\log n)\)的了。 然后更多细节参考代码吧。 SA的应用：height数组 这样看的话SA好像没啥用处？ 我们定义一个\(\mathrm{height}[i]\)表示排名为\(i\)的后缀和他的上一名的LCP。如果你学过后缀树的话，你会发现把后缀树的叶子按照对应后缀字典序排序一下，然后这个\(\mathrm{height}\)就是每个叶子和他左侧的叶子的LCA的深度。 直接按照定义求这玩意显然复杂度\(O(n^2)\)，难以接受。然后我们定义\(h(i) = \mathrm{height}[\mathrm{rk}[i]]\)，然后我们发现有： \[ h(i)\geq h(i - 1) - 1 \] 证明的话考虑\(h(i - 1)\geq 1\)的情况就行了。我们假设\(a = i - 1, b = \mathrm{sa}[\mathrm{rk}[a] - 1]\)，那么若\(h(i - 1)\geq 1\)，那么我们把两者截去开头一个字符还会得到两个新的后缀\(a&#39;,b&#39;\)，注意到有\(a&#39; = i, b&#39; = b + 1\)，且\(\mathbf{LCP}(a&#39;,b&#39;) = h(i - 1) - 1\)，考虑到字典序意义上\(a &gt; b\)，那么显然字典序意义下也有\(i &gt; b + 1\)，那么说明\(\mathrm{rk}[i] - 1\leq b + 1\)，因此\(\mathrm{sa}[\mathrm{rk}[i] - 1]\)在排序后的后缀树中一定不会比\(b + 1\)离\(i\)更远，换言之\(\mathrm{sa}[\mathrm{rk}[i] - 1]\)和\(i\)在树中的LCA深度（也就是串中的LCP大小）不会小于\(h(i - 1) - 1\)。 根据这个东西，就可以很轻松的\(O(n)\)求出\(\mathrm{height}\)数组了。 题目 POJ 2774 Long Long Message Description 给两个串，求两者的最长公共子串。 两个串的长度都不超过100000。 Solution 考虑把两个串强行接在一起（顺便中间加上一个特殊字符作为分隔符以防越界），那么两者的公共子串一定是某两个在分隔符两端的后缀的公共前缀，而我们要取出最长的情况。 那么我们按照\(\mathrm{sa}\)的顺序扫描所有后缀，如果出现相邻两个后缀在分隔符两侧，那就取他们的\(\mathrm{height}\)值更新答案即可。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;int idx(char c) &#123; if(c == '$') &#123; return 27; &#125; else &#123; return c - 'a' + 1; &#125;&#125;const int maxn = 200005;char S[maxn]; int sz;int sa[maxn], rk[maxn], height[maxn];void process() &#123; static int fir[maxn], sec[maxn]; static int buf[maxn], tmp[maxn]; for(int i = 1; i &lt;= sz; i ++) buf[idx(S[i])] ++; for(int i = 1; i &lt;= 27; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) rk[i] = buf[idx(S[i]) - 1] + 1; for(int t = 1; t &lt;= sz; t &lt;&lt;= 1) &#123; for(int i = 1; i &lt;= sz; i ++) &#123; fir[i] = rk[i]; sec[i] = (i + t &gt; sz) ? 0 : rk[i + t]; &#125; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[sec[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) tmp[buf[sec[i]] --] = i; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[fir[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = sz; i &gt;= 1; i --) &#123; int j = tmp[i]; sa[buf[fir[j]] --] = j; &#125; bool unique = true; for(int i = 1, las = 0; i &lt;= sz; i ++) &#123; int j = sa[i]; if(!las) &#123; rk[j] = 1; &#125; else &#123; if(fir[j] == fir[las] &amp;&amp; sec[j] == sec[las]) &#123; unique = false; rk[j] = rk[las]; &#125; else &#123; rk[j] = rk[las] + 1; &#125; &#125; las = j; &#125; if(unique) break; &#125; for(int i = 1, k = 0; i &lt;= sz; i ++) &#123; if(rk[i] == 1) &#123; k = 0; &#125; else &#123; if(k &gt; 0) k --; int j = sa[rk[i] - 1]; while(i + k &lt;= sz &amp;&amp; j + k &lt;= sz &amp;&amp; S[i + k] == S[j + k]) k ++; &#125; height[rk[i]] = k; &#125;&#125;int s1, s2;int solve() &#123; process(); int ans = 0; for(int i = 2; i &lt;= sz; i ++) &#123; int a = sa[i], b = sa[i - 1]; bool v1 = a &lt;= s1, v2 = b &lt;= s1; if(v1 ^ v2) &#123; ans = std::max(ans, height[i]); &#125; &#125; return ans;&#125;int main() &#123; scanf("%s", S + 1); s1 = strlen(S + 1); S[s1 + 1] = '$'; scanf("%s", S + s1 + 2); sz = strlen(S + 1); printf("%d\n", solve()); return 0;&#125; POJ 1743 Musical Theme Description 给一个由\([1, 88]\)中整数组成的数字串，要求取出两个长度相等的不重叠子串。要求： 两个串的长度都大于5。 一个子串可以通过整体加上一个整数得到另一个子串。 最大化取出子串的长度。 多组数据，串长不超过20000。 Solution 算事经典套路题了……一直知道但一直没做 首先第二个条件很鬼畜，我们考虑做一些转化搞掉它。我们直接把序列差分，这样的话除了第一项其他都能匹配（要考虑一下整个序列的第一项怎么处理啊，这个参考代码吧）。 先讲个比较逊的做法……很显然这个东西的答案具有单调性，那么考虑二分答案。 然后考虑该怎么判定答案。考虑当前二分答案为\(k\)，然后我们对于所有\(\mathrm{height}[i]\geq k\)，我们都可以合并\(\mathrm{sa}[i - 1]\)和\(\mathrm{sa}[i]\)（也就是说可能可以由这两个后缀产生答案，并且这种关系很显然具有传递性），那么就相当于除了\(\mathrm{height}[i] &lt; k\)的情况被“断开”了，其他地方都已经分别连在一块了。那么每一块都是可能在块内产生答案（但不可能和块外产生答案），如果说某个块中最长后缀和最短后缀的差不小于\(k\)，那么说明该块可以取出两个不重叠的长度不小于\(k\)的后缀的前缀，因此\(k\)合法。反之\(k\)不合法。 这样复杂度很显然事\(O(n\log n)\)的，可以通过此题。 然后我们考虑那个二分答案其实不需要的……我们可以用并查集来维护块。我们每个块都维护块中最长后缀和最短后缀，刚开始每个点都是自己一块。从大到小枚举所有\(\mathrm{height}[i]\)的值，然后去合并块。每次合并出新的块的时候我们判一下是否有合法答案就行了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;const int maxn = 200005;int S[maxn]; int sz;int sa[maxn], rk[maxn], height[maxn];void process() &#123; static int fir[maxn], sec[maxn]; static int buf[maxn], tmp[maxn]; std::fill(buf, buf + 1 + sz, 0); for(int i = 1; i &lt;= sz; i ++) buf[S[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) rk[i] = buf[S[i] - 1] + 1; for(int t = 1; t &lt;= sz; t &lt;&lt;= 1) &#123; for(int i = 1; i &lt;= sz; i ++) &#123; fir[i] = rk[i]; sec[i] = (i + t &gt; sz) ? 0 : rk[i + t]; &#125; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[sec[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) tmp[buf[sec[i]] --] = i; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[fir[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = sz; i &gt;= 1; i --) &#123; int j = tmp[i]; sa[buf[fir[j]] --] = j; &#125; bool unique = true; for(int i = 1, las = 0; i &lt;= sz; i ++) &#123; int j = sa[i]; if(!las) &#123; rk[j] = 1; &#125; else &#123; if(fir[j] == fir[las] &amp;&amp; sec[j] == sec[las]) &#123; unique = false; rk[j] = rk[las]; &#125; else &#123; rk[j] = rk[las] + 1; &#125; &#125; las = j; &#125; if(unique) break; &#125; for(int i = 1, k = 0; i &lt;= sz; i ++) &#123; if(rk[i] == 1) &#123; k = 0; &#125; else &#123; if(k &gt; 0) k --; int j = sa[rk[i] - 1]; while(i + k &lt;= sz &amp;&amp; j + k &lt;= sz &amp;&amp; S[i + k] == S[j + k]) k ++; &#125; height[rk[i]] = k; &#125;&#125;int p[maxn], pd[maxn];int minv[maxn], maxv[maxn];void init_set() &#123; for(int i = 1; i &lt;= sz; i ++) &#123; p[i] = i; minv[i] = maxv[i] = sa[i]; pd[i] = 0; &#125;&#125;int get_fa(int x) &#123; if(p[x] == x) &#123; return x; &#125; else &#123; return (p[x] = get_fa(p[x])); &#125;&#125;void link_set(int x, int y) &#123; if(pd[x] &gt; pd[y]) std::swap(x, y); p[x] = y; minv[y] = std::min(minv[y], minv[x]); maxv[y] = std::max(maxv[y], maxv[x]); if(pd[x] == pd[y]) pd[y] ++;&#125;void merge_set(int x, int y) &#123; x = get_fa(x), y = get_fa(y); if(x != y) link_set(x, y);&#125;int solve() &#123; static std::vector&lt;int&gt; V[maxn]; process(); init_set(); for(int i = 1; i &lt;= sz; i ++) V[i].clear(); for(int i = 2; i &lt;= sz; i ++) &#123;#ifdef LOCAL printf("height[%d] : %d\n", i, height[i]);#endif V[height[i]].push_back(i); &#125; for(int i = sz; i &gt;= 1; i --) &#123; for(int j = 0; j &lt; V[i].size(); j ++) &#123; int u = V[i][j]; merge_set(u - 1, u); u = get_fa(u); if(maxv[u] - minv[u] &gt;= i) return i; &#125; &#125; return 0;&#125;int main() &#123; static int S2[maxn]; S[0] = 50000; while(scanf("%d", &amp;sz) == 1) &#123; if(!sz) break; for(int i = 1; i &lt;= sz; i ++) scanf("%d", &amp;S[i]); for(int i = sz; i &gt;= 1; i --) S[i] -= S[i - 1]; std::copy(S + 1, S + 1 + sz, S2 + 1); std::sort(S2 + 1, S2 + 1 + sz); int lsiz = std::unique(S2 + 1, S2 + 1 + sz) - S2 - 1; for(int i = 1; i &lt;= sz; i ++) &#123; S[i] = std::lower_bound(S2 + 1, S2 + 1 + lsiz, S[i]) - S2; &#125; int ret = solve() + 1; if(ret &gt;= 5) &#123; printf("%d\n", ret); &#125; else &#123; puts("0"); &#125; &#125; return 0;&#125; POJ 3415 Common Substrings Description 给出两个串\(A,B\)和一个一个正整数\(k\)，求出两个串长度不小于\(k\)的公共子串的数量。 \(1\leq |A|,|B|\leq 10^5,1\leq k\leq\min(|A|,|B|)\)，多组数据。两个串最多由全体拉丁字母组成。 Solution 首先还是考虑把\(\mathrm{height}[i] &lt; k\)的地方断开，剩下的地方连成块，然后剩下的每一块内部产生答案。 然后答案有两类，一类是在\(A\)中的后缀和排名比他小的\(B\)中的后缀产生答案，另一类情况是反过来的。那么会做第一类就会做第二类了。 考虑一个排名比\(i\)低的串，对\(i\)造成的贡献事两者的LCP再减\(k - 1\)，那么我们考虑怎么去维护所有串的贡献的和。我们注意到排名比\(\mathrm{sa}[i]\)越低，和\(\mathrm{sa}[i]\)的LCP就会越来越小，从左往右事单调递增的。所以我们可以用单调栈来维护这个东西。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;int idx(char c) &#123; if(c == '$') &#123; return 53; &#125; else if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') &#123; return c - 'a' + 1; &#125; else &#123; return c - 'A' + 27; &#125;&#125;const int maxn = 200005;char S[maxn]; int sz;int sa[maxn], rk[maxn], height[maxn];void process() &#123; static int fir[maxn], sec[maxn]; static int buf[maxn], tmp[maxn]; std::fill(buf, buf + std::max(sz, 53) + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[idx(S[i])] ++; for(int i = 1; i &lt;= 53; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) rk[i] = buf[idx(S[i]) - 1] + 1; for(int t = 1; t &lt;= sz; t &lt;&lt;= 1) &#123; for(int i = 1; i &lt;= sz; i ++) &#123; fir[i] = rk[i]; sec[i] = (i + t &gt; sz) ? 0 : rk[i + t]; &#125; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[sec[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) tmp[buf[sec[i]] --] = i; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[fir[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = sz; i &gt;= 1; i --) &#123; int j = tmp[i]; sa[buf[fir[j]] --] = j; &#125; bool unique = true; for(int i = 1, las = 0; i &lt;= sz; i ++) &#123; int j = sa[i]; if(!las) &#123; rk[j] = 1; &#125; else &#123; if(fir[j] == fir[las] &amp;&amp; sec[j] == sec[las]) &#123; unique = false; rk[j] = rk[las]; &#125; else &#123; rk[j] = rk[las] + 1; &#125; &#125; las = j; &#125; if(unique) break; &#125; for(int i = 1, k = 0; i &lt;= sz; i ++) &#123; if(rk[i] == 1) &#123; k = 0; &#125; else &#123; if(k &gt; 0) k --; int j = sa[rk[i] - 1]; while(i + k &lt;= sz &amp;&amp; j + k &lt;= sz &amp;&amp; S[i + k] == S[j + k]) k ++; &#125; height[rk[i]] = k; &#125;&#125;int s1, s2;bool check(int i) &#123; return (i &lt;= s1);&#125;struct Node &#123; int cnt, val; Node(int v, int c = 1) &#123; val = v; cnt = c; &#125; bool operator &lt;(const Node &amp;res) const &#123; return val &lt; res.val; &#125; bool operator ==(const Node &amp;res) const &#123; return val == res.val; &#125; bool operator &gt;(const Node &amp;res) const &#123; return val &gt; res.val; &#125;&#125;;int k;typedef long long ll;struct DStack &#123; std::stack&lt;Node&gt; S; ll ans; DStack() &#123; ans = 0; &#125; void clear() &#123; ans = 0; while(!S.empty()) S.pop(); &#125; void insert(Node x) &#123; while(!S.empty() &amp;&amp; (S.top() &gt; x || S.top() == x)) &#123; ll v = S.top().val, c = S.top().cnt; S.pop(); ans -= v * c; x.cnt += c; &#125; S.push(x); ans += (ll(x.cnt)) * (ll(x.val)); &#125;&#125;;ll solve(bool bs) &#123; DStack S; ll ans = 0; for(int i = 1; i &lt;= sz; i ++) &#123; if(height[i] &lt; k) &#123; S.clear(); continue; &#125; bool th = check(sa[i]); S.insert(Node(height[i] - k + 1, (check(sa[i - 1]) != bs) ? 1 : 0)); if(th == bs) ans += S.ans; &#125; return ans;&#125;int main() &#123; while(scanf("%d", &amp;k) == 1) &#123; if(!k) break; scanf("%s", S + 1); s1 = strlen(S + 1); S[s1 + 1] = '$'; scanf("%s", S + 2 + s1); sz = strlen(S + 1);#ifdef LOCAL printf("s1 : %d\nsz : %d\n", s1, sz); puts(S + 1);#endif process(); printf("%lld\n", solve(false) + solve(true)); &#125; return 0;&#125; LibreOJ 2059 「TJOI / HEOI2016」字符串 Description 给出一个长度为\(n\)的小写字母串\(S\)，\(m\)询问\(a, b, c, d\)，求出\(S[a\ldots b]\)的所有子串和\(S[c\ldots d]\)本身的LCP的最大值。 \(1\leq n, m\leq 10^5, 1\leq a\leq b\leq n, 1\leq c\leq d\leq n\)。 Solution 很显然这个东西的答案满足单调性……所以我们就二分答案吧。 那么考虑怎么判定呢。 假设当前二分出来的答案为\(k\)，那么和后缀\(c\ldots n\)的LCP为\(k\)的后缀在后缀数组中一定为一段区间（假设为\([l, r]\)），那么如果这段区间里有个\(i\)满足\(\mathrm{sa}[i]\in[a, b - k + 1]\)，那么显然答案合法，反之则不合法。 于是我们队后缀数组建主席树，然后每次判定就是确定\([l, r]\)（这个也可以二分答案搞）之后在一段区间里查询是否有值在一段区间里的位置就行了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;int idx(char c) &#123; if(c == '$') &#123; return 27; &#125; else &#123; return c - 'a' + 1; &#125;&#125;const int maxn = 100005;char S[maxn]; int sz;int sa[maxn], rk[maxn], height[maxn];void process() &#123; static int fir[maxn], sec[maxn]; static int buf[maxn], tmp[maxn]; std::fill(buf, buf + 28, 0); for(int i = 1; i &lt;= sz; i ++) buf[idx(S[i])] ++; for(int i = 1; i &lt;= 27; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) rk[i] = buf[idx(S[i]) - 1] + 1; for(int t = 1; t &lt;= sz; t &lt;&lt;= 1) &#123; for(int i = 1; i &lt;= sz; i ++) &#123; fir[i] = rk[i]; sec[i] = (i + t &gt; sz) ? 0 : rk[i + t]; &#125; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[sec[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = 1; i &lt;= sz; i ++) tmp[buf[sec[i]] --] = i; std::fill(buf, buf + sz + 1, 0); for(int i = 1; i &lt;= sz; i ++) buf[fir[i]] ++; for(int i = 1; i &lt;= sz; i ++) buf[i] += buf[i - 1]; for(int i = sz; i &gt;= 1; i --) &#123; int j = tmp[i]; sa[buf[fir[j]] --] = j; &#125; bool unique = true; for(int i = 1, las = 0; i &lt;= sz; i ++) &#123; int j = sa[i]; if(!las) &#123; rk[j] = 1; &#125; else &#123; if(fir[j] == fir[las] &amp;&amp; sec[j] == sec[las]) &#123; unique = false; rk[j] = rk[las]; &#125; else &#123; rk[j] = rk[las] + 1; &#125; &#125; las = j; &#125; if(unique) break; &#125; for(int i = 1, k = 0; i &lt;= sz; i ++) &#123; if(rk[i] == 1) &#123; k = 0; &#125; else &#123; if(k &gt; 0) k --; int j = sa[rk[i] - 1]; while(i + k &lt;= sz &amp;&amp; j + k &lt;= sz &amp;&amp; S[i + k] == S[j + k]) k ++; &#125; height[rk[i]] = k; &#125;&#125;int minv[maxn][18], lim[maxn];void process_st() &#123; for(int i = 1; i &lt;= sz; i ++) &#123; minv[i][0] = height[i]; &#125; for(int j = 1; (1 &lt;&lt; j) &lt;= sz; j ++) &#123; for(int i = 1; (i + (1 &lt;&lt; j) - 1) &lt;= sz; i ++) &#123; minv[i][j] = std::min(minv[i][j - 1], minv[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; for(int i = 1; i &lt;= sz; i ++) &#123; int v = 0; while((1 &lt;&lt; (v + 1)) &lt;= i) v ++; lim[i] = v; &#125;&#125;int query(int l, int r) &#123; if(l &gt; r) return 0x7fffffff; int c = lim[r - l + 1]; return std::min(minv[l][c], minv[r - (1 &lt;&lt; c) + 1][c]);&#125;const int bufsiz = 100 * 1024 * 1024;char buf[bufsiz]; char *cur = buf;void *alloc(size_t size) &#123; if(buf - cur + size &gt; bufsiz) &#123; return malloc(size); &#125; else &#123; char *ret = cur; cur += size; return ret; &#125;&#125;struct Node &#123; Node *lc, *rc; int sumv;&#125;;Node *nil;void init_pool() &#123; nil = (Node*)alloc(sizeof(Node)); nil -&gt; sumv = 0; nil -&gt; lc = nil -&gt; rc = nil;&#125;Node *alloc_node(int v = 0, Node *lc = nil, Node *rc = nil) &#123; Node *ret = (Node*)alloc(sizeof(Node)); ret -&gt; sumv = v; ret -&gt; lc = lc; ret -&gt; rc = rc; return ret;&#125;Node *modify(Node *o, int L, int R, int p, int v) &#123; Node *ret = alloc_node(o -&gt; sumv + v, o -&gt; lc, o -&gt; rc); if(L &lt; R) &#123; int M = (L + R) / 2; if(p &lt;= M) &#123; ret -&gt; lc = modify(ret -&gt; lc, L, M, p, v); &#125; else &#123; ret -&gt; rc = modify(ret -&gt; rc, M + 1, R, p, v); &#125; &#125; return ret;&#125;int query(Node *o, int L, int R, int ql, int qr) &#123; if(ql &lt;= L &amp;&amp; R &lt;= qr) &#123; return o -&gt; sumv; &#125; else &#123; int ans = 0; int M = (L + R) / 2; if(ql &lt;= M) ans += query(o -&gt; lc, L, M, ql, qr); if(qr &gt; M) ans += query(o -&gt; rc, M + 1, R, ql, qr); return ans; &#125;&#125;Node *T[maxn];int query(int lt, int rt, int l, int r) &#123; return query(T[rt], 1, sz, l, r) - query(T[lt - 1], 1, sz, l, r);&#125;void process_tree() &#123; init_pool(); T[0] = nil; for(int i = 1; i &lt;= sz; i ++) &#123; T[i] = modify(T[i - 1], 1, sz, sa[i], 1); &#125;#ifdef LOCAL puts("Processing tree ended!"); fflush(stdout);#endif&#125;bool check(int x, int c, int l, int r) &#123; int L, R, lp = c, rp = c; L = 1, R = c - 1; while(true) &#123; if(R - L &lt;= 3) &#123; for(int i = L; i &lt;= R; i ++) &#123; if(query(i + 1, c) &gt;= x) &#123; lp = i; break; &#125; &#125; break; &#125; int M = (L + R) / 2; if(query(M + 1, c) &gt;= x) &#123; R = M; &#125; else &#123; L = M; &#125; &#125; L = c + 1, R = sz; while(true) &#123;#ifdef LOCAL printf("CState (%d, %d)\n", L, R); fflush(stdout);#endif if(R - L &lt;= 3) &#123; for(int i = R; i &gt;= L; i --) &#123; if(query(c + 1, i) &gt;= x) &#123; rp = i; break; &#125; &#125; break; &#125; int M = (L + R) / 2; if(query(c + 1, M) &gt;= x) &#123; L = M; &#125;else &#123; R = M; &#125; &#125;#ifdef LOCAL printf("%d : [%d, %d]\n", c, lp, rp); fflush(stdout);#endif return (query(lp, rp, l, r) &gt; 0);&#125;int solve(int a, int b, int c, int d) &#123; int L = 1, R = std::min(d - c + 1, b - a + 1); int ret = 0; while(true) &#123;#ifdef LOCAL printf("State (%d, %d)\n", L, R); fflush(stdout);#endif if(R - L &lt;= 3) &#123; for(int i = R; i &gt;= L; i --) &#123; if(check(i, rk[c], a, b - i + 1)) &#123; ret = i; break; &#125; &#125; break; &#125; int M = (L + R) / 2; if(check(M, rk[c], a, b - M + 1)) &#123; L = M; &#125; else &#123; R = M; &#125; &#125; return ret;&#125;int main() &#123; int q; scanf("%d%d%s", &amp;sz, &amp;q, S + 1); process(); process_st(); process_tree(); while(q --) &#123; int a, b, c, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); printf("%d\n", solve(a, b, c, d)); &#125; return 0;&#125; 后缀自动机 介绍 还在路上，马上就来了（鸽并感） 题目 例题1 Description 给一个字母串，求出它的最小表示法（就是可以进行若干次循环位移，使得串的字典序尽可能小）。 \(n\leq 10^{5}\)。 Solution 把串复制两份接一块，那么很显然就是要求新串的一个长度为\(n\)的子串，使得这个串的字典序最小。 那么考虑建新串的后缀自动机。从根开始每一步走尽可能小的转移边即可。 LibreOJ 2033 「SDOI2016」生成魔咒 Description 有一个初始为空的整数串\(S\)，要求动态的往尾部加数，每次操作完后求数字串的本质不同子串数目。 操作次数不超过十万次，\(S\)中的数在\([1, 10^9]\)中。 Solution 参考原博客 SPOJ NSUBSTR Description 给一个字符串\(S\)，用\(F(x)\)表示所有\(S\)的长度为\(x\)的子串中出现次数的最大值。求\(F(1)\ldots F(|S|)\)。 \(|S|\leq 250000\)。 Solution 参考原博客 SPOJ LCS2 Description 给你至多十个串，求他们的最长公共子串。 每个串的大小不超过十万。 Solution 参考原博客 LibreOJ 2102 「TJOI2015」弦论 Description 对于一个长为\(n\)的小写字母串\(S\)，求它的第\(k\)小子串。 每组数据还给定一个\(T\)，表示对于不同位置的相同子串是否算一种。 \(n\leq 5\times 10^5, k\leq 10^9\)。 Solution 参考原博客 LibreOJ 2137 「ZJOI2015」诸神眷顾的幻想乡 Description 给出一个点上写着字符（这里字符定义为小于\(c\)的自然数）的树，度数为1的点的数量不超过20。定义其子串为从一个点延最短路走到另一个点（显然方案唯一），把经过的点上的字符顺次写下来所得到的字符串。 求这棵树有多少种本质不同子串。 \(1\leq n\leq 10^5, 1\leq c\leq 10\)。 Solution 参考原博客]]></content>
      <categories>
        <category>大坑</category>
      </categories>
      <tags>
        <tag>SPOJ</tag>
        <tag>LibreOJ</tag>
        <tag>后缀自动机</tag>
        <tag>后缀数组</tag>
        <tag>后缀树</tag>
        <tag>后缀平衡树</tag>
        <tag>POJ</tag>
        <tag>SDOI</tag>
        <tag>TJOI</tag>
        <tag>HEOI</tag>
        <tag>ZJOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 6052 「雅礼集训 2017 Day11」DIV]]></title>
    <url>%2F2018%2F07%2F24%2Floj6052%2F</url>
    <content type="text"><![CDATA[Description 定义复数\(a + bi\)为\(k\)的约数，当且仅当\(a, b\)为整数且存在整数\(c, d\)满足\((a + bi)(c + di) = k\)。 给定\(n\)，求\(1\)到\(n\)中所有整数的实部大于\(0\)的约数的实部的和。 答案模1004535809。 \(n\leq 10^{10}\)。 Solution 为啥这题和某课件上的简化版差距这么大啊…… 考虑一个复数\((a + bi)(c + di) = k\)意味着什么，其实也就是下面两个式子： \[ ac - bd = k\\ ad + bc = 0 \] 由第二个式子可得： \[ \frac{a}{b} = -\frac{c}{d} \] 那么我们考虑将\(a, b\)约去他们两个之间的最大公约数，\(c, d\)也做一样的操作。那么上式还是成立的，并且等号两边的分式都已经最简化了，因此此时有\(a = c, b = -d\)。 带回最早的式子（两个复数的积那个）可以得到： \[ c(a^2 + b^2) = k \] 这个\(c\)是我们先前约去的常数的积。从此式也可以看出\((a^2+b^2)|k\)，并且贡献一定是\(a\)乘上一个常数。 那么我们枚举互质数对\((a, b)\)，其对答案的贡献是\(a\sigma(\frac{n}{a^2 + b^2})\)（这里\(\sigma\)表示\(\sigma_1\)，即约束之和）。 因此最终答案为： \[ \begin{aligned} \quad&amp;\sum_{i = 1}^n\sum_{a\perp b, (a^2 + b^2) | i} a\sigma(\frac{i}{a^2+b^2}) \end{aligned} \] 这玩怕不是几乎不可做……因此我们考虑枚举\(k = a^2 + b^2\)： \[ \begin{aligned} \quad&amp;\sum_{k = 1}^n\sum_{a\perp b, a^2 + b^2 = k} a\sum_{k | i}\sigma(\frac{i}{k})\\ =&amp;\sum_{k = 1}^n\sum_{a\perp b, a^2 + b^2 = k} aD(\lfloor\frac{n}{k}\rfloor)\\ =&amp;\sum_{k = 1}^nD(\lfloor\frac{n}{k}\rfloor)\sum_{a\perp b, a^2 + b^2 = k} a\\ =&amp;\sum_{k = 1}^nD(\lfloor\frac{n}{k}\rfloor)f(k) \end{aligned} \] 其中\(D\)为\(\sigma\)的前缀和，\(f(k)\)表记的是啥可以根据上下文推导一下（逃 这个形式几乎和杜教筛如出一辙……像杜教筛一样先大力数论分块，然后先考虑怎么处理\(D\)，很显然有一个\(O(\sqrt{n})\)的做法： \[ \sum_{i = 1}^n i\lfloor\frac{n}{i}\rfloor \] 如此一来我们可以考虑先预处理不大于\(n^\frac{2}{3}\)的\(D\)值，其他情况用上面的式子求（甚至不需要记忆化复杂度也是对的）。用杜教筛那种复杂度证明可以证出这部分的复杂度是\(O(n^\frac{2}{3})\)的。 然后我们发现我们其实也要处理\(f​\)的前缀和\(F​\)……但是有个互质在这这个玩意并不好处理。那么我们考虑类似于狄利克雷卷积的一些思路？定义一个\(G(x) = \sum_{1\leq a^2+b^2\leq x}a​\)，这个东西可以很方便的用\(O(\sqrt{n})​\)的复杂度求（\(G(x)=\sum_{i = 1}^{\lfloor\sqrt{x}\rfloor}i\lfloor\sqrt{x - i^2}\rfloor​\)），然后我们发现有： \[ G(x) = \sum_{i = 1}^{\lfloor\sqrt{x}\rfloor}iF(\lfloor\frac{x}{i^2}\rfloor) \] 然后这个还是有点像杜教筛的一些形式啊！我们发现我们要抽出来的事\(F(x)\)，因此移一下项就有了： \[ F(x)=G(x) - \sum_{i = 2}^{\lfloor\sqrt{x}\rfloor}iF(\lfloor\frac{x}{i^2}\rfloor) \] 还是如出一辙的处理套路啊……对于大于\(n^\frac{2}{3}\)的情况我们直接用这个式子\(O(\sqrt{n})\)求（顺便记忆化）；其他情况就要考虑预处理了，那么我们考虑预处理\(f(x)\)本身，这个东西可以通过枚举\(a\)然后枚举\(b\)最后判断是否互质的搞法在\(O(n^\frac{2}{3}\log n)\)的复杂度里搞出来。总复杂度证明还是和杜教筛如出一辙。 然后做完了？其实并没有。我们上面钦点了复数虚部为正整数。至于负整数和正整数的情况对称，答案完全一致。如果虚部为\(0\)的话那么参与运算的全都是正整数，因此此时答案就是\(D(n)\)了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;unordered_map&gt;const int N = 5000000;using ll = long long;const ll ha = 1004535809LL;ll d[N + 5], f[N + 5];int prm[N + 5]; bool vis[N + 5];int gcd(int a, int b) &#123; if(!b) &#123; return a; &#125; else &#123; return gcd(b, a % b); &#125;&#125;void sieve() &#123; int cnt = 0; vis[1] = true; d[1] = 1; f[1] = 0; for(int i = 2; i &lt;= N; i ++) &#123; if(!vis[i]) &#123; d[i] = i + 1; prm[cnt ++] = i; &#125; for(int j = 0; j &lt; cnt; j ++) &#123; int v = i * prm[j]; if(v &gt; N) break; vis[v] = true; if(i % prm[j] == 0) &#123; d[v] = d[i] * d[prm[j]] - (ll)prm[j] * d[i / prm[j]]; break; &#125; else &#123; d[v] = d[i] * d[prm[j]]; &#125; &#125; &#125; for(int i = 1; i * i &lt;= N; i ++) &#123; for(int j = 1; j * j + i * i &lt;= N; j ++) &#123; if(gcd(i, j) == 1) &#123; f[j * j + i * i] += i; &#125; &#125; &#125; for(int i = 1; i &lt;= N; i ++) &#123; d[i] = (d[i] + d[i - 1]) % ha; f[i] = (f[i] + f[i - 1]) % ha; &#125;&#125;std::unordered_map&lt;ll, ll&gt; ma_d;ll S(ll n) &#123; static const ll inv_2 = 502267905LL; ll ret = ((n % ha) * ((n + 1) % ha)) % ha; ret = (ret * inv_2) % ha; return ret;&#125;ll sigma(ll n) &#123; if(n &lt;= (ll)N) return d[n]; if(ma_d.count(n)) return ma_d[n]; ll ret = 0; for(ll i = 1; i &lt;= n;) &#123; ll next = n / (n / i); ll delta = (S(next) - S(i - 1) + ha) % ha; delta = (delta * ((n / i) % ha)) % ha; ret = (ret + delta) % ha; i = next + 1LL; &#125; ma_d[n] = ret; return ret;&#125;std::unordered_map&lt;ll, ll&gt; ma_f;ll calc_f(ll n) &#123; if(n &lt;= (ll)N) return f[n]; if(ma_f.count(n)) return ma_f[n]; ll ret = 0; for(ll i = 1; i * i &lt;= n; i ++) &#123; ll delta = floor(sqrt(n - i * i)); delta %= ha; delta = (delta * i) % ha; ret = (ret + delta) % ha; &#125; for(ll i = 2; i * i &lt;= n; i ++) &#123; ll delta = (calc_f(n / (i * i)) * i) % ha; ret = (ret - delta + ha) % ha; &#125; ma_f[n] = ret; return ret;&#125;ll calc(ll n) &#123; ll ret = 0, las = 0; for(ll i = 1; i &lt;= n;) &#123; ll next = n / (n / i); ll th = calc_f(next); ll delta = (th - las + ha) % ha; delta = (delta * sigma(n / i)) % ha; ret = (ret + delta) % ha; las = th; i = next + 1LL; &#125; return ret;&#125;int main() &#123; sieve(); ll n; scanf("%lld", &amp;n); printf("%lld\n", (calc(n) * 2LL + sigma(n)) % ha); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>狄利克雷卷积</tag>
        <tag>杜教筛</tag>
        <tag>LibreOJ</tag>
        <tag>雅礼集训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LibreOJ 6053 简单的函数]]></title>
    <url>%2F2018%2F07%2F24%2Floj6053%2F</url>
    <content type="text"><![CDATA[Description 今有一积性函数\(f(x)\)，满足以下性质 \(f(1) = 1\)。 对任意质数\(p\)和正整数\(c\)，有\(f(p^c) = p\oplus c\)。 给定正整数\(n\)，求\(\sum_{i = 1}^n f(i)\)，答案模1000000007。 \(n\leq 10^{10}\)。 Solution 算是一道不那么水的Min_25筛板子题？ Min_25筛最核心的地方就是对于质数的答案求前缀和。那么我们考虑对任意质数\(p\)，\(f(p)\)的取值。然后我们会发现除了\(2\)以外的所有质数都是奇数，所以对于\(2\)有\(f(p) = p + 1\)，对其他质数有\(f(p) = p - 1\)。 那么我们把质数的答案分为两部分考虑：一部分是\(p\)，另一部分是后面的加减一。前面一部分就是质数本身的和，几乎就是最简单的Min_25筛；后面也不难，只需要对于小于等于2的情况特判一下就完了。 然后下面就是标准的Min_25筛了……Min_25筛真香！ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;const int maxn = 200005;using ll = long long;const ll ha = 1000000007LL;ll sqr(ll x) &#123; ll ret = 1; while((ret + 1LL) * (ret + 1LL) &lt;= x) ret ++; return ret;&#125;ll n, S; int cnt;ll A[2][maxn]; ll prm[maxn];void sieve_0() &#123; S = sqr(n); cnt = 0; for(int i = 1; i &lt;= S; i ++) &#123; A[0][i] = i; &#125; for(int i = 1; i &lt;= S; i ++) &#123; A[1][i] = (n / (ll(i))) % ha; &#125; for(int i = 2; i &lt;= S; i ++) &#123; if(A[0][i - 1] == A[0][i]) continue; prm[++ cnt] = i; ll lim = (ll(i)) * (ll(i)), v = A[0][i - 1]; for(int j = 1; j &lt;= S / i; j ++) &#123; ll delta = (A[1][j * i] - v + ha) % ha; A[1][j] = (A[1][j] - delta + ha) % ha; &#125; for(int j = S / i + 1; j &lt;= S; j ++) &#123; ll src = n / ((ll(j)) * (ll(i))); if(src &lt; (ll)i) break; ll delta = (A[0][src] - v + ha) % ha; A[1][j] = (A[1][j] - delta + ha) % ha; &#125; for(int j = S; (ll)j &gt;= lim; j --) &#123; ll delta = (A[0][j / i] - v + ha) % ha; A[0][j] = (A[0][j] - delta + ha) % ha; &#125; &#125; prm[++ cnt] = S + 1;&#125;ll B[2][maxn];ll S1(ll x) &#123; ll a = x, b = x + 1LL; if(x &amp; 1LL) &#123; b &gt;&gt;= 1; &#125; else &#123; a &gt;&gt;= 1; &#125; a %= ha; b %= ha; return (a * b) % ha;&#125;void sieve_1() &#123; S = sqr(n); cnt = 0; for(int i = 1; i &lt;= S; i ++) &#123; B[0][i] = S1(i); &#125; for(int i = 1; i &lt;= S; i ++) &#123; B[1][i] = S1(n / (ll(i))); &#125; for(int i = 2; i &lt;= S; i ++) &#123; if(B[0][i - 1] == B[0][i]) continue; prm[++ cnt] = i; ll lim = (ll(i)) * (ll(i)), v = B[0][i - 1]; for(int j = 1; j &lt;= S / i; j ++) &#123; ll delta = (B[1][j * i] - v + ha) % ha; delta = (delta * (ll(i))) % ha; B[1][j] = (B[1][j] - delta + ha) % ha; &#125; for(int j = S / i + 1; j &lt;= S; j ++) &#123; ll src = n / ((ll(j)) * (ll(i))); if(src &lt; (ll)i) break; ll delta = (B[0][src] - v + ha) % ha; delta = (delta * (ll(i))) % ha; B[1][j] = (B[1][j] - delta + ha) % ha; &#125; for(int j = S; (ll)j &gt;= lim; j --) &#123; ll delta = (B[0][j / i] - v + ha) % ha; delta = (delta * (ll(i))) % ha; B[0][j] = (B[0][j] - delta + ha) % ha; &#125; &#125; prm[++ cnt] = S + 1;#ifdef LOCAL for(int i = 1; i &lt;= cnt; i ++) &#123; printf("prm[%d] : %lld\n", i, prm[i]); &#125; for(int i = 1; i &lt;= S; i ++) &#123; printf("B[%d] : %lld\n", i, B[0][i]); &#125; for(int i = S; i &gt;= 1; i --) &#123; printf("B[%lld] : %lld\n", n / (ll(i)), B[1][i]); &#125;#endif&#125;ll query_0(ll x) &#123; if(x &lt;= 1LL) return 0; if(x == 2LL) return 1; ll ret; if(x &lt;= S) &#123; ret = A[0][x]; &#125; else &#123; ret = A[1][n / x]; &#125; ret --; ret = (2LL - ret + ha) % ha; return ret;&#125;ll query_1(ll x) &#123; if(x &lt;= S) &#123; return B[0][x]; &#125; else &#123; return B[1][n / x]; &#125;&#125;ll calc(ll m, int x) &#123; if(m &lt; prm[x]) return 0; ll ret = (query_0(m) + query_1(m)) % ha; ret = (ret - (query_0(prm[x] - 1) + query_1(prm[x] - 1)) % ha + ha) % ha; for(int i = x; i &lt;= cnt; i ++) &#123; ll st = prm[i]; if(st * prm[i] &gt; m) break; for(int j = 1; ; j ++) &#123; if(st * prm[i] &gt; m) break; ll delta = ((calc(m / st, i + 1) * (prm[i] ^ (ll(j)))) % ha + (prm[i] ^ (ll(j + 1)))) % ha; ret = (ret + delta) % ha; st *= prm[i]; &#125; &#125; return ret;&#125;int main() &#123; scanf("%lld", &amp;n); sieve_0(); sieve_1(); printf("%lld\n", (1LL + calc(n, 1)) % ha); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Min_25筛</tag>
        <tag>LibreOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 4314 倍数？倍数！]]></title>
    <url>%2F2018%2F07%2F21%2FBZOJ4314%2F</url>
    <content type="text"><![CDATA[Description 要求你从\(Z_n\)（模\(n\)的剩余系）里选出\(k\)个不重复元素，使得他们的和模\(n\)为0。求方案数。 \(1\leq n\leq 10^9, 1\leq k\leq 10^3\)。 Solution 看上去就很像单位根反演的题？ 先放一下众所周知的单位根反演的式子： \[ \frac{1}{n}\sum_{i = 0}^{n - 1}(\xi_{n}^i)^k=[n | k] \] 证明很容易：假如有\(n | k\)，那么和式中每一项都是1，加起来除\(n\)后就事1了（这种情况下等比数列公比为1，所以不可以采用等比数列求和公式）；反之，我们采用等比数列求和公式可知原式中的和式为\(\frac{1 - \xi_n^{kn}}{1 - \xi_n^k}\)，这个东西的分子为0，那么自然和式左边为0。 那么考虑构造二元答案多项式\(f(x, y)\)： \[ f(x, y) = \prod_{i = 0}^{n - 1}(1 + x^iy) \] 这个多项式的每一项中\(x\)的次数表示和，\(y\)表示选数的数量。我们显然要求所有含\(y^k\)且\(x\)的次数为\(n\)的倍数的项的系数之和，那么考虑将\(y\)视为常数，对\(x\)进行单位根反演： \[ f(\xi_n^t, y)=\prod_{i = 0}^{n - 1}(1 + (\xi_n^{t})^iy) \] 观察到如果\(t\)和\(n\)不互质，那么两者可以同时约去一约数（反之，若有\(t\perp n\)，那么称\(\xi_n^t\)为一个\(n\)次本原单位根）。假设约完之后的单位根为\(\xi_a^b\)，那么我们发现当积式中枚举的\(i\)大于\(a\)时，会出现循环。所以我们只需要取循环节（显然长度为\(a\)，因为我们知道所有\(a\)阶单位根构成一个循环群，而\(a\)阶本原单位根一定是该群的生成元。原因事首先显然用\(\xi_a^1\)可以生成所有\(a\)阶单位根，所以所有\(a\)阶单位根构成一个循环群；然后你根据数论里的欧拉定理可以知道\(x^{\phi(p)}\equiv 1\pmod{p}(x\perp p)\)，那么对于任意本原单位根\(\xi_a^b\)有\(\xi_a^{b^{\phi(a)}} = \xi_a^1\)，式子左边的东西是\(\xi_a^b\)的若干次方，所以用\(\xi_a^b\)可以生成\(\xi_a^1\)，自然就可以生成整个循环群）的若干次方就行了，那么有： \[ f(\xi_a^b, y) = (\prod_{i = 0}^{a - 1}(1 + (\xi_a^b)^iy))^\frac{n}{a} \] 根据上面的说法，考虑里面的积式一定可以枚举到所有\(a\)阶单位根，所以这个积式也可以写成： \[ f(\xi_a^b, y) = (\prod_{i = 0}^{a - 1} (1 + \xi_a^iy))^\frac{n}{a} \] 这么一来，我们发现对于任意\(a\)阶本原单位根\(\xi_a^b\)，对答案的贡献都是一样的，而我们知道\(a\)阶本原单位根有\(\phi(a)\)个。只要我们对所有\(n\)的约数求出其所有本原单位根的贡献的和，那么这题就做完了。 那么我们考虑，如果我们知道了\(a\)，那么怎么快速求一个本原单位根的贡献呢？ 考虑那个多项式（里面的积式），首先很容易发现其0次项为1。然后我们从零点入手…… 然后我们发现这个多项式几乎没法求零点……那么我们做一步小转换吧： \[ \prod_{i = 0}^{a - 1}\xi_a^i(\xi_a^{a - i} + y) \] 然后我们发现\(\xi_a^{a - i}\)就枚举了所有单位根，所以零点集合就是所有单位根相反数的集合。 如果\(a\)为偶数，那么把所有单位根取相反数之后得到的集合其实和原集合事一样的……这个大致可以理解为所有单位根构成的图形关于原点中心对称。而我们知道\(x^a - 1 = 0\)的解就是全体\(a\)阶单位根，因此答案多项式和\(x^a - 1\)只有常数项的不同，而取反之后得到了\(1 - x^a\)，其零点、常数项都符合我们的要求。 如果\(a\)为奇数，那么考虑\(x^a\)，往里面带一个单位根的相反数的话，因为\(a\)为奇数所以会得到\(-1\)，所以该多项式的零点就是\(x^a + 1 = 0\)的全体解。而左边多项式的常数项也符合我们的要求，因此此时多项式为\(1 + x^a\)。 综上可得： \[ \prod_{i = 0}^{a - 1}(1 + \xi_a^iy) = 1 - (-y)^a \] 而最后的答案多项式为： \[ \frac{1}{n}\sum_{d | n}\phi(d)(1 - (-y)^d)^\frac{n}{d} \] 这个东西的\(y^k\)项的系数就是答案了…… Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;typedef long long ll;const ll ha = 1000000007LL;ll pow_mod(ll a, ll b) &#123; ll ans = 1LL, res = a; while(b) &#123; if(1LL &amp; b) ans = (ans * res) % ha; res = (res * res) % ha; b &gt;&gt;= 1; &#125; return ans;&#125;ll inv(ll x) &#123; return pow_mod(x, ha - 2LL);&#125; ll sqrt(ll n) &#123; ll ans = 1; while((ans + 1LL) * (ans + 1LL) &lt;= n) ans ++; return ans;&#125;int phi(int n) &#123; int ans = n, m = sqrt(n); for(int i = 2; i &lt;= m; i ++) &#123; if(n % i == 0) &#123; ans = (ans / i) * (i - 1); while(n % i == 0) n /= i; &#125; &#125; if(n &gt; 1) ans = (ans / n) * (n - 1); return ans;&#125;ll C(int n, int m) &#123; if(n &lt; m) return 0; ll ans = 1; for(int i = 1; i &lt;= m; i ++) &#123; ans = (ans * (ll(n - i + 1))) % ha; ans = (ans * inv(i)) % ha; &#125; return ans;&#125;ll query(int d, int nd, int k) &#123; if(k % d != 0) return 0; ll ret = phi(d); if(d % 2 == 0 &amp;&amp; (k / d) % 2 != 0) &#123; ret = (ha - ret) % ha; &#125; ret = (ret * C(nd, k / d)) % ha; return ret;&#125;ll calc(int n, int k) &#123; int m = sqrt(n); ll ans = 0; for(int i = 1; i &lt;= m; i ++) &#123; if(n % i != 0) continue; ans = (ans + query(i, n / i, k)) % ha; if(i * i != n) ans = (ans + query(n / i, i, k)) % ha; &#125; ans = (ans * inv(n)) % ha; return ans;&#125; int main() &#123; int n, k; scanf("%d%d", &amp;n, &amp;k); printf("%lld\n", calc(n, k)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>单位根</tag>
        <tag>单位根反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ 221「NOI2016」循环之美]]></title>
    <url>%2F2018%2F07%2F21%2FNOI2016D1T3%2F</url>
    <content type="text"><![CDATA[Description 求有多少数值不同的分数\(\frac{x}{y}\)（\(1\leq x\leq n, 1\leq y\leq m\)），满足其在\(k\)进制下化为小数之后事纯循环小数（即小数部分是无限循环的）。 \(1\leq n, m\leq 10^9,2\leq k\leq 2000\)。 Solution 首先如果只统计最简分数就能保证数值相同辣（即钦点\(x\perp y\)，这里用垂直符号表示互质）。然后通过猜结论等手段可以发现纯循环小数其实限制了\(y\perp k\)。 然后考虑颓柿子： \[ \begin{aligned} \quad&amp;\sum_{x = 1}^n\sum_{y = 1}^m [x\perp y][y\perp k]\\ =&amp;\sum_{x = 1}^n\sum_{y = 1,y\perp k}^m \sum_{d | x, d | y}\mu(d)\\ =&amp;\sum_{d = 1,d\perp k}^{\min(n, m)}\mu(d)\lfloor\frac{n}{d}\rfloor\sum_{y = 1}^{\lfloor\frac{m}{d}\rfloor}[y\perp k] \end{aligned} \] 然后这样是个反演的形式……很容易想到数论分块罢…… 接下来首先要考虑对于所有\(\lfloor\frac{m}{d}\rfloor\)处理出范围内和\(k\)互质的数的数量，这个很容易想到洲阁筛的思路。考虑筛出\(k\)的所有质因子\(p_1,p_2,\ldots,p_c\)，定义状态\(f(i, j)\)表示不大于\(j\)且和\(p_1, p_2,\ldots,p_i\)互质的数的数目（边界为\(f(0, j) = j\)）。然后转移很显然是： \[ f(i, j) = f(i - 1, j) - f(i - 1, \lfloor\frac{j}{p_i}\rfloor) \] 然后我们还有一块硬骨头……就是对于所有\(\lfloor\frac{n}{d}\rfloor\)要求出范围内和\(k\)互质的\(d\)的\(\mu(d)\)的和。还是采用洲阁筛的思路，定义\(g(i, j)\)表示对于所有\(d\)满足\(d\leq j\)且\(d\perp p_1, p_2,\ldots, p_i\)的\(\mu(d)\)的和，这样边界\(g(0, j)\)也就是直接对\(\mu\)求一个前缀和，这个杜教筛处理。其他情况的话，我们要排除在一个没有前\(i\)个质因子的数的基础上乘上\(p_i\)的情况（如果有\(p_i\)这个质因子的话再乘一遍就变成0了，所以对答案没有影响），故转移如下： \[ g(i,j)=g(i - 1, j) + g(i, \lfloor\frac{j}{p_i}\rfloor) \] 考虑到这题\(k\)不大，所以第一维非常的小，甚至不需要用洲阁筛的一般加速方法。总复杂度为\(O(n^\frac{2}{3} + \omega(k)\sqrt{n})\)。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;unordered_map&gt;using ll = long long;const int N = 10000000;int mu[N + 5]; int mu_S[N + 5];int prm[N + 5]; bool vis[N + 5];void process() &#123; mu[1] = 1; vis[1] = true; int cnt = 0; for(int i = 2; i &lt;= N; i ++) &#123; if(!vis[i]) &#123; prm[cnt ++] = i; mu[i] = -1; &#125; for(int j = 0; j &lt; cnt &amp;&amp; i * prm[j] &lt;= N; j ++) &#123; int v = i * prm[j]; vis[v] = true; if(i % prm[j] == 0) &#123; mu[v] = 0; break; &#125; else &#123; mu[v] = -mu[i]; &#125; &#125; &#125; for(int i = 1; i &lt;= N; i ++) &#123; mu_S[i] = mu_S[i - 1] + mu[i]; &#125;&#125;int p[12]; int pcnt;void desc(int x) &#123; pcnt = 0; int l = sqrt(x + 0.5); for(int i = 2; i &lt;= l; i ++) &#123; if(x % i == 0) &#123; p[++ pcnt] = i; while(x % i == 0) x /= i; &#125; &#125; if(x &gt; 1) p[++ pcnt] = x;&#125;std::unordered_map&lt;int, ll&gt; h1[12];ll calc_1(int c, int n) &#123; if(c == 0) return n; if(n == 0) return 0; if(h1[c].count(n)) return h1[c][n]; ll ret = calc_1(c - 1, n) - calc_1(c - 1, n / p[c]); h1[c][n] = ret; return ret;&#125;std::unordered_map&lt;int, ll&gt; h2[12];ll calc_2(int c, int n) &#123; if(c == 0) &#123; if(n &lt;= N) return mu_S[n]; if(h2[0].count(n)) return h2[0][n]; ll ret = 1; for(int i = 2; i &lt;= n;) &#123; int next = n / (n / i); ret -= (ll(next - i + 1)) * calc_2(0, n / i); i = next + 1; &#125; h2[0][n] = ret; return ret; &#125; if(n == 0) return 0; if(h2[c].count(n)) return h2[c][n]; ll ret = calc_2(c - 1, n) + calc_2(c, n / p[c]); h2[c][n] = ret; return ret;&#125;ll calc(int n, int m, int k) &#123; desc(k); ll ans = 0; ll las = 0; for(int i = 1; i &lt;= std::min(n, m);) &#123; int next = std::min(n / (n / i), m / (m / i)); ll th = n / i; th *= (ll)calc_1(pcnt, m / i); ll ts = calc_2(pcnt, next); th *= (ts - las); ans += th; i = next + 1; las = ts; &#125; return ans;&#125;int main() &#123; process(); int n, m, k; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); printf("%lld\n", calc(n, m, k)); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>NOI</tag>
        <tag>洲阁筛</tag>
        <tag>UOJ</tag>
        <tag>狄利克雷卷积</tag>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ 3551「ONTAK2010」Peaks加强版]]></title>
    <url>%2F2018%2F07%2F18%2FBZOJ3551%2F</url>
    <content type="text"><![CDATA[真他X的是个弟弟。 初中会嘴巴的东西，高中不会了。 写了骗分，被多组数据雷普了，从75到5。 我谔谔，还事书这题罢，，， 这题大概可以用可持久化并查集套可持久化平衡树或权值线段树啥的做一下（逃 然后我们考虑用一种简单的做法…… 如果我们最后的并查集树中只有原图中的点的话，那么很多信息会非常难处理，那么是否可以考虑引入边？ 在Kruskal的过程中，边被从小到大加入。那么我们给每个边建一个点，用来维护经过这条边才能联通的点的信息。最后我们会得到一棵满二叉树。 这样的好处事有很多的……首先我们可以把信息维护在边上了。这个题要求\(k\)大，所以我们就用可持久化权值线段树吧，然后每个非叶子结点合并信息的时候直接可持久化的线段树合并就行了。 然后还有一个小好处，就是这棵树显然从叶子向上的边点的权值事单调不降的，这样我们可以直接倍增找到一个最往上的符合限制的祖先，用这个祖先的信息就行了。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;const int maxn = 200005;const int maxm = 500005;int n, m;struct Edge &#123; int u, v, d; bool operator &lt;(const Edge &amp;res) const &#123; return d &lt; res.d; &#125;&#125;;Edge E[maxm];const int bufsiz = 1024 * 1024 * 40;char buf[bufsiz]; char *cur = buf;void *alloc(size_t size) &#123; if(cur - buf + size &gt; bufsiz) &#123; return malloc(size); &#125; else &#123; char *ret = cur; cur += size; return ret; &#125;&#125;struct Node &#123; int sumv; Node *lc, *rc;&#125;;Node *nil;void init_tree() &#123; nil = (Node*)alloc(sizeof(Node)); nil -&gt; sumv = 0; nil -&gt; lc = nil -&gt; rc = nil;&#125;Node *alloc_node(int v = 0, Node *lc = nil, Node *rc = nil) &#123; Node *ret = (Node*)alloc(sizeof(Node)); ret -&gt; sumv = v; ret -&gt; lc = lc; ret -&gt; rc = rc; return ret;&#125;Node *gen_chain(int L, int R, int p, int v) &#123; if(L == R) &#123; return alloc_node(v); &#125; else &#123; int M = (L + R) / 2; Node *lc = nil, *rc = nil; if(p &lt;= M) &#123; lc = gen_chain(L, M, p, v); &#125; else &#123; rc = gen_chain(M + 1, R, p, v); &#125; return alloc_node(v, lc, rc); &#125;&#125;Node *merge(Node *A, Node *B) &#123; if(A == nil) return B; if(B == nil) return A; Node *lc = merge(A -&gt; lc, B -&gt; lc); Node *rc = merge(A -&gt; rc, B -&gt; rc); Node *ret = alloc_node(A -&gt; sumv + B -&gt; sumv, lc, rc); return ret;&#125;int kth(Node *o, int L, int R, int k) &#123; if(o -&gt; sumv &lt; k) &#123; return 0; &#125; if(L == R) &#123; return L; &#125; else &#123; int M = (L + R) / 2; if(k &lt;= o -&gt; rc -&gt; sumv) &#123; return kth(o -&gt; rc, M + 1, R, k); &#125; else &#123; return kth(o -&gt; lc, L, M, k - o -&gt; rc -&gt; sumv); &#125; &#125;&#125;int p[maxn];void init_set() &#123; for(int i = 1; i &lt;= 2 * n; i ++) &#123; p[i] = i; &#125;&#125;int get_fa(int x) &#123; if(p[x] == x) &#123; return x; &#125; else &#123; return (p[x] = get_fa(p[x])); &#125;&#125;void merge_set(int x, int y) &#123; x = get_fa(x), y = get_fa(y); p[x] = y;&#125;bool is_same(int x, int y) &#123; return (get_fa(x) == get_fa(y));&#125;int h[maxn], h2[maxn]; int lsiz;void desc() &#123; std::copy(h + 1, h + 1 + n, h2 + 1); std::sort(h2 + 1, h2 + 1 + n); lsiz = std::unique(h2 + 1, h2 + 1 + n) - h2 - 1; for(int i = 1; i &lt;= n; i ++) &#123; h[i] = std::lower_bound(h2 + 1, h2 + 1 + lsiz, h[i]) - h2; &#125;&#125;int lim[maxn];int anc[maxn][19]; int cnt;Node *T[maxn];void build_tree() &#123; memset(anc, -1, sizeof(anc)); init_set(); init_tree(); desc(); for(int i = 1; i &lt;= n; i ++) &#123; T[i] = gen_chain(1, lsiz, h[i], 1); &#125; std::sort(E + 1, E + 1 + m); cnt = n; for(int i = 1; i &lt;= m; i ++) &#123; int u = E[i].u, v = E[i].v, l = E[i].d; if(is_same(u, v)) continue; u = get_fa(u); v = get_fa(v); cnt ++; lim[cnt] = l; T[cnt] = merge(T[u], T[v]); anc[u][0] = anc[v][0] = cnt; merge_set(u, cnt); merge_set(v, cnt); &#125; for(int j = 1; (1 &lt;&lt; j) &lt; cnt; j ++) &#123; for(int i = 1; i &lt;= cnt; i ++) &#123; int a = anc[i][j - 1]; if(a != -1) anc[i][j] = anc[a][j - 1]; &#125; &#125;&#125;int get_up(int x, int l) &#123; for(int j = 18; j &gt;= 0; j --) &#123; int a = anc[x][j]; if(a != -1 &amp;&amp; lim[a] &lt;= l) &#123; x = a; &#125; &#125; return x;&#125;int main() &#123; int q; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); for(int i = 1; i &lt;= n; i ++) scanf("%d", &amp;h[i]); for(int i = 1; i &lt;= m; i ++) &#123; scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].d); &#125; build_tree(); int lastans = 0; h2[0] = -1; while(q --) &#123; int v, x, k; scanf("%d%d%d", &amp;v, &amp;x, &amp;k); if(lastans != -1) &#123; v ^= lastans; x ^= lastans; k ^= lastans; &#125; v = get_up(v, x); printf("%d\n", lastans = h2[kth(T[v], 1, lsiz, k)]);#ifdef LOCAL lastans = 0;#endif &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>ONTAK</tag>
        <tag>Kruskal重构树</tag>
        <tag>权值线段树</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「TJOI2015」概率论]]></title>
    <url>%2F2018%2F07%2F17%2Floj2105%2F</url>
    <content type="text"><![CDATA[通过OEIS等传统艺能易知答案为\(\frac{n(n + 1)}{2(2n - 1)}\)。然后下面说一下怎么证明…… 令虑\(n\)个点的二叉树的方案数为\(H_n\)（其实很显然就是卡塔兰数列），令\(n\)个点的所有二叉树的叶子数的和为\(F_n\)。 考虑推导\(H_n\)的生成函数。我们知道（下面只考虑\(n &gt; 0\)，我们钦定\(H_0 = 1\)）： \[ H_n = \sum_{i = 0}^{n - 1} H_i H_{n - i - 1} \] 所以说对于\(H\)的生成函数，我们可以列方程： \[ H(x) = xH^2(x) + 1 \] 解得： \[ H(x) = \frac{1 \pm \sqrt{1 - 4x}}{2x} \] 通过收敛性可以得知（具体地说……如果取得是加号，那么\(H(x)\)在0处不收敛，与\(H(x)\)的零次项系数的取值有限的事实明显背道相驰），应取\(H(x) = \frac{1 - \sqrt{1 - 4x}}{2x}\)。 由于\(H\)就是卡塔兰数列，所以有\(H_n = \frac{1}{n + 1}\binom{2n}{n}\)。 然后对于\(F\)，我们考虑左右儿子分别的贡献，就可以列式得（这里考虑\(n &gt; 1\)的情况，\(F_1=1\)）： \[ F_n = 2\sum_{i = 1}^{n - 1} F_i H_{n - i - 1} \] 所以可以列出方程： \[ F(x) = 2xF(x)H(x) + x \] 然后解得： \[ F(x) = \frac{x}{\sqrt{1 - 4x}} \] 下面那个开根，看起来很不好弄。我们尝试用广义二项式定理展开它，就可以得到： \[ F(x) = \sum_{i = 1}^{+\infty} \binom{-0.5}{i - 1}(-4)^{i - 1} x^i \] 这里牵扯到了任意实数的组合数……定义可以参考维基（具体是二项式定理那篇）。然后我们去考虑\(F_n\)： \[ \begin{aligned} F_n &amp;= \frac{(-0.5)^{\underline{n - 1}}(-4)^{n - 1}}{(n - 1)!}\\ &amp;=\frac{1}{(n - 1)!}\prod_{i = 0}^{n - 2} (-0.5 - i)\cdot (-4)\\ &amp;=\frac{2^{n - 1}}{(n - 1)!}\prod_{i = 0}^{n - 2} (1 + 2i)\\ &amp;=\frac{2^{n - 1}}{(n - 1)!}\cdot\frac{(2n - 2)!}{2^{n - 1}(n - 1)!}\\ &amp;=\frac{(2n - 2)!}{(n - 1)!(n - 1)!}\\ &amp;=\binom{2n - 2}{n - 1} \end{aligned} \] 最后的答案是一个\(\frac{F_n}{H_n}\)，不妨推一下： \[ \begin{aligned} \frac{F_n}{H_n} &amp;= \frac{(n + 1)\binom{2n - 2}{n - 1}}{\binom{2n}{n}}\\ &amp;=\frac{(n + 1)(2n - 2)!n!n!}{(n-1)!(n-1)!(2n)!}\\ &amp;=\frac{(n + 1)n^2}{2n(2n - 1)}\\ &amp;=\frac{(n + 1)n}{2(2n - 1)} \end{aligned} \] 终于搞出来了…… 代码不用贴了吧……（逃]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>TJOI</tag>
        <tag>广义二项式定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min_25筛学习笔记]]></title>
    <url>%2F2018%2F07%2F14%2FMIN-25-sieve%2F</url>
    <content type="text"><![CDATA[一直想学洲阁筛吧……（这就是我学Min_25筛的理由？） 然后今天终于能yy出来洲阁筛的复杂度证明了……（然后不想写（逃 然后发现了一种更优越的求积性函数前缀和的方法，叫做Min_25筛的……（虽然算是烂大街了？） Min_25筛 假设现在有一个积性函数\(f\)，我们知道他在质数的幂\(p^c\)上的表现\(f(p^c)\)，然后要去求它的前缀和。 Min_25筛有个重要的要求就是……\(f(p)\)（\(p\)为质数）事一个低次多项式或者一个方便求前缀和的东西。下面就谈谈为什么…… 我们先考虑对于所有状态\(\lfloor\frac{n}{x}\rfloor\)，求出范围内所有质数的答案。 看起来蛮棘手的……但我们考虑模仿洲阁筛，定义一个状态\(g(i, x)\)，表示\(x\)范围内事质数或者和前\(i\)个质数都互质的数的答案之和。如果说\(p_i\)达到了\(\lfloor\sqrt{n}\rfloor\)，那么显然\(g(i, x)\)就是\(x\)范围内所有质数的答案了（\(p_i\)表示第\(i\)个质数，下同）。 那么考虑转移（接下来出现的\(f(p_i)\)是指质数的答案多项式中的某一项，因为答案多项式要分开考虑）……对所有\(x\geq p_i^2\)，使用\(g(i, x) = g(i - 1, x) - f(p_i)(g(i - 1,\lfloor\frac{x}{p_i}\rfloor) - g(i - 1, p_i - 1))\)转移（之所以后面又补了一个东西是因为要把多减去的含小于\(p_i\)的质数的合数补回来）；至于\(x &lt; p_i^2\)，我们会发现答案以后就不会变了，因为答案全部都是一堆质数的答案的和（其中不大于\(p_i\)的一定不是合数，否则必定有小于等于\(p_i\)的质因子；倘使大于\(p_i\)的话，没有小于等于\(p_i\)的质因子也只能有且仅有一个大于\(p_i\)的质因子，当然就是质数了）。 这一步操作和洲阁筛几乎如出一辙，复杂度证明也完全一致（复杂度为\(O(\frac{n^{\frac{3}{4}}}{\ln n})\)）。 但是光考虑质数的答案没完惹……再定义状态\(f(i, x)\)表示\(x\)范围内和小于\(p_i\)的质数都互质的数的答案，最终答案显然就是\(f(1) + f(1, n)\)。那么考虑一个很暴力的策略： 先把质数的答案都算进来（之前预处理了），然后考虑合数的答案。考虑枚举所有不小于\(p_i\)的质数\(p\)（假设是第\(j\)个质数），如果说\(p^2 &gt; x\)了那么就没法往下转移了（因为这样用上\(p\)就没法构造合数了），break出来就行了；反之则枚举\(p\)在数中所占的正指数\(e\)，对于所有\(p^{e + 1}\leq x\)，对答案做\(f(j + 1, \lfloor\frac{x}{p^e}\rfloor)f(p^e) + f(p^{e + 1})\)的贡献（其实就是枚举是否选够了\(e\)个\(p\)，然后考虑只用\(p\)的若干次方的情况）。 这个方法看起来极其暴力（甚至也没记忆化），但是复杂度很玄学（也很优秀）……可以参考朱老大的集训队论文。 例题：SPOJ DIVCNT3 这个题显然有\(f(p^c) = 3c + 1\)，然后根据上面说的搞就行了…… 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;const int maxn = 400005;using ll = long long;int prm[maxn]; ll A[maxn], B[maxn];ll sqr(ll x) &#123; ll ret = 1; while((ret + 1LL) * (ret + 1LL) &lt;= x) ret ++; return ret;&#125;ll n, S;int cnt;void process() &#123; S = sqr(n); cnt = 0;#ifdef LOCAL printf("S : %lld\n", S);#endif for(int i = 1; i &lt;= S; i ++) &#123; A[i] = i; &#125; for(int i = 1; i &lt;= S; i ++) &#123; B[i] = n / (ll(i)); &#125; for(int i = 2; i &lt;= S; i ++) &#123; if(A[i] == A[i - 1]) continue; ll v = A[i - 1], lim = (ll(i)) * (ll(i)); for(int j = 1; j &lt;= (S / i); j ++) &#123; B[j] -= B[j * i] - v; &#125; for(int j = S / i + 1; j &lt;= S; j ++) &#123; ll th = n / (ll(j)); if(th &lt; lim) break; B[j] -= A[th / (ll(i))] - v; &#125; for(int j = S; (ll)j &gt;= lim; j --) &#123; A[j] -= A[j / (ll(i))] - v; &#125; prm[++ cnt] = i; &#125; prm[++ cnt] = S + 1LL;&#125;inline ll query(ll x) &#123; if(x &lt;= S) &#123; return A[x]; &#125; else &#123; return B[n / x]; &#125;&#125;ll calc(ll m, int x) &#123; if(m &lt; (ll)prm[x]) return 0; ll ret = 4LL * (query(m) - query(prm[x] - 1)); for(int i = x; i &lt;= cnt; i ++) &#123; ll mul = prm[i]; if(mul * (ll(prm[i])) &gt; m) break; for(int j = 1; ; j ++) &#123; if(mul * (ll(prm[i])) &gt; m) break; ret += calc(m / mul, i + 1) * (ll(3 * j + 1)) + (ll(3 * j + 4)); mul *= (ll(prm[i])); &#125; &#125; return ret;&#125;int main() &#123; int T; scanf("%d", &amp;T); while(T --) &#123; scanf("%lld", &amp;n); process(); printf("%lld\n", calc(n, 1) + 1LL); &#125; return 0;&#125;]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Min_25筛</tag>
        <tag>洲阁筛</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4261」建设游乐场]]></title>
    <url>%2F2018%2F07%2F11%2FBZOJ4261%2F</url>
    <content type="text"><![CDATA[Description 给定一个\(n\times m\)网格图，其中有一些点是障碍，有一些点是平原。 现在要求你用若干无重边无自环的不相交简单环覆盖所有平原。有一些点\((i, j)\)如果满足经过的两条边一条是横着的一套是竖着的那么就会获得\(V_{i, j}\)的收益。 求是否有解，如果有解的话输出最大收益。 \(n\le 150\)，\(m\le 30\)，\(0\le V_{i, j}\le 100\)。 Solution 算是坑了很久的传统艺能题，，， 首先先来一步传统艺能：假设所有收益都能获得，然后问题转化成使笋丝尽可能小，也就变成了如果有一个地方是直的话就会有笋丝。 考虑黑白染色，我们钦点只从黑点往白点连边，这样的话每个黑点要向两个不同的白点（不能走到障碍上）连边。我们要希望所有点都弯着走，我们大可以把所有点全部拆成两个点，一个表示横着走一个表示竖着走，分别向源/汇连容量为1的边，同时他们再往相邻的横着/竖着相邻的点连容量为1的边。 但问题是有些时候有些点肯定只能直着走。那可以用“弯直转换”来表示，具体方法就是把一个点拆出来的横竖点互连容量为1费用为\(V_{i, j}\)的边。 最后关于是否有解的判定……最后的流量就是原网格图中用了的边的数量，对于每个环的边数都等于点数，因此总边数要等于总点数，因此最后的流量要等于平地的总数量才算有解。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int maxn = (150 * 30) * 2 + 5;struct Edge &#123; int u, v, cap, flow, cost;&#125;;std::vector&lt;int&gt; G[maxn];std::vector&lt;Edge&gt; E;inline void add_edge(int u, int v, int cap, int cost) &#123; E.push_back((Edge)&#123;u, v, cap, 0, cost&#125;); E.push_back((Edge)&#123;v, u, 0, 0, -cost&#125;); int m = E.size(); G[u].push_back(m - 2); G[v].push_back(m - 1);&#125;int a[maxn], d[maxn], p[maxn];bool inq[maxn];int num;const int INF = 0x3f3f3f3f;inline bool spfa(int s, int t, int &amp;flow, int &amp;cost) &#123; std::fill(a, a + num + 1, 0); std::fill(d, d + num + 1, INF); std::fill(p, p + num + 1, 0); std::fill(inq, inq + num + 1, false); std::queue&lt;int&gt; Q; Q.push(s); d[s] = 0; a[s] = INF; inq[s] = true; while(!Q.empty()) &#123; int u = Q.front(); Q.pop(); inq[u] = false; for(int i = 0; i &lt; G[u].size(); i ++) &#123; Edge &amp;e = E[G[u][i]]; int v = e.v; if(e.cap &gt; e.flow &amp;&amp; d[u] + e.cost &lt; d[v]) &#123; d[v] = d[u] + e.cost; p[v] = G[u][i]; a[v] = std::min(a[u], e.cap - e.flow); if(!inq[v]) Q.push(v), inq[v] = true; &#125; &#125; &#125; if(d[t] &gt;= INF) return false; flow += a[t]; cost += d[t] * a[t];#ifdef LOCAL printf("flow delta : %d\n", a[t]); printf("cost delta : %d\n", d[t] * a[t]);#endif int u = t; while(u != s) &#123; Edge &amp;e = E[p[u]]; e.flow += a[t]; E[p[u] ^ 1].flow -= a[t]; u = e.u; &#125; return true;&#125;inline void MCMF(int s, int t, int &amp;flow, int &amp;cost) &#123; while(spfa(s, t, flow, cost));&#125;int n, m;inline int get_p(int i, int j, int t) &#123; int ret = (i - 1) * m + j; ret = ret * 2 - 1 + t; return ret;&#125;int A[155][35], V[155][35];int main() &#123; scanf("%d%d", &amp;n, &amp;m); int s = 0, t = n * m * 2 + 1; num = t; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; scanf("%d", &amp;A[i][j]); &#125; &#125; int ans = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; scanf("%d", &amp;V[i][j]); if(!A[i][j]) ans += V[i][j]; &#125; &#125; int cnt = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = 1; j &lt;= m; j ++) &#123; if(A[i][j]) continue; cnt ++; int p0 = get_p(i, j, 0), p1 = get_p(i, j, 1); add_edge(p0, p1, 1, V[i][j]); add_edge(p1, p0, 1, V[i][j]); if((i + j) &amp; 1) &#123; add_edge(p0, t, 1, 0); add_edge(p1, t, 1, 0); &#125; else &#123; add_edge(s, p0, 1, 0); add_edge(s, p1, 1, 0); if(i &gt; 1 &amp;&amp; !A[i - 1][j]) &#123; add_edge(p0, get_p(i - 1, j, 0), 1, 0); &#125; if(i &lt; n &amp;&amp; !A[i + 1][j]) &#123; add_edge(p0, get_p(i + 1, j, 0), 1, 0); &#125; if(j &gt; 1 &amp;&amp; !A[i][j - 1]) &#123; add_edge(p1, get_p(i, j - 1, 1), 1, 0); &#125; if(j &lt; m &amp;&amp; !A[i][j + 1]) &#123; add_edge(p1, get_p(i, j + 1, 1), 1, 0); &#125; &#125; &#125; &#125;#ifdef LOCAL printf("tot : %d\n", ans);#endif int flow = 0, cost = 0; MCMF(s, t, flow, cost); if(flow &lt; cnt) &#123; puts("-1"); &#125; else &#123; printf("%d\n", ans - cost); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝尔级数在积性函数毒瘤题中的应用]]></title>
    <url>%2F2018%2F07%2F11%2Fbell-series%2F</url>
    <content type="text"><![CDATA[嗯，OC！ 一直以来，数论生成函数在积性函数毒瘤题中的应用都不是很多…… 数论函数的生成函数大概有三种：狄利克雷级数（也叫数论生成函数）、贝尔级数、Lambert级数。Lambert级数不了解，狄利克雷级数太复杂（需要一些复分析的水平，恰好我没有……），能派上用场的也就只有贝尔级数力，，， 下文主要介绍贝尔级数的基本概念，在狄利克雷卷积中的应用，以及在积性函数求和（对我书得就事杜教筛）中的一些微小的应用…… 贝尔级数的概念 贝尔级数的定义 贝尔级数是一种形式幂级数。对于给定的数论函数\(f\)和质数\(p\)，我们定义\(f\)模\(p\)的贝尔级数为： \[ f_p(x)=\sum_{i = 0}^{+\infty} f(p^i)x^i \] 贝尔级数的基本性质 唯一定理 对于两个积性函数\(f\)和\(g\)，如果对于任意质数\(p\)都有\(f\)和\(g\)模\(p\)的贝尔级数相同，那两者相同。 这个定理我局的还事挺好理解的……两个积性函数在任何质数的幂的表现都相同，那么两者也相同。 因为一般的数论函数没有这么优秀的性质……所以下面提到的贝尔级数的应用基本上都针对积性函数…… 狄利克雷卷积 对任意两个数论函数\(f\)和\(g\)，有\((f\ast g)_p(x) = f_p(x)\cdot g_p(x)\)。 这是贝尔级数最有用的性质了……（没这个性质用它干啥？） 完全积性函数的贝尔级数 对于一个完全积性函数\(f\)，有\(f_p(x)=\frac{1}{1 - f(p)x}\)。 这个也不难理解，用的就是等比数列求和公式。不过好在事形式幂级数，并不需要考虑收敛的问题…… 常用积性函数函数的贝尔级数 关于狄利克雷卷积的单位元\(\epsilon\)（\(\epsilon(x) = [x=1]\)），不必自说当然是\(1\)。 首先对于\(f(x) = x^k(k\in N^0)\)这种东西，根据完全积性函数的贝尔级数公式可知有\(f_p(x)=\frac{1}{1 - p^kx}\)。 莫比乌斯函数比较有意思。显然\(\mu(1) = 1\)，\(\mu(p) = -1\)，但是\(\mu(p^k)=0(k\ge 2)\)。所以说其贝尔级数就是\(1-x\)。类似我们可以推导得\(\mu^2\)的贝尔级数为\(1+x\)。 欧拉函数直接推有些棘手……但注意到我们知道\(\varphi\ast 1 = \mathrm{id}\)，反演一下可以得知\(\mathrm{id}\ast\mu =\varphi\)，由此可得\(\varphi_p(x)=\frac{1 - x}{1 - px}\)。 接下来介绍一个非常好玩的函数：刘维尔函数。在此之前先定义\(\Omega(n)\)表示\(n\)的可重复质因子数（因此\(\Omega(4) = 2\)），那么刘维尔函数\(\lambda(x) = (-1)^{\Omega(x)}\)，这个函数很显然是完全积性函数，故\(\lambda_p(x)=\frac{1}{1 + x}\)。这个函数有些时候是肥肠有用的。 然后考虑约数好兄弟\(\sigma_k\)。很显然\(\sigma_k = \mathrm{id}^k\ast 1\)，因此可以推出\((\sigma_k)_p(x)=\frac{1}{1 - p^kx}\cdot\frac{1}{1 - x} = \frac{1}{1 - (1 + p^k)x + p^kx^2}\)。 至此常见积性函数已经推完力，，， 贝尔级数在狄利克雷卷积中的应用 这个还算是很显然吧…… 举个例子，让你证\((\mathrm{id}\cdot\mu)\ast\mathrm{id} = \epsilon\)。 这个东西用传统的计数解方法当然可行，但是多麻烦事有目共睹的（甚至于有些东西被我们的当结论记了）。用贝尔级数的话这个等式不就是\((1 - px)\cdot\frac{1}{1 - px} = 1\)嘛，非常简单。 还有一些比较复杂的例子，大家可以自行寻找。 贝尔级数在杜教筛中的应用 这个东西算是最大应用了吧…… 应用主要分为两部分：你知道\(f\)本身是啥，但是不知道找啥去卷比较好；你不知道\(f\)本身是啥（你只知道它在质数的幂上表现），但你还是要杜教筛。 利用贝尔级数构造合适的狄利克雷卷积 给一道题吧：求\(\mu^2\ast (\mathrm{id}\cdot\mu)\)这个东西的前缀和，\(n\le 10^{11}\)。 如果你不知道贝尔级数，你可能需要靠背上面提到的那个用传统方法很难证的结论来做这个题…… 但如果说你知道贝尔级数的话，你发现原函数贝尔级数为\((1 + x)(1 - px)\)，然后我们想肯定要消掉一部分或者全部式子。我们考虑卷上一个\(\mathrm{id}\)，弄完了之后的贝尔级数为\(1 + x\)，也就是\(\mu^2\)。 \(\mathrm{id}\)的前缀和自然好说，但是\(\mu^2\)的前缀和咋整？ 其实\(\mu^2\)就是判断它是否没有完全平方因子。因此我们直接枚举那个因子的平方根就好了，但是这样会重复，因此考虑用\(\mu\)容斥一下，得到： \[ \sum_{i = 1}^n\mu^2(i)=\sum_{i = 1}^{\lfloor\sqrt{n}\rfloor}\mu(i)\lfloor\frac{n}{i^2}\rfloor \] 因此\(\mu^2\)的前缀和是可以根号复杂度来求的，不会影响杜教筛总的转移复杂度。因此总复杂度为\(O(n^{\frac{2}{3}})\)。 在不知道函数本身是啥的时候杜教筛 还是给一道题： 有一个积性函数\(f(x)\)，你不知道它本身是啥，但是你知道他满足以下性质： \(f(1) = 1\)。 对于质数\(p\)和正整数\(a\)，有\(f(p^a) = p^a + (-1)^a\)。 求这玩意的前缀和，\(n\le 10^{11}\)。 其实你通过OEIS可以知道这个函数本身是啥（逃），但考虑到那样你也很难用常规手段杜教筛所以还事没啥用…… 首先考虑去构造这个玩意的贝尔级数。它看起来很像事\(\mathrm{id}\)和\(\lambda\)的贝尔级数加一下，但是考虑到\(f(1) = 1\)因此还要再减个1。最后得到： \[ f_p(x)=\frac{1}{1 - px} + \frac{1}{1 + x} - 1 \] 我们想要卷上一个\(g\)，那些分母看起来很不顺眼，干脆把他们都消掉了吧！因此我们规定\(g_p(x) = (1 - px)(1 + x)\)（因此我们得知\(g = (\mathrm{id}\cdot\mu)\ast\mu^2\)）。卷出来之后发现： \[ (f\ast g)_p(x) = 1 + x + 1 - px - 1 - x + px + px^2 = 1 + px^2 \] 然后我们弄了一大半顿我们还是不知道\(f\ast g\)具体是啥……但是我们观察到一点非常重要的性质：若\((f\ast g)(x)\ne 0\)，那么\(x\)起码也得是完全平方数，并且\(\mu^2(\sqrt{x}) = 1\)，并且对答案的贡献为\(\sqrt{x}\)！ 这下\(f\ast g\)虽然还不知道是啥，但是起码它前缀和好求了！我们对于对答案可能有贡献的\(x\)枚举其算术平方根即可，写出来就是： \[ \sum_{i = 1}^n(f\ast g)(i) = \sum_{i = 1}^{\lfloor\sqrt{n}\rfloor}\mu^2(i)i \] 这样的话求\(f\ast g\)的前缀和的复杂度就已经降到\(O(\sqrt{n})\)了，更进一步我们发现这个式子的答案只和\(\lfloor\sqrt{n}\rfloor\)有关，所以我们用\(O(\sqrt{n})\)的时间预处理所有这种和之后\(O(1)\)查询就好了。 剩下唯一的硬骨头就是\(g\)的前缀和，这个上一小节已经讲了。 虽说这玩意蛮有用的……但是无法阻止杜教筛过气，常熟优秀还好想的MIN_25筛已经要dssq力（悲）]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>狄利克雷卷积</tag>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
        <tag>贝尔级数</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些测试]]></title>
    <url>%2F2018%2F07%2F11%2Ftest%2F</url>
    <content type="text"><![CDATA[一级标题 二级标题 三级标题 四级标题 五级标题 行内公式：\(\int_{-\infty}^{+\infty}e^{x^2}\mathrm{d}x\)。 行间公式： \[ \int u\mathrm{d}v = uv - \int v\mathrm{d}u \] 123456// C++ code#include &lt;cstdio&gt;int main() &#123; int a, b; scanf("%d%d", &amp;a, &amp;b); printf("%d\n", a + b); return 0;&#125; 嗯，OC！]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
